/**
 * Copyright (c) 2004-2005, Regents of the University of California
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * Neither the name of the University of California, Los Angeles nor the
 * names of its contributors may be used to endorse or promote products
 * derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * This file implements a parser for the instruction set description language
 * that is used by Avrora to generate an optimized interpreter as well as
 * an abstract interpreter, visitors, instruction representations, etc.
 *
 * @author Ben L. Titzer
 **/
options {
  LOOKAHEAD = 1;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = false;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  IGNORE_CASE = false;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  FORCE_LA_CHECK = false;
}


PARSER_BEGIN(ISDLParser)

package jintgen.isdl.parser;
import jintgen.jigir.*;
import jintgen.isdl.*;
import java.util.List;
import java.util.LinkedList;

public class ISDLParser {

    Architecture arch;

}

PARSER_END(ISDLParser)

/* WHITE SPACE */

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

/* COMMENTS */

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
|
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}


/* RESERVED WORDS AND LITERALS */

TOKEN :
{
  < INTEGER_LITERAL:
       (<DECIMAL_LITERAL> | <HEX_LITERAL> | <BIN_LITERAL> | <OCTAL_LITERAL>)
  >
|
  < #DECIMAL_LITERAL: (("-")? ["1"-"9"] (["0"-"9"])*) >
|
  < #HEX_LITERAL: (("0" ["x","X"])) (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #BIN_LITERAL: "0" ["b","B"] (["0", "1"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
}

/* Reserved words */
TOKEN :
{
    < INSTRUCTION : "instruction" >
  | < ARCHITECTURE : "architecture" >
  | < FORMAT : "format" >
  | < ENUM : "enum" >
  | < OPERAND_TYPE : "operand-type" >
  | < ADDR_MODE : "addr-mode" >
  | < ADDR_SET : "addr-set" >
  | < READ : "read" >
  | < WRITE : "write" >
  | < WHERE : "where" >
  | < PRIORITY : "priority" >
  | < ENCODING : "encoding" >
  | < EXECUTE : "execute" >
  | < LOCAL : "local" >
  | < GLOBAL : "global" >
  | < MEMORY : "memory" >
  | < MAPPING : "mapping" >
  | < IF : "if" >
  | < ELSE : "else" >
  | < AND: "and" >
  | < OR: "or" >
  | < XOR: "xor" >
  | < SUBROUTINE: "subroutine" >
  | < INLINE: "inline" >
  | < EXTERNAL: "external" >
  | < RETURN: "return" >
  | < BOOLEAN_LITERAL: "true" | "false" >
  | < SYMBOL: "symbol" >
  | < PSEUDO: "pseudo" >
  | < WHEN : "when" >
  | < PROPERTY: "property" >
}

TOKEN :
{
    < LBRACKET: "{" >
  | < RBRACKET: "}" >
  | < EQUALS: "=" >
  | < COMMA: "," >
  | < LPAREN: "(" >
  | < RPAREN: ")" >
  | < SEMI: ";" >
  | < SHIFTLEFT: "<<" >
  | < SHIFTRIGHT: ">>" >
  | < ADD: "+" >
  | < SUB: "-" >
  | < MUL: "*" >
  | < DIV: "/" >
  | < B_AND: "&" >
  | < B_OR: "|" >
  | < B_XOR: "^" >
  | < NOT: "!" >
  | < B_COMP: "~" >
  | < EQUAL: "==" >
  | < NOTEQUAL: "!=" >
  | < LESS: "<" >
  | < LESSEQ: "<=" >
  | < GREATER: ">" >
  | < GREATEREQ: ">=" >
  | < DOLLAR: "$" >
}

/* Instruction MNEMONICS */

/* IDENTIFIERS */

TOKEN :
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < #LETTER:
      [ "a"-"z", "A"-"Z", "_"]
  >
|
  < #DIGIT:
      [ "0"-"9" ]
  >
}


/* Begin GRAMMAR */


Architecture Architecture() : { Token n; }
{
    "architecture" n = <IDENTIFIER> { arch = new Architecture(n); }"{"
        (Item())*
    "}" { return arch; }
}

void Item() : {}
{
    Instruction()
  | Enum()
  | FormatDecl()
  | OperandTypeDecl()
  | Subroutine()
  | AddrModeDecl()
  | AddrSetDecl()
  | StateDecl()
}

void Instruction() :
{
    Token n;
    AddrModeUse am;
    List<Stmt> s = new LinkedList<Stmt>();
    List<Property> p = new LinkedList<Property>();
    EncodingDecl e = null;
    boolean pseudo = false;
}
{
    ["pseudo" { pseudo = true; }] "instruction" n = <STRING_LITERAL> am = AddrModeUse(n) "{"
        ( e = Encoding(n) { am.addEncoding(e); })*
        ( Property(p) )*
        [ s = Execute(s) ]

    "}" { arch.addInstruction(new InstrDecl(pseudo, n, am, p, s)); }
}

void Enum() : { Token n; SymbolMapping m = new SymbolMapping(); }
{
    "enum" n = <IDENTIFIER> "{"
        MappingSetElem(m) ("," MappingSetElem(m))*
    "}"
}

AddrModeUse AddrModeUse(Token n) : { List<AddressingModeDecl.Operand> o; }
{
    (":" n = <IDENTIFIER> { return new AddrModeUse(n, null); })
   |(o = Operands() { return new AddrModeUse(null, new AddressingModeDecl(n, o)); })
}

void Property(List<Property> p) : { Token name, t, v;}
{
    "property" name = <IDENTIFIER> ":" t = Type() "=" v = Value() ";" { p.add(new Property(name, t, v)); }
}

Token Value() : { Token t = null; }
{
  ( t = <STRING_LITERAL>
  | t = <IDENTIFIER>
  | t = <BOOLEAN_LITERAL>
  | t = <INTEGER_LITERAL>)
  { return t; }
}

void StateDecl() : {}
{
    Global()
  | Memory()
}

void Global() : { Token n; }
{
    "global" n = <IDENTIFIER> ":" Type() ";"
}

void Memory() : { Token n; }
{
    "memory" <DOLLAR> n = <IDENTIFIER> "(" MapType() ")" ":" MapType() ";"
}

void AddrModeDecl() : {
    Token n;
    List<AddressingModeDecl.Operand> o;
    List<Property> p = new LinkedList<Property>();
    EncodingDecl e;
}
{
    "addr-mode" n = <IDENTIFIER> o = Operands() "{"
        (Property(p)
        | e = Encoding(n)
        )*
    "}" { arch.addAddressingMode(new AddressingModeDecl(n, o)); }
}

void AddrSetDecl() : { Token n; List<Token> l = new LinkedList<Token>(); Token e; }
{
    "addr-set" n = <IDENTIFIER> "{"
        e = <IDENTIFIER> { l.add(e); }
        ("," e = <IDENTIFIER> { l.add(e); })*
    "}"
    { arch.addAddressingModeSet(new AddressingModeSetDecl(n, l)); }
}

EncodingDecl Encoding(Token n) : { EncodingDecl d; EncodingDecl.Cond ec = null; }
{
    "encoding" "=" d = Format(n) [ec = EncodingCond() { d.setCond(ec); }] { return d; }
}

EncodingDecl.Cond EncodingCond() : { Token n; Expr e; }
{
    "when" n = <IDENTIFIER> "==" e = Expr() { return new EncodingDecl.Cond(n, e); }
}

List<Stmt> Execute(List<Stmt> s) : { }
{
    "execute" Block(s) { return s; }
}

void FormatDecl() : { Token n; EncodingDecl d; }
{
    "format" n = <IDENTIFIER> "=" d = Format(n) { arch.addEncoding(d); }
}

void OperandTypeDecl() : { Token n; OperandTypeDecl d; }
{
    "operand-type" n = <IDENTIFIER>  ( d = SimpleOperandType(n) | d = CompoundOperandType(n) )
    { arch.addOperand(d); }
}

OperandTypeDecl SimpleOperandType(Token n) : { Token b; OperandTypeDecl d; }
{
    "[" b = <INTEGER_LITERAL> "]" ":"
    (d = SymbolOperand(n, b) | d = ValueOperand(n, b))
    { return d; }
}

OperandTypeDecl SymbolOperand(Token n, Token b) :
{
  SymbolMapping m = new SymbolMapping();
  OperandTypeDecl.SymbolSet sd = new OperandTypeDecl.SymbolSet(n, b, m);
}
{
    "symbol" OperandBody(sd, m)
    { return sd; }
}

OperandTypeDecl ValueOperand(Token n, Token b) :
{
  Token t, l, h;
  SymbolMapping m = new SymbolMapping();
  OperandTypeDecl.Value vd;
}
{
   (t = Type() "[" l = <INTEGER_LITERAL> "," h = <INTEGER_LITERAL> "]")
    { vd = new OperandTypeDecl.Value(n, b, t, l, h); }
   ( OperandBody(vd, m) | ";" )
    { return vd; }
}

OperandTypeDecl CompoundOperandType(Token n) :
{
    SymbolMapping m = new SymbolMapping();
    OperandTypeDecl.Compound cd = new OperandTypeDecl.Compound(n);
}
{
    OperandBody(cd, m)
    { return cd; }

}

void OperandBody(OperandTypeDecl td, SymbolMapping m) : { }
{
    "{"
    ( SymbolMapping(m)
    | ReadMethod(td)
    | WriteMethod(td)
    | SubOperand(td) )*
    "}"
}

void SubOperand(OperandTypeDecl td) : { AddressingModeDecl.Operand o; }
{
    "sub-operand" o = Operand() { td.addSubOperand(o); } ";"
}

void ReadMethod(OperandTypeDecl td) : { List<Stmt> s = new LinkedList<Stmt>(); }
{
    "read" ":" Type() Block(s)
}

void WriteMethod(OperandTypeDecl td) : { List<Stmt> s = new LinkedList<Stmt>(); }
{
    "write" ":" Type() Block(s)
}

void SymbolMapping(SymbolMapping m) : {  }
{
    "mapping" "{" MappingSetElem(m) ("," MappingSetElem(m))* "}"
}

void MappingSetElem(SymbolMapping m) : { Token n, i; }
{
    (n = <IDENTIFIER> "=" i = <INTEGER_LITERAL>)
    { m.add(n, i); }
}

EncodingDecl Format(Token n) : { Token pr = null; EncodingDecl d; }
{
   ["priority" pr = <INTEGER_LITERAL>] (d = DerivedFormat(pr, n) | d = NewFormat(pr, n)) { return d; }
}

EncodingDecl DerivedFormat(Token pr, Token n) :
{
    Token p;
    EncodingDecl d;
    List<EncodingDecl.Substitution> l = new LinkedList<EncodingDecl.Substitution>();
}
{
    p = <IDENTIFIER> ["where" l = SubstitutionList()]
    { return new EncodingDecl.Derived(n, pr, p, l); }
}

EncodingDecl NewFormat(Token pr, Token n) : { List<Expr> l; }
{
    "{" l = ExprList() "}" { return new EncodingDecl(n, pr, l); }
}

List<EncodingDecl.Substitution> SubstitutionList() :
{
    List<EncodingDecl.Substitution> l = new LinkedList<EncodingDecl.Substitution>();
    EncodingDecl.Substitution s;
}
{
    "{" s = Substitution() { l.add(s); } ("," s = Substitution() { l.add(s); })* "}" { return l; }
}

EncodingDecl.Substitution Substitution() : { Token n; Expr e; }
{
    n = <IDENTIFIER> "=" e = Expr() { return new EncodingDecl.Substitution(n, e); }
}

List<AddressingModeDecl.Operand> Operands() :
{
    AddressingModeDecl.Operand o;
    List<AddressingModeDecl.Operand> l = new LinkedList<AddressingModeDecl.Operand>();
}
{
    [ o = Operand() { l.add(o); } ("," o = Operand() { l.add(o); })* ] { return l; }
}

AddressingModeDecl.Operand Operand() : { Token n, t; }
{
    n = <IDENTIFIER> ":" t = OperandType() { return new AddressingModeDecl.Operand(n, t); }
}

void Subroutine() :
{
    boolean i = false;
    Token m, r;
    List<SubroutineDecl.Parameter> f;
    List<Stmt> l = new LinkedList<Stmt>();
}
{
    (["inline" { i = true; }] "subroutine" m = <IDENTIFIER>
       "(" f = Params() ")" ":" r = <IDENTIFIER> Block(l)
        { arch.addSubroutine(new SubroutineDecl(i, m, f, r, l)); } )
   |("external" "subroutine" m = <IDENTIFIER> "(" f = Params() ")" ":" r = <IDENTIFIER> ";"
        { arch.addSubroutine(new SubroutineDecl(i, m, f, r, null)); } )

}

List<SubroutineDecl.Parameter> Params() :
{
    SubroutineDecl.Parameter p;
    List<SubroutineDecl.Parameter> l = new LinkedList<SubroutineDecl.Parameter>();
}
{
    [ p = Param() { l.add(p); } ("," p = Param() { l.add(p); })* ] { return l; }
}

SubroutineDecl.Parameter Param() : { Token n, t; }
{
    n = <IDENTIFIER> ":" t = Type() { return new SubroutineDecl.Parameter(n, t); }
}

Expr Expr() : { Expr e; }
{
    e = Cond_Or_Expr() { return e; }
}

List<Expr> ExprList() : { List<Expr> l = new LinkedList<Expr>(); Expr e; }
{
    (e = Expr() { l.add(e); } ("," e = Expr() { l.add(e); } )*)
    { return l; }
}

Expr Term() : { Expr e; }
{
    ( LOOKAHEAD(2) e = CallExpr()
    | LOOKAHEAD(2) e = DotExpr()
    | e = VarUse()
    | e = Literal()
    | e = MapAccess()
    | "(" e = Expr() ")"
    )
    [e = BitRange(e)]
    [e = Conversion(e)]
    { return e; }
}

Expr Conversion(Expr e) : { Token t; }
{
  ":" t = <IDENTIFIER> { return new ConversionExpr(e, t); }
}

Expr MapAccess() : { Expr e; Token t; }
{
  "$" t = <IDENTIFIER> "(" e = Expr() ")" { return new MapExpr(t, e); }
}

Expr VarUse() : { Token t; }
{
  t = <IDENTIFIER> { return new VarExpr(t); }
}

Expr DotExpr() : { Token o, f; }
{
    o = <IDENTIFIER> "." f = <IDENTIFIER> { return new DotExpr(o, f); }
}

Expr Literal() : { Token t; }
{
  (t = <INTEGER_LITERAL> { return new Literal.IntExpr(t); })
 |(t = <BOOLEAN_LITERAL> { return new Literal.BoolExpr(t); })
}

Expr CallExpr() : { Token t; List<Expr> l; }
{
  t = Method() l = Parameters() { return new CallExpr(t, l); }
}

Token Method() : { Token m; }
{
 (
   m = <IDENTIFIER>
 | m = "read"
 | m = "write"
 ) { return m; }
}

List<Expr> Parameters() : { List<Expr> l = new LinkedList<Expr>(); }
{
    "(" [ l = ExprList() ] ")"
    { return l; }
}

Stmt Statement() : { Stmt s; }
{
  (
    s = LocalDecl()
  | s = IfStatement()
  | LOOKAHEAD(2) s = Assignment()
  | s = CallStmt()
  | s = ReturnStmt()
  ) { return s; }
}

DeclStmt LocalDecl() : { Token n, t; Expr e; }
{
    "local" n = <IDENTIFIER> ":" t = <IDENTIFIER> "=" e = Expr() ";"
    { return new DeclStmt(n, t, e); }
}

IfStmt IfStatement() : { Expr c; List<Stmt> t = new LinkedList<Stmt>(), f = new LinkedList<Stmt>(); }
{
    "if" "(" c = Expr() ")" SingleStatement(t)
        [ LOOKAHEAD(1) "else" SingleStatement(f) ]
    { return new IfStmt(c, t, f); }
}

ReturnStmt ReturnStmt() : { Expr e; }
{
    "return" e = Expr() ";" { return new ReturnStmt(e); }
}

void SingleStatement(List<Stmt> l) : { Stmt s; }
{
    s = Statement() { l.add(s); } | (Block(l))
}

AssignStmt Assignment() : { AssignStmt s; }
{
    ( s = VarAssignment()
    | s = MapAssignment()) ";"
    { return s; }
}

CallStmt CallStmt() : { Token m; List<Expr> l; }
{
    m = Method() l = Parameters() ";" { return new CallStmt(m, l); }
}

AssignStmt VarAssignment() : { AssignStmt s; Token v, i, j; Expr e; }
{
    (v = <IDENTIFIER> s = VarAssignEnd(v))
    { return s; }
}

AssignStmt VarAssignEnd(Token v) : { AssignStmt s; Token i, j; Expr e, b; }
{
    (("=" e = Expr() { s = new VarAssignStmt(v, e); })
    | LOOKAHEAD(3) ("[" i = <INTEGER_LITERAL> ":" j = <INTEGER_LITERAL> "]"
      "=" e = Expr() { s = new VarBitRangeAssignStmt(v, i, j, e); })
    |("[" b = Expr() "]"
      "=" e = Expr() { s = new VarBitAssignStmt(v, b, e); })
    ) { return s; }
}

AssignStmt MapAssignment() : { AssignStmt s; Token v, i, j; Expr ind, e; }
{
    "$" v = <IDENTIFIER> "(" ind = Expr() ")" s = MapAssignmentEnd(v, ind)
    { return s; }
}

AssignStmt MapAssignmentEnd(Token v, Expr ind) : { AssignStmt s; Token i, j; Expr e, b; }
{
    (
     ("=" e = Expr() { s = new MapAssignStmt(v, ind, e); })
    | LOOKAHEAD(3) ("[" i = <INTEGER_LITERAL> ":" j = <INTEGER_LITERAL> "]"
      "=" e = Expr() { s = new MapBitRangeAssignStmt(v, ind, i, j, e); })
    |("[" b = Expr() "]"
      "=" e = Expr() { s = new MapBitAssignStmt(v, ind, b, e); })
    ) { return s; }
}

List<Stmt> Block(List<Stmt> l) : { Stmt s; }
{
    "{" (s = Statement() { l.add(s); })* "}"
    { return l; }
}

Expr BitRange(Expr e) : { Expr et; Token t1, t2; }
{
    "["
    (LOOKAHEAD(2) (t1 = <INTEGER_LITERAL> ":" t2 = <INTEGER_LITERAL>
     { e =  new BitRangeExpr(e, t1, t2); })
   | (et = Expr()
     { e = new BitExpr(e, et); }))
    "]"
    { return e; }
}


Expr Cond_Or_Expr() : { Expr e, et; Token tok; }
{
  e = Cond_Xor_Expr()
  ( tok = "or" et = Cond_Xor_Expr()
    { e = new Logical.OrExpr(e, et); } )*
  { return e; }
}

Expr Cond_Xor_Expr() : { Expr e, et; Token tok; }
{
  e = Cond_And_Expr()
  ( tok = "xor" et = Cond_And_Expr()
    { e = new Logical.XorExpr(e, et); } )*
  { return e; }
}

Expr Cond_And_Expr() : { Expr e, et; Token tok; }
{
  e = Or_Expr()
  ( tok = "and" et = Or_Expr()
    { e = new Logical.AndExpr(e, et); } )*
  { return e; }
}

Expr Or_Expr() : { Expr e, et; Token tok; }
{
  e = Xor_Expr()
  ( tok = "|" et = Xor_Expr()
    { e = new Arith.OrExpr(e, et); } )*
  { return e; }
}

Expr Xor_Expr() : { Expr e, et; Token tok; }
{
  e = And_Expr()
  ( tok = "^" et = And_Expr()
    { e = new Arith.XorExpr(e, et); } )*
  { return e; }
}

Expr And_Expr() : { Expr e, et; Token tok; }
{
  e = Equ_Expr()
  ( tok = "&" et = Equ_Expr()
    { e = new Arith.AndExpr(e, et); } )*
  { return e; }
}

Expr Equ_Expr() : { Expr e, et; }
{
  e = Rel_Expr() (
    ("==" et = Rel_Expr() { e = new Logical.EquExpr(e, et); })
   |("!=" et = Rel_Expr() { e = new Logical.NequExpr(e, et); })
  )*
  { return e; }
}

Expr Rel_Expr() : { Expr e, et; Token tok; }
{
  e = Shift_Expr() (
    ("<"  et = Shift_Expr() { e = new Logical.LessExpr(e, et); } )
   |(">"  et = Shift_Expr() { e = new Logical.GreaterExpr(e, et); } )
   |("<=" et = Shift_Expr() { e = new Logical.LessEquExpr(e, et); } )
   |(">=" et = Shift_Expr() { e = new Logical.GreaterEquExpr(e, et); } )
  )*
  { return e; }
}

Expr Shift_Expr() : { Expr e, et; Token tok; }
{
  e = Add_Expr() (
    ("<<" et = Add_Expr() { e = new Arith.ShiftLeftExpr(e, et); } )
   |(">>" et = Add_Expr() { e = new Arith.ShiftRightExpr(e, et); } )
  )*
  { return e; }
}

Expr Add_Expr() : { Expr e, et; Token tok; }
{
  e = Mul_Expr() (
    ("+" et = Mul_Expr() { e = new Arith.AddExpr(e, et); } )
   |("-" et = Mul_Expr() { e = new Arith.SubExpr(e, et); } )
  )*
  { return e; }
}

Expr Mul_Expr() : { Expr e, et; Token tok; }
{
  e = Un_Expr() (
    ("*" et = Un_Expr() { e = new Arith.MulExpr(e, et); } )
   |("/" et = Un_Expr() { e = new Arith.DivExpr(e, et); } )
  )*
  { return e; }
}

Expr Un_Expr() : { Expr e; }
{
   (
    ("~" e = Term() { e = new Arith.CompExpr(e); })
   |("!" e = Term() { e = new Logical.NotExpr(e); })
   |("-" e = Term() { e = new Arith.NegExpr(e); })
   |(e = Term())
   )
  { return e; }
}

Token MapType() : { Token t; }
{
    ( t = "symbol" | t = Type() )
    { return t; }
}

Token Type() : { Token t; }
{
    t = <IDENTIFIER> { return t; }
}

Token OperandType() : { Token t; }
{
    t = <IDENTIFIER> { return t; }
}