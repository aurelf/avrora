
//
//  instruction set description of the Texas Instruments MSP430 microcontroller
//
architecture msp430 {

//---------------------------------------------------------------------------
//  ENCODING FORMATS OF INSTRUCTIONS
//---------------------------------------------------------------------------

    format SINGLE_OP = { opcode[8:0], bw[0], As[1:0], sreg[3:0] }
    format SINGLE_OP_X = { opcode[8:0], bw[0], As[1:0], sreg[3:0], X[15:0] }
    format DOUBLE_OP = { opcode[3:0], sreg[3:0], Ad[0], bw[0], As[1:0], dreg[3:0] }
    format DOUBLE_OP_X = { opcode[3:0], sreg[3:0], Ad[0], bw[0], As[1:0], dreg[3:0], X[15:0] }
    format DOUBLE_OP_XY = { opcode[3:0], sreg[3:0], Ad[0], bw[0], As[1:0], dreg[3:0], X[15:0], Y[15:0] }
    format JUMP_OP = { opcode[5:0], offset[9:0] }

//---------------------------------------------------------------------------
//  MEMORY ALLOWED TO INSTRUCTIONS
//---------------------------------------------------------------------------
    memory $regs(GPR): short;
    memory $sram(int): byte; // a "view" of the memory as bytes
    memory $wsram(int): short; // a "view" of the memory as shorts

    global C: boolean;
    global N: boolean;
    global Z: boolean;
    global V: boolean;

    global nextPC: int;
    global cyclesConsumed: int;

//----------------------------------------------------------------------------------
//  OPERANDS ALLOWED FOR INSTRUCTIONS
//----------------------------------------------------------------------------------

    // all registers
    enum GPR {
        pc  = 0,  sp   = 1,  sr  = 2,  // aliases for the first three registers
        r0  = 0,  r1   = 1,  r2  = 2,  r3  = 3,
        r4  = 4,  r5   = 5,  r6  = 6,  r7  = 7,
        r8  = 8,  r9   = 9,  r10 = 10, r11 = 11,
        r12 = 12, r13  = 13, r14 = 14, r15 = 15
    }

     // source registers r2 - r15
    enum-subset SREG: GPR {
        r2 = 2, r3  = 3,  r4  = 4,  r5  = 5,  r6  = 6,  r7  = 7,  r8 = 8,
        r9 = 9, r10 = 10, r11 = 11, r12 = 12, r13 = 13, r14 = 14, r15 = 15
    }

    operand-type SREG[4]: SREG {
	    read: short { return $regs(this); }
	    write: short { $regs(this) = value; }
	}

    operand-type AIREG_B[4]: SREG {                    //Indirect AutoIncrement mode
	    read: byte {
	        local val: short = $regs(this);               //the value of val provides the address of contents to modify
	        $regs(this) = val + 1;                       //the original register's contents are incremented
	        return val: byte;
	    }
	    write: byte {  }                              //valid only as a source operand
	}

    operand-type AIREG_W[4]: SREG {
	    read: short {
	        local addr: short = $regs(this);
	        local val: short = $sram(addr);
	        $regs(this) = addr + 2;
	        return val;
	    }
	    write: short { }
	}

    operand-type IREG[4]: SREG {                    //Indirect register mode
	    read: byte {
	        local addr: short = $regs(this);
	        local val: byte = $sram(addr);
	        return val: byte;
	    }
	    write: byte { }
	}

    operand-type IMM[16]: immediate [-32768,65536];

    operand-type INDX {
        sub-operand reg: SREG;
        sub-operand index: IMM;
	    read: byte { return $sram(read(reg) + index); }
	    write: byte { $sram(read(reg) + index) = value; }
    }

    // TODO: this is encoded as relative to the pc
    operand-type SYM[16]: immediate [0,0xFFFF] {
        read: byte { return $sram(pc + this); }
        write: byte {$sram(pc + this) = value; }
    }

    operand-type ABSO[16]: immediate [0,0xFFFF] {
	    read: byte { return $sram(this); }
	    write: byte { $sram(this) = value; }
    }

    operand-type JUMP[10]: immediate [0,0x3FF];

//-------------------------------------------------------------------------- 
//   ADDRESSING MODES ALLOWED FOR SINGLE OPERAND/DOUBLE OPERAND/JUMP INSTRUCTIONS
//-------------------------------------------------------------------------   
    addr-mode REG source: SREG {
        encoding = priority 5 SINGLE_OP where { As = 0b00, sreg = source }
	    property syntax: String = "%source";
	    property cycles: int = 1;
    }

    addr-mode REGREG source: SREG, dest: SREG {         //addressing modes like REGREG, REGIND_W, etc are double operand
        encoding = priority 5 DOUBLE_OP where { As = 0b00, Ad = 0, sreg = source, dreg = dest }
        property syntax: String = "%source, %dest";
        property cycles: int = 1;
    }

    addr-mode REGIND source: SREG, dest: INDX {
        encoding = priority 5 DOUBLE_OP_X where { As = 0b00, Ad = 1, sreg = source, dreg = dest.reg, X = dest.index }
	    property syntax: String = "%source, %dest.index(%dest.reg)";
	    property cycles: int = 4;
    }

    addr-mode REGSYM source: SREG, dest: SYM {
        // SYMolic mode is encoded as indexing off of the PC register
        encoding = priority 4 DOUBLE_OP_X where { As = 0b00, Ad = 1, sreg = source, dreg = 0b0000, X = dest }
	    property syntax: String = "%source, %dest";
	    property cycles: int = 4;
    }

    addr-mode REGABS source: SREG, dest: ABSO {
        // absolute mode (as destination) is encoded as indexing off of dreg = R2
        encoding = priority 4 DOUBLE_OP_X where { As = 0b00, Ad = 1, sreg = source, dreg = 0b0010, X = dest }
	    property syntax: String = "%source, &%dest";
       	property cycles: int = 4;
    }

    addr-mode IND source: INDX {
        encoding = priority 5 SINGLE_OP_X where { As = 0b01, sreg = source.reg, X = source.index }
        property syntax: String = "%source.index(%source.reg)";
        property cycles: int = 4;
    }

    addr-mode INDREG source: INDX, dest: SREG {
        encoding = priority 5 DOUBLE_OP_X where { As = 0b01, Ad = 0, sreg = source.reg, dreg = dest.reg, X = source.index }
        property syntax: String = "%source.index(%source.reg), %dest";
        property cycles: int = 3;
    }

    addr-mode INDIND source: INDX, dest: INDX {
        encoding = priority 5 DOUBLE_OP_XY where { As = 0b01, Ad = 1, sreg = source.reg, dreg = dest.reg, X = source.index, Y = dest.index }
        property syntax: String = "%source.index(%source.reg), %dest.index(%dest.reg)";
        property cycles: int = 6;
    }

    addr-mode SYM source: SYM {
        encoding = priority 2 SINGLE_OP_X where { As = 0b01, sreg = 0b0000, X = source }
        property syntax: String = "%source";
        property cycles: int = 4;
    }

    addr-mode SYMREG source: SYM, dest: SREG {
        encoding = priority 3 DOUBLE_OP_X where { As = 0b01, Ad = 0, sreg = 0b0000, dreg = dest, X = source }
        property syntax: String = "%source, %dest";
        property cycles: int = 3;
    }

    addr-mode INDSYM source: INDX, dest: SYM {
        encoding = priority 4 DOUBLE_OP_XY where { As = 0b01, Ad = 1, sreg = source.reg, dreg = 0b0000, X = source.index, Y = dest.index }
        property syntax: String = "%source.index(%source.reg), %dest";
        property cycles: int = 6;
    }

    addr-mode INDABS source: INDX, dest: ABSO {
        encoding = priority 4 DOUBLE_OP_XY where { As = 0b01, Ad = 1, sreg = source.reg, dreg = 0b0010, X = source.index, Y = dest }
        property syntax: String = "%source.index(%source.reg), &%dest";
        property cycles: int = 6;
    }

    addr-mode SYMABS source: SYM, dest: ABSO {
        encoding = priority 2 DOUBLE_OP_XY where { As = 0b01, Ad = 1, sreg = 0b0000, dreg = 0b0010, X = source, Y = dest }
        property syntax: String = "%source, &%dest";
        property cycles: int = 6;
    }

    addr-mode SYMIND source: SYM, dest: INDX {
        encoding = priority 3 DOUBLE_OP_XY where { As = 0b01, Ad = 1, sreg = 0b0000, dreg = dest.reg, X = source, Y = dest.index }
        property syntax: String = "%source, %dest.index(%dest.reg)";
        property cycles: int = 6;
    }

    addr-mode SYMSYM source : SYM, dest: SYM {
        encoding = priority 2 DOUBLE_OP_XY where { As = 0b01, Ad = 1, sreg = 0b0000, dreg = 0b0000, X = source, Y = dest }
        property syntax: String = "%source, %dest";
        property cycles: int = 6;
    }

    addr-mode ABSSYM source: ABSO, dest: SYM {
        encoding = priority 2 DOUBLE_OP_XY where { As = 0b01, Ad = 1, sreg = 0b0010, dreg = 0b0000, X = source, Y = dest }
        property syntax: String = "&%source, %dest";
        property cycles: int = 6;
    }

    addr-mode ABS source: ABSO {
        encoding = priority 2 SINGLE_OP_X where { As = 0b01, sreg = 0b0010, X = source }
        property syntax: String = "&%source";
        property cycles: int = 4;
    }

    addr-mode ABSREG source: ABSO, dest: SREG {
        encoding = priority 3 DOUBLE_OP_X where { As = 0b01, Ad = 0, sreg = 0b0010, dreg = dest, X = source }
        property syntax: String = "&%source, %dest";
        property cycles: int = 3;
    }

    addr-mode ABSIND source: ABSO, dest: INDX {
        encoding = priority 3 DOUBLE_OP_XY where { As = 0b01, Ad = 1, sreg = 0b0010, dreg = dest.reg, X = source, Y = dest.index }
        property syntax: String = "&%source, %dest.index(%dest.reg)";
        property cycles: int = 6;
    }

    addr-mode ABSABS source: ABSO, dest: ABSO {
        encoding = priority 2 DOUBLE_OP_XY where { As = 0b01, Ad = 1, sreg = 0b0010, dreg = 0b0010, X = source, Y = dest }
        property syntax: String = "&%source, &%dest";
        property cycles: int = 6;
    }

    addr-mode IREGSYM source: IREG, dest: SYM {
        encoding = priority 4 DOUBLE_OP_X where { As = 0b10, Ad = 1, sreg = source, dreg = 0b0000, X = dest }
        property syntax: String = "@%source, %dest";
        property cycles: int = 5;
    }

    addr-mode IREG source: IREG {
        encoding = priority 5 SINGLE_OP_X where { As = 0b10, sreg = source }
        property syntax: String = "@%source";
        property cycles: int = 3;
    }

    addr-mode IREGREG source: IREG, dest: SREG {
        encoding = priority 5 DOUBLE_OP where { As = 0b10, Ad = 0, sreg = source, dreg = dest }
        property syntax: String = "@%source, %dest";
        property cycles: int = 2;
    }

    addr-mode IREGIND source: IREG, dest: INDX {
        encoding = priority 5 DOUBLE_OP_X where { As = 0b10, Ad = 1, sreg = source, dreg = dest.reg, X = dest.index }
        property syntax: String = "@%source, %dest.index(%dest.reg)";
        property cycles: int = 5;
    }

    addr-mode IREGABS source: IREG, dest: ABSO {
        encoding = priority 4 DOUBLE_OP_X where { As = 0b10, Ad = 1, sreg = source, dreg = 0b0010, X = dest }
        property syntax: String = "@%source, &%dest";
        property cycles: int = 5;
    }

    addr-mode IMM source: IMM {
        encoding = priority 1 SINGLE_OP_X where { As = 0b11, sreg = 0b0000, X = source }
        encoding = priority 0 SINGLE_OP where { As = 0b11, sreg = 0b0011 } when source == -1 // encodes as R3, As = 0b11
        encoding = priority 0 SINGLE_OP where { As = 0b00, sreg = 0b0011 } when source == 0  // encodes as R2, As = 0b10
        encoding = priority 0 SINGLE_OP where { As = 0b01, sreg = 0b0011 } when source == 1  // encodes as R3, As = 0b01
        encoding = priority 0 SINGLE_OP where { As = 0b10, sreg = 0b0011 } when source == 2
        encoding = priority 0 SINGLE_OP where { As = 0b10, sreg = 0b0010 } when source == 4
        encoding = priority 0 SINGLE_OP where { As = 0b11, sreg = 0b0010 } when source == 8
        property syntax: String = "#%source";
        property cycles: int = 4;
    }

    addr-mode IMMREG source: IMM, dest: SREG {
        encoding = priority 1 DOUBLE_OP_X where { As = 0b11, Ad = 0, sreg = 0b0000, dreg = dest, X = source }
        encoding = priority 1 DOUBLE_OP where { As = 0b11, Ad = 0, sreg = 0b0011, dreg = dest } when source == -1 // encodes as R3, As = 0b11
        encoding = priority 1 DOUBLE_OP where { As = 0b00, Ad = 0, sreg = 0b0011, dreg = dest } when source == 0  // encodes as R2, As = 0b10
        encoding = priority 1 DOUBLE_OP where { As = 0b01, Ad = 0, sreg = 0b0011, dreg = dest } when source == 1  // encodes as R3, As = 0b01
        encoding = priority 1 DOUBLE_OP where { As = 0b10, Ad = 0, sreg = 0b0011, dreg = dest } when source == 2
        encoding = priority 1 DOUBLE_OP where { As = 0b10, Ad = 0, sreg = 0b0010, dreg = dest } when source == 4
        encoding = priority 1 DOUBLE_OP where { As = 0b11, Ad = 0, sreg = 0b0010, dreg = dest } when source == 8
        property syntax: String = "#%source, %dest";
        property cycles: int = 2;
    }

    addr-mode IMMIND source: IMM, dest: INDX {
        encoding = priority 1 DOUBLE_OP_XY where { As = 0b11, Ad = 1, sreg = 0b0000, dreg = dest.reg, X = source, Y = dest.index }
        encoding = priority 1 DOUBLE_OP_X where { As = 0b11, Ad = 1, sreg = 0b0011, dreg = dest.reg, X = dest.index } when source == -1 // encodes as R3, As = 0b11
        encoding = priority 1 DOUBLE_OP_X where { As = 0b00, Ad = 1, sreg = 0b0011, dreg = dest.reg, X = dest.index } when source == 0  // encodes as R2, As = 0b10
        encoding = priority 1 DOUBLE_OP_X where { As = 0b01, Ad = 1, sreg = 0b0011, dreg = dest.reg, X = dest.index } when source == 1  // encodes as R3, As = 0b01
        encoding = priority 1 DOUBLE_OP_X where { As = 0b10, Ad = 1, sreg = 0b0011, dreg = dest.reg, X = dest.index } when source == 2
        encoding = priority 1 DOUBLE_OP_X where { As = 0b10, Ad = 1, sreg = 0b0010, dreg = dest.reg, X = dest.index } when source == 4
        encoding = priority 1 DOUBLE_OP_X where { As = 0b11, Ad = 1, sreg = 0b0010, dreg = dest.reg, X = dest.index } when source == 8
        property syntax: String = "#%source, %dest.index(%dest.reg)";
        property cycles: int = 5;
    }

    addr-mode IMMSYM source: IMM, dest: SYM {
        encoding = priority 0 DOUBLE_OP_XY where { As = 0b11, Ad = 1, sreg = 0b0000, dreg = 0b0000, X = source, Y = dest.index }
        encoding = priority 0 DOUBLE_OP_X where { As = 0b11, Ad = 1, sreg = 0b0011, dreg = 0b0000, X = dest } when source == -1 // encodes as R3, As = 0b11
        encoding = priority 0 DOUBLE_OP_X where { As = 0b00, Ad = 1, sreg = 0b0011, dreg = 0b0000, X = dest } when source == 0  // encodes as R2, As = 0b10
        encoding = priority 0 DOUBLE_OP_X where { As = 0b01, Ad = 1, sreg = 0b0011, dreg = 0b0000, X = dest } when source == 1  // encodes as R3, As = 0b01
        encoding = priority 0 DOUBLE_OP_X where { As = 0b10, Ad = 1, sreg = 0b0011, dreg = 0b0000, X = dest } when source == 2
        encoding = priority 0 DOUBLE_OP_X where { As = 0b10, Ad = 1, sreg = 0b0010, dreg = 0b0000, X = dest } when source == 4
        encoding = priority 0 DOUBLE_OP_X where { As = 0b11, Ad = 1, sreg = 0b0010, dreg = 0b0000, X = dest } when source == 8
        property syntax: String = "#%source, %dest";
        property cycles: int = 5;
    }

    addr-mode IMMABS source: IMM, dest: ABSO {
        encoding = priority 0 DOUBLE_OP_XY where { As = 0b11, Ad = 1, sreg = 0b0000, dreg = 0b0010, X = source, Y = dest.index }
        encoding = priority 0 DOUBLE_OP_X where { As = 0b11, Ad = 1, sreg = 0b0011, dreg = 0b0010, X = dest } when source == -1 // encodes as R3, As = 0b11
        encoding = priority 0 DOUBLE_OP_X where { As = 0b00, Ad = 1, sreg = 0b0011, dreg = 0b0010, X = dest } when source == 0  // encodes as R2, As = 0b10
        encoding = priority 0 DOUBLE_OP_X where { As = 0b01, Ad = 1, sreg = 0b0011, dreg = 0b0010, X = dest } when source == 1  // encodes as R3, As = 0b01
        encoding = priority 0 DOUBLE_OP_X where { As = 0b10, Ad = 1, sreg = 0b0011, dreg = 0b0010, X = dest } when source == 2
        encoding = priority 0 DOUBLE_OP_X where { As = 0b10, Ad = 1, sreg = 0b0010, dreg = 0b0010, X = dest } when source == 4
        encoding = priority 0 DOUBLE_OP_X where { As = 0b11, Ad = 1, sreg = 0b0010, dreg = 0b0010, X = dest } when source == 8
        property syntax: String = "#%source, &%dest";
        property cycles: int = 5;
    }

    addr-mode AUTO_B source: AIREG_B {
        encoding = priority 5 SINGLE_OP where { As = 0b11, sreg = source }
	    property syntax: String = "@%source+";
	    property cycles: int = 3;
    }

    addr-mode AUTOREG_B source: AIREG_B, dest: SREG {
        encoding = priority 5 DOUBLE_OP where { As = 0b11, Ad = 0, sreg = source, dreg = dest }
        property syntax: String = "@%source+, %dest";
        property cycles: int = 2;
    }

    addr-mode AUTOIND_B source: AIREG_B, dest: INDX {
        encoding = priority 5 DOUBLE_OP_X where { As = 0b11, Ad = 1, sreg = source, dreg = dest.reg, X = dest.index }
        property syntax: String = "@%source+, %dest.index(%dest.reg)";
        property cycles: int = 5;
    }

    addr-mode AUTOSYM_B source: AIREG_B, dest: SYM {
        encoding = priority 4 DOUBLE_OP_X where { As = 0b11, Ad = 1, sreg = source, dreg = 0b0000, X = dest }
        property syntax: String = "@%source+, %dest";
        property cycles: int = 5;
    }

    addr-mode AUTOABS_B source: AIREG_B, dest: ABSO {
        encoding = priority 4 DOUBLE_OP_X where { As = 0b11, Ad = 1, sreg = source, dreg = 0b0010, X = dest }
        property syntax: String = "@%source+, %dest";
        property cycles: int = 5;
    }

    addr-mode AUTO_W source: AIREG_W {
        encoding = priority 5 SINGLE_OP where { As = 0b11, sreg = source }
	    property syntax: String = "@%source+";
	    property cycles: int = 3;
    }

    addr-mode AUTOREG_W source: AIREG_W, dest: SREG {
        encoding = priority 5 DOUBLE_OP where { As = 0b11, Ad = 0, sreg = source, dreg = dest }
        property syntax: String = "@%source+, %dest";
        property cycles: int = 2;
    }

    addr-mode AUTOIND_W source: AIREG_W, dest: INDX {
        encoding = priority 5 DOUBLE_OP_X where { As = 0b11, Ad = 1, sreg = source, dreg = dest.reg, X = dest.index }
        property syntax: String = "@%source+, %dest.index(%dest.reg)";
        property cycles: int = 5;
    }

    addr-mode AUTOSYM_W source: AIREG_W, dest: SYM {
        encoding = priority 4 DOUBLE_OP_X where { As = 0b11, Ad = 1, sreg = source, dreg = 0b0000, X = dest }
        property syntax: String = "@%source+, %dest";
        property cycles: int = 5;
    }

    addr-mode AUTOABS_W source: AIREG_W, dest: ABSO {
        encoding = priority 4 DOUBLE_OP_X where { As = 0b11, Ad = 1, sreg = source, dreg = 0b0010, X = dest }
        property syntax: String = "@%source+, %dest";
        property cycles: int = 5;
    }

     addr-mode JMP source: JUMP {
         encoding = JUMP_OP where { offset = source }
         property syntax: String = "%offset";
         property cycles: int = 2;
     }

    //--------------------------------------------------------------------------
    //   Begin WORD addressing modes
    //--------------------------------------------------------------------------

    addr-set DOUBLE_W {
        REGREG,
        REGIND,
        REGSYM,
        REGABS,
        INDREG,
        INDIND,
        INDSYM,
        INDABS,
        SYMREG,
        SYMIND,
        SYMSYM,
        SYMABS,
        ABSREG,
        ABSIND,
        ABSSYM,
        ABSABS,
        IREGREG,
        IREGIND,
        IREGSYM,
        IREGABS,
        AUTOREG_W,
        AUTOIND_W,
        AUTOSYM_W,
        AUTOABS_W,
        IMMREG,
        IMMIND,
        IMMSYM,
        IMMABS
    }

    addr-set SINGLE_W {
        REG,
        IND,
        SYM,
        ABS,
        IREG,
        AUTO_W,
        IMM
    }

    addr-set DOUBLE_B {
        REGREG,
        REGIND,
        REGSYM,
        REGABS,
        INDREG,
        INDIND,
        INDSYM,
        INDABS,
        SYMREG,
        SYMIND,
        SYMSYM,
        SYMABS,
        ABSREG,
        ABSIND,
        ABSSYM,
        ABSABS,
        IREGREG,
        IREGIND,
        IREGSYM,
        IREGABS,
        AUTOREG_B,
        AUTOIND_B,
        AUTOSYM_B,
        AUTOABS_B,
        IMMREG,
        IMMIND,
        IMMSYM,
        IMMABS
    }

    addr-set SINGLE_B {
        REG,
        IND,
        SYM,
        ABS,
        IREG,
        AUTO_B,
        IMM
    }

//---------------------------------------------------------------------------
//  SUBROUTINES
//---------------------------------------------------------------------------
    inline subroutine performAddition(r1: int, r2: int, carry: int): byte {
        local result: int = r1 + r2 + carry;
        local ral: int = r1[3:0];
        local rbl: int = r2[3:0];

        local Rd7: boolean = r1[7];
        local Rr7: boolean = r2[7];
        local R7: boolean = result[7];

        // set the flags as per instruction set documentation.
        C = result[8];
        N = result[7];
        Z = low(result) == 0;
        V = (Rd7 and Rr7 and !R7) or (!Rd7 and !Rr7 and R7);

        return low(result);
    }

    inline subroutine performAdditionW(r1: int, r2: int, carry: int): word {
        local result: int = r1 + r2 + carry;
        local ral: int = r1[7:0];
        local rbl: int = r2[7:0];

        local Rd15: boolean = r1[15];
        local Rr15: boolean = r2[15];
        local R15: boolean  = result[15];

        C = result[16];
        N = result[15];
        Z = (result == 0);
        V = (Rd15 and Rr15 and !R15) or (!Rd15 and !Rr15 and R15);

        return result;
    }
	

    inline subroutine performSubtraction(r1: int, r2: int, carry: int): byte {
        local result: int = r1 - r2 - carry;

        local Rd7: boolean = r1[7];
        local Rr7: boolean = r2[7];
        local R7:  boolean = result[7];
        local Rd3: boolean = r1[3];
        local Rr3: boolean = r2[3];
        local R3:  boolean = result[3];

        // set the flags as per instruction set documentation.
        C = (!Rd7 and Rr7) or (Rr7 and R7) or (R7 and !Rd7);
        N = R7;
        Z = low(result) == 0;
        V = (Rd7 and !Rr7 and !R7) or (!Rd7 and Rr7 and R7);

        return low(result);
    }
    inline subroutine performSubtractionW(r1: int, r2: int, carry: int): word {
        local result: int = r1 - r2 - carry;

        local Rd15: boolean = r1[15];
        local Rr15: boolean = r2[15];
        local R15:  boolean = result[15];
        local Rd7: boolean = r1[7];
        local Rr7: boolean = r2[7];
        local R7:  boolean = result[7];

        // set the flags as per instruction set documentation.

        C = (!Rd15 and Rr15) or (Rr15 and R15) or (R15 and !Rd15);
        N = R15;
        Z = (low(result) == 0 and high(result) == 0);
        V = (Rd15 and !Rr15 and !R15) or (!Rd15 and Rr15 and R15);
       
        return result;
    }


    inline subroutine performAnd(r1: int, r2: int): byte {
        local result: int = r1 & r2;

        N = result[7];
        Z = low(result) == 0;
        V = false;
        C = !N;

        return low(result);
    }

    inline subroutine performAndW(r1: int, r2: int): word {
        local result: int = r1 & r2;

        N = result[15];
        C = !N;
        Z = (result == 0);
        V = 0;
    }

    subroutine performDeciAddCW(r1: int, r2: int, carry: int): word {
        local reg1: int = r1;
        local reg2: int = r2;
        local result: int = 0;

        // TODO: this code will not work: e.g. 9 + 9 = 18 (overflow)
        reg1[3:0] = reg1[3:0] + carry;
        result[3:0] = reg1[3:0] + reg2[3:0];
        if (result[3:0] > 10) {
            result[3:0] = result[3:0] - 10;
            reg1[7:4] = reg1[7:4] + 1;
        }
        result[7:4] = reg1[7:4] + reg2[7:4];
        if (result[7:4] > 10) {
            result[7:4] = result[7:4] - 10;
            reg1[11:8] = reg1[11:8] + 1;
        }
        result[11:8] = reg1[11:8] + reg2[11:8];
        if (result[11:8] > 10) {
            result[11:8] = result[11:8] - 10;
            reg1[15:12] = reg1[15:12] + 1;
        }
        result[15:12] = reg1[15:12] + reg2[15:12];
        if (result[15:12] > 10) {
            result[15:12] = result[15:12] - 10;
            C = 1;
        }
        N = result[15];
        Z = !(result);
        return result;
    }

    subroutine performDeciAddC(r1: int, r2: int, carry: int): byte {
        local reg1: int = r1;
        local reg2: int = r2;
        local result: int = 0;

        reg1[3:0] = reg1[3:0] + carry;
        result[3:0] = reg1[3:0] + reg2[3:0];
        if (result[3:0] > 10) {
            result[3:0] = result[3:0] - 10;
            reg1[7:4] = reg1[7:4] + 1;
        }
        result[7:4] = reg1[7:4] + reg2[7:4];
        if (result[7:4] > 10) {
            result[7:4] = result[7:4] - 10;
            C = 1;
        }
        N = result[7];
        Z = !(result);
        return result[7:0];
    }

    inline subroutine relativeBranch(target: int): void {
        nextPC = relative(target);
        cyclesConsumed = cyclesConsumed + 1;
    }

    inline subroutine relative(target: int): int {
        return (target * 2) + nextPC;
    }

    inline subroutine absolute(target: int): int {
        return target * 2;
    }

    inline subroutine skip(): void {
        local dist: int = $isize(nextPC);
        nextPC = nextPC + dist;
        if ( dist == 4 ) cyclesConsumed = cyclesConsumed + 2;
        else cyclesConsumed = cyclesConsumed + 1;
    }

    inline subroutine pushPC(npc: int): void {
        npc = npc / 2;
        pushByte(low(npc));
        pushByte(high(npc));
    }

    inline subroutine popPC(): int {
        local high: byte = popByte();
        local low: byte = popByte();
        return uword(low, high) * 2;
    }

    inline subroutine low(v: int): byte {
        return v: byte;
    }

    inline subroutine high(v: int): byte {
        return (v >> 8): byte;
    }

    inline subroutine uword(low: byte, high: byte): int {
        return ((high << 8) | low)[15:0];
    }

    external subroutine bit(b: boolean): int;
    external subroutine popByte(): byte;
    external subroutine pushByte(b: byte): void;


//---------------------------------------------------------------------------
//  BEGIN INSTRUCTION SET DESCRIPTION
//---------------------------------------------------------------------------
	
    instruction "adc": SINGLE_W {
	    property bw: int = 1;
        property opcode: int = 0b0110;                     //opcode for ADDC (6) emulated to ADC
        execute {
            local r1: int       = read(source);
            local result: int   = r1 + bit(C);
                                    //word operation
            local R15: boolean  = result[15];
            local Rdh7: boolean = r1[15];
            C = (!R15 and Rdh7);
            N = (R15);
            V = (!Rdh7 and R15);
            Z = (result[15:0]  == 0);

            write(source, result: short);
        }
    }

    instruction "adc.b": SINGLE_B {
	    property bw: int = 0;
        property opcode: int = 0b0110;                     //opcode for ADDC (6) emulated to ADC
        execute {
            local r1: int       = read(source);
            local result: int   = r1 + bit(C);

            //byte operation
            local R7: boolean   = result[7];
            local Rdh1: boolean = r1[7];
            C = (!R7 and Rdh1);
            N = (R7);
            V = (!Rdh1 and R7);
            Z = (result[7:0]  == 0);

            write(source, result: byte);
        }
    }


    instruction "add": DOUBLE_W {
	    property bw: int = 1;
	    property opcode: int = 0b0101;
        execute {
            local r1: short = read(source);
            local r2: short = read(dest);
            local result: short = performAdditionW(r1, r2, 0);
            write(dest, result);
        }
    }

    instruction "add.b": DOUBLE_B {
	    property bw: int = 0;
        property opcode: int = 0b0101;
        execute {
            local r1: byte = read(source);
            local r2: byte = read(dest);
            local result: byte = performAddition(r1, r2, 0);
            write(dest, result);
        }
    }

    instruction "addc": DOUBLE_W {
	    property bw: int = 1;
        property opcode: int = 0b0110;
        execute {
            local r1: short = read(source);
            local r2: short = read(dest);
            local result: short = performAdditionW(r1, r2, bit(C));
            write(dest, result);
        }
    }

    instruction "addc.b": DOUBLE_B {
	    property bw: int = 0;
        property opcode: int = 0b0110;
    	execute {
            local r1: byte = read(source);
            local r2: byte = read(dest);
            local result: byte = performAddition(r1, r2, bit(C));
            write(dest, result);
   	    }
    }

    instruction "and": DOUBLE_W {
	    property bw: int = 1;
	    property opcode: int = 0b1111;
	    execute {
            local r1: short = read(source);
            local r2: short = read(dest);
            local result: short = performAndW(r1, r2);
            write(dest, result);
        }
    }

    instruction "and.b": DOUBLE_B {
	    property bw: int = 0;
	    property opcode: int = 0b1111;
	    execute {
            local r1: byte = read(source);
            local r2: byte = read(dest);
            local result: byte = performAnd(r1, r2);
            write(dest, result);
        }
    }

    instruction "bic": DOUBLE_W {    //logical and on inverted source and dest
	    property bw: int = 1;
	    property opcode: int = 0b1100;                        //status bits are not affected
	    execute {
            write(dest, ~(read(source)) & read(dest));
        }
    }

    instruction "bic.b": DOUBLE_B {    //logical and on inverted source and dest
	    property bw: int = 0;
	    property opcode: int = 0b1100;                        //status bits are not affected
	    execute {
            write(dest, ~(read(source)) & read(dest));
        }
    }

    instruction "bis": DOUBLE_W {   //logical or on source and dest
	    property bw: int = 1;
        property opcode: int = 0b1101;                       //status bits not affected
        execute {
            write(dest, read(source) | read(dest));
        }
     }

    instruction "bis.b": DOUBLE_B {   //logical or on source and dest
	    property bw: int = 0;
        property opcode: int = 0b1101;                       //status bits not affected
        execute {
            write(dest, read(source) | read(dest));
        }
     }

    instruction "bit": DOUBLE_W {   //test bits in dest by anding source
	    property bw: int = 1;
	    property opcode: int = 0b1011;                         //with dest and affecting only status bits
	    execute {
	        performAndW(read(source), read(dest));
        }
    }

    instruction "bit.b": DOUBLE_B {   //test bits in dest by anding source
	    property bw: int = 0;
	    property opcode: int = 0b1011;                         //with dest and affecting only status bits
	    execute {
	        performAndW(read(source), read(dest));
        }
    }

    pseudo instruction "br": SINGLE_W {  //uncondtional branch emulated by moving
	    property bw: int = 1;
	    property opcode: int = 0b0100;                     //operand to Program counter
	    execute {
		    // emulated by MOV instruction
	        nextPC = read(source);
	    }
    }

    instruction "call": SINGLE_W {     //calls a subroutine from 64k address space
        // TODO: double check this opcode
	    property bw: int = 1;
	    property opcode: int = 0b000100101;          //stores old pc on TOS while jumping to subroutine
	    execute {
            local temp: int = read(source);  //r1 is the SP, r0 is the PC
            pushPC(nextPC);
            nextPC = temp;
        }
    }

    pseudo instruction "clr": SINGLE_W {             //emulated by MOV instruction
	    property bw: int = 1;
    	property opcode: int = 0b0100;
        execute {
            // note: the read is necessary for the auto-increment operands
            read(source);
            write(source, 0);
        }
    }

    pseudo instruction "clr.b": SINGLE_B {           //emulated by MOV instruction
	    property bw: int = 0;
	    property opcode: int = 0b0100;
	    execute {
            // note: the read is necessary for the auto-increment operands
            read(source);
            write(source, 0);
	    }
    }


    pseudo instruction "clrc" {               //clear carry bit by anding with #1
	    property bw: int = 1;
	    property opcode: int = 0b1100;
        execute {
		    //emulated by BIC instruction
            C = false;
	    }
    }

    pseudo instruction "clrn" {             //clear neg. bit by anding with #4
	    property bw: int = 1;
	    property opcode: int = 0b1100;
        execute {
       		//emulated by BIC instruction
            N = false;
	    }
    }

    pseudo instruction "clrz" {
	    property bw: int = 1;
        property opcode: int = 0b1100;
        execute {
    		//emulated by BIC instruction
            Z = false;
	    }
    }

    instruction "cmp": DOUBLE_W {      // compares 2 operands by
	    property bw: int = 1;
	    property opcode: int = 0b1001;                   // adding source with inverted dest
	    execute {                        // and adding 1 to the result
	        performAdditionW(read(source), ~(read(dest)), 1);
        }
    }

    instruction "cmp.b": DOUBLE_B {    // compares 2 operands by
	    property bw: int = 0;
    	property opcode: int = 0b1001;                   // adding source with inverted dest
	    execute {                        // and adding 1 to the result
	        performAddition(read(source), ~(read(dest)), 1);
        }
    }

    pseudo instruction "dadc": SINGLE_W {   // add carry decimally to dest
	    property bw: int = 1;
	    property opcode: int = 0b1010;                 // emulated by DADD instruction
	    execute {
	        write(source, performDeciAddCW(0, read(source), bit(C)));
	    }
    }

    pseudo instruction "dadc.b": SINGLE_B {   // add carry decimally to dest
	    property bw: int = 0;
	    property opcode: int = 0b1010;                   // emulated by DADD instruction
	    execute {
	        write(source, performDeciAddC(0, read(source), bit(C)));
	    }
    }

    instruction "dadd": DOUBLE_W {  //source and carry added decimally to dest
	    property bw: int = 1;
	    property opcode: int = 0b1010;
	    execute {
	        write(dest, performDeciAddCW(read(source), read(dest), bit(C)));
	    }
    }

    instruction "dadd.b": DOUBLE_B {  //source and carry added decimally to dest
	    property bw: int = 0;
	    property opcode: int = 0b1010;
	    execute {
	        write(dest, performDeciAddC(read(source), read(dest), bit(C)));
	    }
    }

    pseudo instruction "dec": SINGLE_W  {
	    property bw: int = 1;
	    property opcode: int = 0b1000;        // emulated by subtraction operation
	    execute {
	        local original: short = read(source);
	        write(source, performSubtractionW(original, 1, 0));
 	        if (original == 1)
 	            N = 1;    // if original value of dest was 1, set N bit
        }
    }

    pseudo instruction "dec.b": SINGLE_B  {
	    property bw: int = 0;
	    property opcode: int = 0b1000;        //emulated by subtraction operation
	    execute {
	        local original: byte = read(source);
	        write(source, performSubtraction(original, 1, 0));
 	        if (original == 1)
 	            N = 1;    // if original value of dest was 1, set N bit
        }
    }

    pseudo instruction "decd": SINGLE_W {
	    property bw: int = 1;
	    property opcode: int = 0b1000;         //emulated by subtraction  operation
	    execute {
 	        local original: short = read(source);
            write(source, performSubtractionW(original, 2, 0));
	        if (original == 2)
	            N = 1;    //if original value of dest was 2, set N bit
	    }
    }

    pseudo instruction "decd.b": SINGLE_B {
	    property bw: int = 0;
	    property opcode: int = 0b1000;         //emulated by subtraction  operation
	    execute {
 	        local original: byte = read(source);
            write(source, performSubtraction(original, 2, 0));
	        if (original == 2)
	            N = 1;    //if original value of dest was 2, set N bit
	    }
    }

    pseudo instruction "dint" {       // disable general interrupts
	    property bw: int = 1;
        property opcode: int = 0b1100;       // emulated by BIC operation
	    execute {
	        disableInterrupts();
	    }
    }

    pseudo instruction "eint" {       // enable general interrupts
	    property bw: int = 1;
	    property opcode: int = 0b1101;       // emulated by BIS operation
	    execute {
	        enableInterrupts();
	    }
    }

    pseudo instruction "inc": SINGLE_W {     // increment dest
	    property bw: int = 1;
	    property opcode: int = 0b0101;                  // emulated by ADD operation
	    execute {
	        write(source, performAdditionW(read(source), 1, 0));
 	    }
    }

    pseudo instruction "inc.b": SINGLE_B {     // increment dest
	    property bw: int = 0;
	    property opcode: int = 0b0101;                    // emulated by ADD operation
	    execute {
	        write(source, performAdditionW(read(source), 1, 0));
 	    }
    }

    pseudo instruction "incd": SINGLE_W {      //double increment dest
	    property opcode: int = 0b0101;	    //emulated by ADD operation
	    execute {
	        write(source, performAdditionW(read(source), 2, 0));
	    }
    }

    pseudo instruction "incd.b": SINGLE_B {      //double increment dest
	    property bw: int = 0;
	    property opcode: int = 0b0101;	    //emulated by ADD operation
	    execute {
	        write(source, performAdditionW(read(source), 2, 0));
	    }
    }

    pseudo instruction "inv": SINGLE_W  {       //invert dest
	    property bw: int = 1;
	    property opcode: int = 0b1110;    //emulated by XOR operation
	    execute {
   	        local result: int = ~(read(source));
	        N = result[15];             //set if neg.
	        Z = (result == 0xFFFF);  //set if contains 0FFFFh
	        C = !(result == 0);      //set if result not 0
	        V = ($regs(rd) < 0);     //set if original contents neg.
	        write(source, result: short);
	    }
    }

    pseudo instruction "inv.b": SINGLE_B  {       //invert dest
	    property bw: int = 0;
	    property opcode: int = 0b1110;    //emulated by XOR operation
	    execute {
   	        local result: int = ~(read(source));
	        N = results[7];             //set if neg.
	        Z = (results == 0xFF);  //set if contains 0FFh
	        C = !(results == 0);      //set if result not 0
	        V = (low($regs(rd)) < 0);     //set if original contents neg.
	        write(source, low(result));
	    }
    }

    instruction "jc": JMP  {      //jump if carry set
	    property opcode: int = 0b001011;
	    execute {
 	        if ( C ) {
 	            nextPC = nextPC + 2 * read(source);
	        }
        }
    }

    pseudo instruction "jhs": JMP  {      //jump if higher or same
	    property opcode: int = 0b001011;
	    execute {
 	        if ( C ) {
 	            nextPC = nextPC + 2 * read(source);
	        }
        }
    }

    instruction "jeq": JMP {      //jump if equal
	    property opcode: int = 0b001001;
	    execute {
	        if ( Z ) {
 	            nextPC = nextPC + 2 * read(source);
            }
        }
    }

    pseudo instruction "jz": JMP {      //jump if zero
	    property opcode: int = 0b001001;
	    execute {
	        if ( Z ) {
 	            nextPC = nextPC + 2 * read(source);
            }
        }
    }

    instruction "jge": JMP {   //jump if greater or equal
	    property opcode: int = 0b001101;
	    execute {
	        if ( Z xor N ) {
 	            nextPC = nextPC + 2 * read(source);
	        }
	    }
    }

    instruction "jl": JMP {   //jump if less
        property opcode: int = 0b001110;
        execute {
             if ( N xor V ) {
 	            nextPC = nextPC + 2 * read(source);
             }
    	 }
    }

    instruction "jmp": JMP {  //jump unconditionally
	    property opcode: int = 0b001111;
	    execute {
            //jump to address listed by 10 bit offset, unconditionally
 	        nextPC = nextPC + 2 * read(source);
	    }
    }

    instruction "jn": JMP {   //jump if negative
	    property opcode: int = 0b001100;
	    execute {
	        if ( N ) {
			    //if N = 1, jump to address listed by 10 bit offset
 	            nextPC = nextPC + 2 * read(source);
	        }
        }
    }

    instruction "jnc": JMP {  //jump if carry not set
	    property opcode: int = 0b001010;
	    execute {
	        if ( !C ) {
			    //if C != 0, jump to address listed by 10 bit offset
 	            nextPC = nextPC + 2 * read(source);
	        }
        }
    }

    pseudo instruction "jlo": JMP {  //jump if carry not set
	    property opcode: int = 0b001010;
	    execute {
            if ( !C ) {
                //if C != 0, jump to address listed by 10 bit offset
 	            nextPC = nextPC + 2 * read(source);
            }
        }
    }

    instruction "jne": JMP {  //jump if not equal
        property opcode: int = 0b001000;
        execute {
            if ( !Z ) {
                //if Z != 0, jump to address listed by 10 bit offset
 	            nextPC = nextPC + 2 * read(source);
            }
        }
    }

    pseudo instruction "jnz": JMP {  //jump if not equal
	    property opcode: int = 0b001000;
	    execute {
	        if ( !Z ) {
			    //if Z != 0, jump to address listed by 10 bit offset
 	            nextPC = nextPC + 2 * read(source);
	        }
	    }
    }

    instruction "mov": DOUBLE_W {  //move source to dest
	    property bw: int = 1;
        property opcode: int = 0b0100;
        execute {
            write(dest, read(source));
        }
    }

    instruction "mov.b": DOUBLE_B {  //move source to dest
	    property bw: int = 0;
        property opcode: int = 0b0100;
        execute {
            write(dest, read(source));
        }
    }

    pseudo instruction "nop" {   //no operation
        property opcode: int = 0b0100;     //emulated by MOV operation
        execute {
        }
    }

    pseudo instruction "pop": SINGLE_W  {  // pop word from stack to dest
	    property bw: int = 1;
        property opcode: int = 0b0100;   // emulated by MOV operation
        execute {
            write(source, popWord());         // move temp to dest
        }
    }

    pseudo instruction "pop.b": SINGLE_B  {  //pop byte from stack to dest
	    property bw: int = 0;
        property opcode: int = 0b0100;   //emulated by MOV operation
        execute {
            write(source, popByte());         // move temp to dest
        }
    }

    instruction "push": SINGLE_W {  //push word onto stack
	    property bw: int = 1;
        property opcode: int = 0b00010010;
        execute {
            pushWord(read(source));
        }
    }

    instruction "push.b": SINGLE_B {  //push byte onto stack
	    property bw: int = 0;
        property opcode: int = 0b00010010;
        execute {
            pushByte(read(source));
        }
    }

    instruction "ret" {    //return from subroutine
        property opcode: int = 0b0100;
        execute {
            nextPC = popWord();
        }
    }

    instruction "reti" {    //return from interrupt
        property opcode: int = 0b00010011;
        execute {
            sreg = popWord();
            nextPC = popWord();
        }
    }

    pseudo instruction "rla": SINGLE_W {    // rotate left arithmetically
	    property bw: int = 1;
        property opcode: int = 0b0101;            // emulated by add instruction (add dst, dst)
        execute {
            local dest: short = read(source);
            C = dest[15];        // move MSB into carry
            V = (dest > 0x3FFF and dest < 0xC000);  //overflow if >= 4000h and less than C000h
            dest = dest << 1;    // shifting left 1 position
            N = dest[15];        // setting Neg. bit
            Z = (dest == 0);     // set Z bit if equal to zero
            write(source, dest);
        }
    }

    pseudo instruction "rla.b": SINGLE_B {    // rotate left arithmetically
	    property bw: int = 0;
        property opcode: int = 0b0101;                   // emulated by add instruction (add dst, dst)
        execute {
            local dest: int = read(source);
            C = dest[7];        // move MSB into carry
            V = (dest > 0x3F and dest < 0xC0);  //overflow if >= 40h and less than C0h
            dest = dest << 1;   // shifting left 1 position
            N = dest[7];        // setting Neg. bit
            Z = (dest == 0);    // set Z bit if equal to zero
            write(source, low(dest));
        }
    }

    pseudo instruction "rlc": SINGLE_W {    //rotate left through carry
	    property bw: int = 1;
        property opcode: int = 0b0110;       // emulated by addc instruction (addc dst, dst)
        execute {
            local dest: short = read(source);
            local tempC: int = bit(C);
            C = dest[15];      // move MSB into carry
            V = (dest > 0x3FFF and dest < 0xC000);  //overflow if >= 4000h and less than C000h
            dest = dest << 1 | tempC;    //shifting left 1 position
            N = dest[15];      // setting Neg. bit
            Z = (dest == 0);   // set Z bit if equal to zero
            $regs(rd) = dest;  // move shifted result into destination
            write(source, dest);
        }
     }

    pseudo instruction "rlc.b": SINGLE_B {    //rotate left through carry
	    property bw: int = 0;
        property opcode: int = 0b0110;       // emulated by addc instruction (addc dst, dst)
        execute {
            local dest: int = read(source);
            local tempC: int = bit(C);
            C = dest[7];       // move MSB into carry
            V = (dest > 0x3F and dest < 0xC0);  //overflow if >= 40h and less than C0h
            dest = dest << 1 | tempC;    //shifting left 1 position
            N = dest[7];       // setting Neg. bit
            Z = (dest == 0);   // set Z bit if equal to zero
            write(source, low(dest));
        }
     }

    instruction "rra": SINGLE_W  {     //rotate right arithmetically
	    property bw: int = 1;
        property opcode: int = 0b00010001;
        execute {
            local temp: short = read(source);
            C = temp[0];             // move LSB into Carry
            temp = temp >> 1;        // shift 1 right ( i think)
            N = temp[15];
            Z = (temp == 0);
            V = 0;                   // reset overflow bit
            write(source, temp);
	    }
    }

    instruction "rra.b": SINGLE_B  {     //rotate right arithmetically
	    property bw: int = 0;
        property opcode: int = 0b000100010;
        execute {
            local temp: byte = read(source);
            C = temp2[0];            // move LSB into Carry
            temp = temp >> 1;        // shift 1 right ( i think)
            N = temp[7];
            Z = (temp == 0);
            V = 0;                   // reset overflow bit
            write(source, temp);
        }
    }

    instruction "rrc": SINGLE_W  {    //rotate right through carry
	    property bw: int = 1;
        property opcode: int = 0b00010000;
        execute {
            local temp: short = read(source);
            local oldC: int = bit(C);
            C = temp[0];          // carry loaded from original LSB
            temp = temp >> 1 | oldC << 15;      //shift 1 bit right
            N = temp[15];
            Z = (temp == 0);
            V = (temp[14] == 0 and oldC == 1);  //set if inital dest pos. and inital carry was set
            write(source, temp);
        }
    }

    instruction "rrc.b": SINGLE_B  {    //rotate right through carry
	    property bw: int = 0;
        property opcode: int = 0b000100000;
        execute {
            local temp: byte = read(source);
            local oldC: int = bit(C);
            C = temp2[0];         //Carry loaded from original LSB
            temp = temp >> 1 | oldC << 7;      //shift 1 bit right
            N = temp[7];
            Z = (temp == 0);
            V = (temp[6] == 0 and oldC == 1);  //set if inital dest pos. and inital carry was set
            write(source, temp);
        }
    }

    pseudo instruction "sbc": SINGLE_W {    // subtract source and borrow/.NOT. carry from dest
	    property bw: int = 1;
        property opcode: int = 0b0111;                 // emulated by SUBC instruction
        execute {
            local dest: short = read(source);
            local highbit: int = dest[15];
            // TODO: why not emulate this with the performSubtraction method?
            dest = dest + 0xFFFF + bit(C);  //carry bit is added to dest minus one
            N = dest[15];
            Z = (dest == 0);
            C = ((highbit > dest[15]) and (bit(C) == 0));  //if and overflow occured in MSB, set carry
            V = (dest > 0xFFFF);   //set overflow if arithmetic overflow occurs
            write(source, dest);
	    }
    }

    pseudo instruction "sbc.b": SINGLE_B {    //subtract source and borrow/.NOT. carry from dest
	    property bw: int = 0;
        property opcode: int = 0b0111;      //emulated by SUBC instruction
        execute {
            local dest: byte = read(source);
            local highbit: int = dest[7];
            dest = dest + 0xFF + bit(C);  //carry bit is added to dest minus one
            N = dest[7];
            Z = (dest == 0);
            C = ((highbit > dest[7]) and (bit(C) == 0));  //if and overflow occured in MSB, set carry
            V = (dest > 0xFF);   //set overflow if arithmetic overflow occurs
            write(source, dest);
        }
    }

    pseudo instruction "setc"    {     //set carry bit
        property opcode: int = 0b1101;    //emulated by the BIS operation
        execute {
            C = true;
        }
    }

    pseudo instruction "setn"   {   //set Negative bit
        property opcode: int = 0b1101;   //emulated by the BIS operation
        execute {
            N = true;
        }
    }

    pseudo instruction "setz"  {   // set zero bit
        property opcode: int = 0b1101;   //emulated by the BIS operation
        execute {
            Z = true;
        }
    }

    instruction "sub": DOUBLE_W {   //subtract source from dest
	    property bw: int = 1;
        property opcode: int = 0b1000;
        execute {
            local r1: short = read(source);
            local r2: short = read(dest);
            local results: int = performSubtractionW(r1, r2, 0);
            write(dest, results: short);
    	}
    }

    instruction "sub.b": DOUBLE_B {   //subtract source from dest
	    property bw: int = 0;
        property opcode: int = 0b1000;
        execute {
            local r1: byte = read(source);
            local r2: byte = read(dest);
            local results: int = performSubtraction(r1, r2, 0);
            write(dest, low(results));
    	}
    }

    instruction "subc": DOUBLE_W  {    //sub source and borrow/.NOT. carry from dest
	    property bw: int = 1;
        property opcode: int = 0b0111;
        execute {
            local r1: short = read(source);
            local r2: short = read(dest);
            local results: int = performSubtractionW(r1, r2, bit(C));
            write(dest, results: short);
	    }
    }

    instruction "subc.b": DOUBLE_B {    //sub source and borrow/.NOT. carry from dest
	    property bw: int = 0;
        property opcode: int = 0b0111;
        execute {
            local r1: byte = read(source);
            local r2: byte = read(dest);
            local results: int = performSubtraction(r1, r2, bit(C));
            write(dest, low(results));
 	    }
    }

    pseudo instruction "sbb" : DOUBLE_W  {    //sub source and borrow/.NOT. carry from dest
	    property bw: int = 1;
	    property opcode: int = 0b0111;                         //same operation as SUBC, different syntax
	    execute {
            local r1: short = read(source);
            local r2: short = read(dest);
	        local results: int = performSubtractionW(r1, r2, bit(C));
            write(dest, results: short);
	    }
    }

    pseudo instruction "sbb.b": DOUBLE_B {    //sub source and borrow/.NOT. carry from dest
	    property bw: int = 0;
        property opcode: int = 0b0111;                            //same operation as SUBC, different syntax
        execute {
            local r1: byte = read(source);
            local r2: byte = read(dest);
            local results: int = performSubtraction(r1, r2, bit(C));
            write(dest, low(results));
 	    }
    }

    instruction "swpb": SINGLE_W {   //swap bytes
	    property bw: int = 1;
        property opcode: int = 0b000100001;
        execute {
           local temp1: short = read(source);   //contains original
           local temp2: short = temp1;   //eventually contains swapped bytes
           temp2[15:8] = temp1[7:0];
           temp2[7:0] = temp1[15:8];
           write(source, temp2);
        }
    }

    instruction "sxt": SINGLE_W {  //extend sign
	    property bw: int = 1;
        property opcode: int = 0b000100011;
        execute {
            local r1: short = read(source);
            r1 = (r1 << 8) >> 8;
            N = r1[15];      // set if result is negative
            Z = (r1 == 0);   // set if result is zero
            C = !Z;          // set if result not zero
            V = false;       // reset
            write(source, r1);
        }
    }

    instruction "tst": SINGLE_W {  //test destination
	    property bw: int = 1;
        property opcode: int = 0b1001;
        execute {
            local r1: int = read(source);
            N = r1[15];       // if dest is negative, set
            Z = (r1 == 0);    // if dest contains 0, set
            C = true;         // set carry
            V = false;        // reset overflow
        }
    }

    instruction "tst.b": SINGLE_B {  //test destination
	    property bw: int = 0;
        property opcode: int = 0b1001;
        execute {
            local r1: int = read(source);
            N = r1[7];       //if dest is negative, set
            Z = (r1 == 0);   //if dest contains 0, set
            C = true;   //set carry
            V = false;   //reset overflow
        }
    }

    instruction "xor": DOUBLE_W {  //Exclusive OR of source with dest
	    property bw: int = 1;
        property opcode: int = 0b1110;
        execute {
            local source: int = read(source);
            local dest: int = read(dest);
            dest = dest ^ source;
            N = dest[15];
            Z = (dest == 0);
            C = !Z;
            V = ((source < 0) and (dest < 0));
            write(dest, dest: short);
        }
    }

    instruction "xor.b": DOUBLE_B {  //Exclusive OR of source with dest
	    property bw: int = 0;
	    property opcode: int = 0b1110;
	    execute {
            local source: int = read(source);
            local dest: int = read(dest);
            dest = dest ^ source;
            N = dest[7];
            Z = (dest == 0);
            C = !Z;
            V = ((source < 0) and (dest < 0));
            write(dest, low(dest));
        }
    }

}
