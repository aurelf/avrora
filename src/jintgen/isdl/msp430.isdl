
//
//  instruction set description of the Texas Instruments MSP430 microcontroller
//
architecture msp430 {

//---------------------------------------------------------------------------
//  ENCODING FORMATS OF INSTRUCTIONS
//---------------------------------------------------------------------------

    format SINGOPER = { opcode[8:0], BW[0], AS[1:0],SREG[3:0] }
    format DOUBOPER = { opcode[3:0], SREG[3:0], AD[0], BW[0], AS[1:0],DREG[3:0] }
    format JUMPOPER = { opcode[5:0], PCOFF[9:0] }

//---------------------------------------------------------------------------
//  MEMORY ALLOWED TO INSTRUCTIONS
//---------------------------------------------------------------------------
    memory $regs(GPR): short;
    memory $sram(int): byte; // a "view" of the memory as bytes
    memory $wsram(int): short; // a "view" of the memory as shorts

    global C: boolean;
    global N: boolean;
    global Z: boolean;
    global V: boolean;

    global nextPC: int;
    global cyclesConsumed: int;

//----------------------------------------------------------------------------------
//  OPERANDS ALLOWED FOR INSTRUCTIONS
//----------------------------------------------------------------------------------
    enum GPR {
        pc  = 0,  sreg = 1,  r2  = 2,  r3  = 3,
        r4  = 4,  r5   = 5,  r6  = 6,  r7  = 7,
        r8  = 8,  r9   = 9,  r10 = 10, r11 = 11,
        r12 = 12, r13  = 13, r14 = 14, r15 = 15
    }

    operand-type SREG_B[4]: symbol {
        mapping {
	        r2 = 2, r3 = 3,  r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
	        r9 = 9, r10 = 10, r11 = 11, r12 = 12, r13 = 13, r14 = 14,
	        r15 = 15
	    }
	    read: byte { return low($regs(this)); }
	    write: byte { $regs(this)[7:0] = value; }
	}

    operand-type SREG_W[4]: symbol {
        mapping {
	        r2 = 2, r3 = 3,  r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
	        r9 = 9, r10 = 10, r11 = 11, r12 = 12, r13 = 13, r14 = 14,
	        r15 = 15
	    }
	    read: short { return $regs(this); }
	    write: short { $regs(this) = value; }
	}

    operand-type AIREG_B[4]: symbol {                    //Indirect AutoIncrement mode
        mapping {
	        r2 = 2, r3 = 3,  r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
	        r9 = 9, r10 = 10, r11 = 11, r12 = 12, r13 = 13, r14 = 14,
	        r15 = 15
	    }
	    read: byte {
	        local val: short = $regs(this);               //the value of val provides the address of contents to modify
	        $regs(this) = val + 1;                       //the original register's contents are incremented
	        return val: byte;
	    }
	    write: byte {  }                              //valid only as a source operand
	}

    operand-type AIREG_W[4]: symbol {
        mapping {
	        r2 = 2, r3 = 3,  r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
	        r9 = 9, r10 = 10, r11 = 11, r12 = 12, r13 = 13, r14 = 14,
	        r15 = 15
	    }
	    read: short {
	        local val: short = $regs(this);
	        local val2: short = $regs(val);
	        $regs(this) = val + 2;
	        return val2;
	    }
	    write: short { }
	}

    operand-type INDREG_B[4]: symbol {                    //Indirect register mode
        mapping {
	        r2 = 2, r3 = 3,  r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
	        r9 = 9, r10 = 10, r11 = 11, r12 = 12, r13 = 13, r14 = 14,
	        r15 = 15
	    }
	    read: byte {
	        local val: short = $regs(this);
	        local val2: short = $regs(val);
	        return val2;
	    }
	    write: byte { }
	}

    operand-type INDREG_W[4]: symbol {
        mapping {
	        r2 = 2, r3 = 3,  r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
	        r9 = 9, r10 = 10, r11 = 11, r12 = 12, r13 = 13, r14 = 14,
	        r15 = 15
	    }
	    read: short {
	        local val: short = $regs(this);
	        local val2: short = $regs(val);
	        return val2;
	    }
	    write: short { }
	}

    operand-type IMM8[8]: immediate [0,0xFF];
    operand-type IMM16[16]: immediate [0,0xFFFF];

    operand-type INDX_B {
        sub-operand reg: SREG_B;
        sub-operand index: IMM8;
	    read: byte { return $sram(read(reg) + index); }
	    write: byte { $sram(read(reg) + index) = value; }
    }

    operand-type INDX_W {
        sub-operand reg: SREG_W;
        sub-operand index: IMM16;
	    read: short { return $wsram(read(reg) + index); }
	    write: short { $wsram(read(reg) + index) = value; }
    }

    operand-type SYMB_B[8]: immediate [0,0xFF] {
        read: byte { return $sram(pc + this); }
        write: byte {$sram(pc + this) = value; }
    }

    operand-type SYMB_W[16]: immediate [0,0xFFFF] {
	    read: short { return $wsram(pc + this); }
	    write: short { $wsram(pc + this) = value; }
    }

    operand-type ABSO_B[8]: immediate [0,0xFF] {
	    read: byte { return $sram(this); }
	    write: byte { $sram(this) = value; }
    }

    operand-type ABSO_W[16]: immediate [0,0xFFFF] {
	    read: short { return $wsram(this); }
	    write: short { $wsram(this) = value; }
    }

    operand-type IMMD_B[8]: immediate [0,0xFF] {
        read: byte {
            $regs(pc) = pc + 1;
            return this;
        }
        write: byte { }   //Immediate operand can only be used as source
    }

    operand-type IMMD_W[16]: immediate [0,0xFFFF] {
        read: short {
            $wregs(pc) = pc + 2;
            return this;
        }
        write: short { }
    }

    operand-type JUMP_W[10]: immediate [0,0x3FF] {
        read: short {
            return (this & 0x3FF);
        }
        write: short { }
    }

//-------------------------------------------------------------------------- 
//   ADDRESSING MODES ALLOWED FOR SINGLE OPERAND/DOUBLE OPERAND/JUMP INSTRUCTIONS
//-------------------------------------------------------------------------   
    addr-mode REG_W source: SREG_W {                   //addressing modes like REG_W, REGPUSH_W, REGCALL_W are single operand
	    encoding = { opcode[8:0], 0b000, source  }
	    property syntax: String = "%source";
	    property cycles: int = 1;
    }

    addr-mode REG_B source: SREG_B {
    	encoding = { opcode[8:0], 0b100, source  }
	    property syntax: String = "%source";
	    property cycles: int = 1;
    }

    addr-mode REGREG_B source: SREG_B, dest: SREG_B {         //addressing modes like REGREG_B, REGIND_W, etc are double operand
        encoding = { opcode[3:0], source, 0b0100, dest }
        property syntax: String = "%source, %dest";
        property cycles: int = 1;
    }

    addr-mode REGREG_W source: SREG_W, dest: SREG_W {
        encoding = { opcode[3:0], source, 0b0000, dest }
        property syntax: String = "%source, %dest";
        property cycles: int = 1;
    }

    addr-mode REGIND_B source: SREG_B, dest: INDX_B {
	    encoding = { opcode[3:0], source, 0b1100, dest.reg, dest.index[3:0] }
	    property syntax: String = "%source, %dest.index(%dest.reg)";
	    property cycles: int = 4;
    }

    addr-mode REGIND_W source: SREG_W, dest: INDX_W {
	    encoding = { opcode[3:0], source, 0b1000, dest.reg, dest.index[3:0] }
	    property syntax: String = "%source, %dest.index(%dest.reg)";
	    property cycles: int = 4;
    }

    addr-mode REGSYM_B source: SREG_B, dest: SYMB_B {
	    encoding = { opcode[3:0], source, 0b1100, 0b0000, dest - pc }  // X - r0 is the address at label - program counter
	    property syntax: String = "%source, %dest";
	    property cycles: int = 4;
    }

    addr-mode REGSYM_W source: SREG_W, dest: SYMB_W {
    	encoding = { opcode[3:0], source, 0b1000, 0b0000, dest - pc }  // X - r0 is the address at label - program counter
	    property syntax: String = "%source, %dest";
	    property cycles: int = 4;
    }

    addr-mode REGABS_B source: SREG_B, dest: ABSO_B {
	    encoding = { opcode[3:0], source, 0b1100, 0b0010, dest } //X is the absolute address of the label
	    property syntax: String = "%source, &%dest";
       	property cycles: int = 4;
    }

    addr-mode REGABS_W source: SREG_W, dest: ABSO_W {
	    encoding = { opcode[3:0], source, 0b1100, 0b0010, dest } //X is the absolute address of the label
	    property syntax: String = "%source, &%dest";
       	property cycles: int = 4;
    }

    addr-mode IND_W source: INDX_W {
        encoding = { opcode[8:0], 0b001, source, x }
        property syntax: String = "%source";
        property cycles: int = 4;
    }

    addr-mode IND_B source: INDX_B {
        encoding = { opcode[8:0], 0b101, source, X  }
        property syntax: String = "%source";
        property cycles: int = 4;
    }

    addr-mode INDREG_B source: INDX_B, dest: SREG_B {
        encoding = { opcode[3:0], source, 0b0101, dest, X }
        property syntax: String = "%X(%source), %dest";
        property cycles: int = 3;
    }

    addr-mode INDREG_W source: INDX_W, dest: SREG_W {
        encoding = { opcode[3:0], source, 0b0001, dest, X }
        property syntax: String = "%X(%source), %dest";
        property cycles: int = 3;
    }

    addr-mode INDIND_B source: INDX_B, dest: INDX_B {
        encoding = { opcode[3:0], source, 0b1101, dest, X, Y }
        property syntax: String = "%X(%source), %Y(%dest)";
        property cycles: int = 6;
    }

    addr-mode INDIND_W source: INDX_W, dest: INDX_W {
        encoding = { opcode[3:0], source, 0b1001, dest, X, Y }
        property syntax: String = "%X(%source), %Y(%dest)";
        property cycles: int = 6;
    }

    addr-mode INDSYM_B source: INDX_B, dest: SYMB_B {
        encoding =  { opcode[3:0], source, 0b1101, dest, X,  Y - r0 }
        property syntax: String = "%X(%source), %Y";
        property cycles: int = 6;
    }

    addr-mode INDSYM_W source: INDX_W, dest: SYMB_W {
        encoding = { opcode[3:0], source, 0b1001, dest, X, Y - r0 }
        property syntax: String = "%X(%source), %Y";
        property cycles: int = 6;
    }

    addr-mode INDABS_B source: INDX_B, dest: ABSO_B {
        encoding = { opcode[3:0], source, 0b1101, dest, X, Y -r2 }
        property syntax: String = "%X(%source), &%Y";
        property cycles: int = 6;
    }     

    addr-mode INDABS_W source: INDX_W, dest: ABSO_W {
        encoding = { opcode[3:0], source, 0b1001, dest, X, Y - r2 }
        property syntax: String = "%X(%source), &%Y";
        property cycles: int = 6;
    } 

    addr-mode SYM_W source: SYMB_W {
        encoding = { opcode[8:0], 0b001, source, X - r0  }
        property syntax: String = "%X";
        property cycles: int = 4;
    }

    addr-mode SYM_B source: SYMB_B {
        encoding = { opcode[8:0], 0b101, source, X - r0  }
        property syntax: String = "%X";
        property cycles: int = 4;
    }

    addr-mode SYMREG_B source: SYMB_B, dest: SREG_B {
        encoding = { opcode[3:0], source, 0b0101, dest, X - r0 }
        property syntax: String = "%X, %dest";
        property cycles: int = 3;
    }

    addr-mode SYMREG_W source: SYMB_W, dest: SREG_W {
        encoding = { opcode[3:0], source, 0b0001, dest, X - r0 }
        property syntax: String = "%X, %dest";
        property cycles: int = 3;
    }

    addr-mode SYMIND_B source: SYMB_B, dest: INDX_B {
        encoding = { opcode[3:0], source, 0b1101, dest, X - r0, Y }
        property syntax: String = "%X, %Y(%dest)";
        property cycles: int = 6;
    }

    addr-mode SYMIND_W source: SYMB_W, dest: INDX_W {
        encoding = { opcode[3:0], source, 0b1001, dest, X - r0, Y }
        property syntax: String = "%X, %Y(%dest)";
        property cycles: int = 6;
    }		

    addr-mode SYMSYM_B source : SYMB_B, dest: SYMB_B {
        encoding = { opcode[3:0], source, 0b1101, dest, X - r0, Y - r0 }
        property syntax: String = "%X, %Y";
        property cycles: int = 6;
    }

    addr-mode SYMSYM_W source: SYMB_W, dest: SYMB_W {
        encoding = { opcode[3:0], source, 0b1001, dest, X - r0, Y - r0 }
        property syntax: String = "%X, %Y";
        property cycles: int = 6;
    }

    addr-mode SYMABS_B source: SYMB_B, dest: ABSO_B {
        encoding = { opcode[3:0], source, 0b1101, dest, X - r0, Y - r2 }
        property syntax: String = "%X, &%Y";
        property cycles: int = 6;
    }

    addr-mode SYMABS_W source: SYMB_W, dest: ABSO_W {
        encoding = { opcode[3:0], source, 0b1001, dest, X - r0, Y - r2 }
        property syntax: String = "%X, &%Y";
        property cycles: int = 6;
    }

    addr-mode ABS_W source: ABSO_W {
        encoding = { opcode[8:0], 0b001, source, Y - r2  }
        property syntax: String = "&%X";
        property cycles: int = 4;
    }

    addr-mode ABS_B source: ABSO_B {
        encoding = { opcode[8:0], 0b101, source, Y - r2  }
        property syntax: String = "&%X";
        property cycles: int = 4;
    }

    addr-mode ABSREG_B source: ABSO_B, dest: SREG_B {
        encoding = { opcode[3:0], source, 0b0101, dest, X - r2 }
        property syntax: String = "&%X, %dest";
        property cycles: int = 3;
    }

    addr-mode ABSREG_W source: ABSO_W, dest: SREG_W {
        encoding = { opcode[3:0], source, 0b0001, dest, X - r2 }
        property syntax: String = "&%X, %dest";
        property cycles: int = 3;
    }

    addr-mode ABSIND_B source: ABSO_B, dest: INDX_B {
        encoding = { opcode[3:0], source, 0b1101, dest, X - r2, Y }
        property syntax: String = "&%X, %Y(%dest)";
        property cycles: int = 6;
    }

    addr-mode ABSIND_W source: ABSO_W, dest: INDX_W {
        encoding = { opcode[3:0], source, 0b1001, dest, X - r2, Y }
        property syntax: String = "&%X, %Y(%dest)";
        property cycles: int = 6;
    }

    addr-mode ABSSYM_B source: ABSO_B, dest: SYMB_B {
        encoding = { opcode[3:0], source, 0b1101, dest, X - r2, Y - r0 }
        property syntax: String = "&%X, %Y";
        property cycles: int = 6;
    }

    addr-mode ABSSYM_W source: ABSO_W, dest: SYMB_W {
        encoding = { opcode[3:0], source, 0b1001, dest, X - r2, Y - r0 }
        property syntax: String = "&%X, %Y";
        property cycles: int = 6;
    }

    addr-mode ABSABS_B source: ABSO_B, dest: ABSO_B {
        encoding = { opcode[3:0], source, 0b1101, dest, X - r2, Y - r2 }
        property syntax: String = "&%X, &%Y";
        property cycles: int = 6;
    }

    addr-mode ABSABS_W source: ABSO_W, dest: ABSO_W {
        encoding = { opcode[3:0], source, 0b1001, dest, X - r2, Y - r2 }
        property syntax: String = "&%X, &%Y";
        property cycles: int = 6;
    }

    addr-mode INREG_W source: INDREG_W {
        encoding = { opcode[8:0], 0b010, source  }
        property syntax: String = "@%source";
        property cycles: int = 3;
    }

    addr-mode INREG_B source: INDREG_B {
        encoding = { opcode[8:0], 0b110, source  }
        property syntax: String = "@%source";
        property cycles: int = 3;
    }

    addr-mode INREGREG_B source: INDREG_B, dest: SREG_B {
        encoding = { opcode[3:0], contofaddyatsource, 0b0110, dest }
        property syntax: String = "@%source, %dest";
        property cycles: int = 2;
    }	

    addr-mode INREGREG_W source: INDREG_W, dest: SREG_W {
        encoding = { opcode[3:0], contofaddyatsource, 0b0010, dest }
        property syntax: String = "@%source, %dest";
        property cycles: int = 2;
    }	

    addr-mode INREGIND_B source: INDREG_B, dest: INDX_B {
        encoding = { opcode[3:0], contofaddyatsource, 0b1110, dest, X }
        property syntax: String = "@%source, %X(%dest)";
        property cycles: int = 5;
    }

    addr-mode INREGIND_W source: INDREG_W, dest: INDX_W {
        encoding = { opcode[3:0], contofaddyatsource, 0b1010, dest, X }
        property syntax: String = "@%source, %X(%dest)";
        property cycles: int = 5;
    }

    addr-mode INREGSYM_B source: INDREG_B, dest: SYMB_B {
        encoding = { opcode[3:0], contofaddyatsource, 0b1110, dest, X - r0 }
        property syntax: String = "@%source, %X";
        property cycles: int = 5;
    }

    addr-mode INREGSYM_W source: INDREG_W, dest: SYMB_W {
        encoding = { opcode[3:0], contofaddyatsource, 0b1010, dest, X - r0 }
        property syntax: String = "@%source, %X";
        property cycles: int = 5;
    }

    addr-mode INREGABS_B source: INDREG_B, dest: ABSO_B {
        encoding = { opcode[3:0], contofaddyatsource, 0b1110, dest, X - r2 }
        property syntax: String = "@%source, &%X";
        property cycles: int = 5;
    }

    addr-mode INREGABS_W source: INDREG_W, dest: ABSO_W {
        encoding = { opcode[3:0], contofaddyatsource, 0b1010, dest, X - r2 }
        property syntax: String = "@%source, &%X";
        property cycles: int = 5;
    }

    addr-mode INDRA_W source: AIREG_W {
        encoding = { opcode[8:0], 0b011, source  }
        property syntax: String = "@%source+";
        property cycles: int = 3;
    }

    addr-mode INDRA_B source: AIREG_B {
	    encoding = { opcode[8:0], 0b111, source  }
	    property syntax: String = "@%source+";
	    property cycles: int = 3;
    }

    addr-mode INDRAREG_B source: AIREG_B, dest: SREG_B {
        encoding = { opcode[3:0], contofaddyatsource, 0b0111, dest }
        property syntax: String = "@%source+, %dest";
        property cycles: int = 2;
   }
    addr-mode INDRAREG_W source: AIREG_W, dest: SREG_W {
        encoding = { opcode[3:0], contofaddyatsource, 0b0011, dest }
        property syntax: String = "@%source+, %dest";
        property cycles: int = 2;
   }
    addr-mode INDRAIND_B source: AIREG_B, dest: INDX_B {
        encoding = { opcode[3:0], contofaddyatsource, 0b1111, dest, X }
        property syntax: String = "@%source+, %X(%dest)";
        property cycles: int = 5;
    }  	

    addr-mode INDRAIND_W source: AIREG_W, dest: INDX_W {
	    encoding = { opcode[3:0], contofaddyatsource, 0b1011, dest, X }
	    property syntax: String = "@%source+, %X(%dest)";
	    property cycles: int = 5;
    }

    addr-mode INDRASYM_B source: AIREG_B, dest: SYMB_B {
        encoding = { opcode[3:0], contofaddyatsource, 0b1111, dest, X - r0 }
        property syntax: String = "@%source+, %X";
        property cycles: int = 5;
    }

    addr-mode INDRASYM_W source: AIREG_W, dest: SYMB_W {
        encoding = { opcode[3:0], contofaddyatsource, 0b1011, dest, X - r0 }
        property syntax: String = "@%source+, %X";
        property cycles: int = 5;
    }

    addr-mode INDRAABS_B source: AIREG_B, dest: ABSO_B {
        encoding = { opcode[3:0], contofaddyatsource, 0b1111, dest, X - r2 }
        property syntax: String = "@%source+, %X";
        property cycles: int = 5;
    }
    addr-mode INDRAABS_W source: AIREG_W, dest: ABSO_W {
        encoding = { opcode[3:0], contofaddyatsource, 0b1011, dest, X - r2 }
        property syntax: String = "@%source+, %X";
        property cycles: int = 5;
    }

    //Using of RRA, RRC, SWPB, and SXT instructions with an Immediate operand is not allowed

    addr-mode IMMED_W source: IMMD_W {
        encoding = { opcode[8:0], 0b011, source }
        property syntax: String = "#%contofaddyatsource";
        property cycles: int = 4;
    }


    //Using of RRA, RRC, SWPB, and SXT instructions with an Immediate operand is not allowed

    addr-mode IMMED_B source: IMMD_B {
        encoding = { opcode[8:0], 0b011, source }
        property syntax: String = "#%contofaddyatsource";
        property cycles: int = 4;
    }


    addr-mode IMMEDREG_B source: IMMD_B, dest: SREG_B {
        encoding = { opcode[3:0], contofaddyatsource, 0b0111, dest }
        property syntax: String = "#%contofaddyatsource, %dest";
        property cycles: int = 2;
    }

    addr-mode IMMEDREG_W source: IMMD_W, dest: SREG_W {
        encoding = { opcode[3:0], contofaddyatsource, 0b0011, dest }
        property syntax: String = "#%contofaddyatsource, %dest";
        property cycles: int = 2;
    }

    addr-mode IMMEDIND_B source: IMMD_B, dest: INDX_B {
        encoding = { opcode[3:0], contofaddyatsource, 0b1111, dest, X }
        property syntax: String = "#%contofaddyatsource, %X(%dest)";
        property cycles: int = 5;
    }

    addr-mode IMMEDIND_W source: IMMD_W, dest: INDX_W {
        encoding = { opcode[3:0], contofaddyatsource, 0b1011, dest, X }
        property syntax: String = "#%contofaddyatsource, %X(%dest)";
        property cycles: int = 5;
    }

    addr-mode IMMEDSYM_B source: IMMD_B, dest: SYMB_B {
        encoding = { opcode[3:0], contofaddyatsource, 0b1111, dest, X - r0 }
        property syntax: String = "#%contofaddyatsource, %X";
        property cycles: int = 5;
    }

    addr-mode IMMEDSYM_W source: IMMD_W, dest: SYMB_W {
        encoding = { opcode[3:0], contofaddyatsource, 0b1011, dest, X - r0 }
        property syntax: String = "#%contofaddyatsource, %X";
        property cycles: int = 5;
    }

    addr-mode IMMEDABS_B source: IMMD_B, dest: ABSO_B {
        encoding = { opcode[3:0], contofaddyatsource, 0b1111, dest, X - r2 }
        property syntax: String = "#%contofaddyatsource, &%X";
        property cycles: int = 5;
    }

    addr-mode IMMEDABS_W source: IMMD_W, dest: ABSO_W {
        encoding = { opcode[3:0], contofaddyatsource, 0b1011, dest, X - r2 }
        property syntax: String = "#%contofaddyatsource, &%X";
        property cycles: int = 5;
    }	

    addr-mode JMP_W source: JUMP_W {
        encoding = { opcode[7:2], source }
        property syntax: String = "%offset";
        property cycles: int = 2;
    }

    addr-set DOUBLE_W {
        REGREG_W,
        REGIND_W,
        REGSYM_W,
        REGABS_W,
        INDREG_W,
        INDIND_W,
        INDSYM_W,
        INDABS_W,
        SYMREG_W,
        SYMIND_W,
        SYMSYM_W,
        SYMABS_W,
        ABSREG_W,
        ABSIND_W,
        ABSSYM_W,
        ABSABS_W,
        INREGREG_W,
        INREGIND_W,
        INREGSYM_W,
        INREGABS_W,
        INDRAREG_W,
        INDRAIND_W,
        INDRASYM_W,
        INDRAABS_W,
        IMMEDREG_W,
        IMMEDIND_W,
        IMMEDSYM_W,
        IMMEDABS_W
    }

    addr-set SINGLE_W {
        REG_W,
        IND_W,
        SYM_W,
        ABS_W,
        INREG_W,
        INDRA_W,
        IMMED_W
    }

    addr-set DOUBLE_B {
        REGREG_B,
        REGIND_B,
        REGSYM_B,
        REGABS_B,
        INDREG_B,
        INDIND_B,
        INDSYM_B,
        INDABS_B,
        SYMREG_B,
        SYMIND_B,
        SYMSYM_B,
        SYMABS_B,
        ABSREG_B,
        ABSIND_B,
        ABSSYM_B,
        ABSABS_B,
        INREGREG_B,
        INREGIND_B,
        INREGSYM_B,
        INREGABS_B,
        INDRAREG_B,
        INDRAIND_B,
        INDRASYM_B,
        INDRAABS_B,
        IMMEDREG_B,
        IMMEDIND_B,
        IMMEDSYM_B,
        IMMEDABS_B
    }

    addr-set SINGLE_B {
        REG_B,
        IND_B,
        SYM_B,
        ABS_B,
        INREG_B,
        INDRA_B,
        IMMED_B
    }

//---------------------------------------------------------------------------
//  SUBROUTINES
//---------------------------------------------------------------------------
    inline subroutine performAddition(r1: int, r2: int, carry: int): byte {
        local result: int = r1 + r2 + carry;
        local ral: int = r1[3:0];
        local rbl: int = r2[3:0];

        local Rd7: boolean = r1[7];
        local Rr7: boolean = r2[7];
        local R7: boolean = result[7];

        // set the flags as per instruction set documentation.
        C = result[8];
        N = result[7];
        Z = low(result) == 0;
        V = (Rd7 and Rr7 and !R7) or (!Rd7 and !Rr7 and R7);

        return low(result);
    }

    inline subroutine performAdditionW(r1: int, r2: int, carry: int): word {
        local result: int = r1 + r2 + carry;
        local ral: int = r1[7:0];
        local rbl: int = r2[7:0];

        local Rd15: boolean = r1[15];
        local Rr15: boolean = r2[15];
        local R15: boolean  = result[15];

        C = result[16];
        N = result[15];
        Z = (result == 0);
        V = (Rd15 and Rr15 and !R15) or (!Rd15 and !Rr15 and R15);

        return result;
    }
	

    inline subroutine performSubtraction(r1: int, r2: int, carry: int): byte {
        local result: int = r1 - r2 - carry;

        local Rd7: boolean = r1[7];
        local Rr7: boolean = r2[7];
        local R7:  boolean = result[7];
        local Rd3: boolean = r1[3];
        local Rr3: boolean = r2[3];
        local R3:  boolean = result[3];

        // set the flags as per instruction set documentation.
        C = (!Rd7 and Rr7) or (Rr7 and R7) or (R7 and !Rd7);
        N = R7;
        Z = low(result) == 0;
        V = (Rd7 and !Rr7 and !R7) or (!Rd7 and Rr7 and R7);

        return low(result);
    }
    inline subroutine performSubtractionW(r1: int, r2: int, carry: int): word {
        local result: int = r1 - r2 - carry;

        local Rd15: boolean = r1[15];
        local Rr15: boolean = r2[15];
        local R15:  boolean = result[15];
        local Rd7: boolean = r1[7];
        local Rr7: boolean = r2[7];
        local R7:  boolean = result[7];

        // set the flags as per instruction set documentation.

        C = (!Rd15 and Rr15) or (Rr15 and R15) or (R15 and !Rd15);
        N = R15;
        Z = (low(result) == 0 and high(result) == 0);
        V = (Rd15 and !Rr15 and !R15) or (!Rd15 and Rr15 and R15);
       
        return result;
    }


    inline subroutine performAnd(r1: int, r2: int): byte {
        local result: int = r1 & r2;

        N = result[7];
        Z = low(result) == 0;
        V = false;
        C = !N;

        return low(result);
    }

    inline subroutine performAndW(r1: int, r2: int): word {
        local result: int = r1 & r2;

        N = result[15];
        C = !N;
        Z = (result == 0);
        V = 0;
    }

    subroutine performDeciAddCW(r1: int, r2: int, carry: int): word {
        local reg1: int = r1;
        local reg2: int = r2;
        local result: int = 0;

        reg1[3:0] = reg1[3:0] + carry;
        result[3:0] = reg1[3:0] + reg2[3:0];
        if (result[3:0] > 10) {
            result[3:0] = result[3:0] - 10;
            reg1[7:4] = reg1[7:4] + 1;
        }
        result[7:4] = reg1[7:4] + reg2[7:4];
        if (result[7:4] > 10) {
            result[7:4] = result[7:4] - 10;
            reg1[11:8] = reg1[11:8] + 1;
        }
        result[11:8] = reg1[11:8] + reg2[11:8];
        if (result[11:8] > 10) {
            result[11:8] = result[11:8] - 10;
            reg1[15:12] = reg1[15:12] + 1;
        }
        result[15:12] = reg1[15:12] + reg2[15:12];
        if (result[15:12] > 10) {
            result[15:12] = result[15:12] - 10;
            C = 1;
        }
        N = result[15];
        Z = !(result);
        return result;
    }

    subroutine performDeciAddC(r1: int, r2: int, carry: int): byte {
        local reg1: int = r1;
        local reg2: int = r2;
        local result: int = 0;

        reg1[3:0] = reg1[3:0] + carry;
        result[3:0] = reg1[3:0] + reg2[3:0];
        if (result[3:0] > 10) {
            result[3:0] = result[3:0] - 10;
            reg1[7:4] = reg1[7:4] + 1;
        }
        result[7:4] = reg1[7:4] + reg2[7:4];
        if (result[7:4] > 10) {
            result[7:4] = result[7:4] - 10;
            C = 1;
        }
        N = result[7];
        Z = !(result);
        return result[7:0];
    }

    inline subroutine relativeBranch(target: int): void {
        nextPC = relative(target);
        cyclesConsumed = cyclesConsumed + 1;
    }

    inline subroutine relative(target: int): int {
        return (target * 2) + nextPC;
    }

    inline subroutine absolute(target: int): int {
        return target * 2;
    }

    inline subroutine skip(): void {
        local dist: int = $isize(nextPC);
        nextPC = nextPC + dist;
        if ( dist == 4 ) cyclesConsumed = cyclesConsumed + 2;
        else cyclesConsumed = cyclesConsumed + 1;
    }

    inline subroutine pushPC(npc: int): void {
        npc = npc / 2;
        pushByte(low(npc));
        pushByte(high(npc));
    }

    inline subroutine popPC(): int {
        local high: byte = popByte();
        local low: byte = popByte();
        return uword(low, high) * 2;
    }

    inline subroutine low(v: int): byte {
        return v: byte;
    }

    inline subroutine high(v: int): byte {
        return (v >> 8): byte;
    }

    inline subroutine uword(low: byte, high: byte): int {
        return ((high << 8) | low)[15:0];
    }

    external bit(b: boolean): int;
    external popByte(): byte;
    external pushByte(b: byte): void;


//---------------------------------------------------------------------------
//  BEGIN INSTRUCTION SET DESCRIPTION
//---------------------------------------------------------------------------
	
    instruction "adc": SINGLE_W {
        property opcode: int = 0b0110;                     //opcode for ADDC (6) emulated to ADC
        execute {
            local r1: int       = read(source);
            local result: int   = r1 + bit(C);
                                    //word operation
            local R15: boolean  = result[15];
            local Rdh7: boolean = r1[15];
            C = (!R15 and Rdh7);
            N = (R15);
            V = (!Rdh7 and R15);
            Z = (result[15:0]  == 0);

            write(source, result: short);
        }
    }

    instruction "adc.b": SINGLE_B {
        property opcode: int = 0b0110;                     //opcode for ADDC (6) emulated to ADC
        execute {
            local r1: int       = read(source);
            local result: int   = r1 + bit(C);

            //byte operation
            local R7: boolean   = result[7];
            local Rdh1: boolean = r1[7];
            C = (!R7 and Rdh1);
            N = (R7);
            V = (!Rdh1 and R7);
            Z = (result[7:0]  == 0);

            write(source, result: byte);
        }
    }


    instruction "add": DOUBLE_W {
	    property opcode: int = 0b0101;
        execute {
            local r1: short = read(source);
            local r2: short = read(dest);
            local result: short = performAdditionW(r1, r2, 0);
            write(dest, result);
        }
    }

    instruction "add.b": DOUBLE_B {
        property opcode: int = 0b0101;
        execute {
            local r1: byte = read(source);
            local r2: byte = read(dest);
            local result: byte = performAddition(r1, r2, 0);
            write(dest, result);
        }
    }

    instruction "addc": DOUBLE_W {
        property opcode: int = 0b0110;
        execute {
            local r1: short = read(source);
            local r2: short = read(dest);
            local result: short = performAdditionW(r1, r2, bit(C));
            write(dest, result);
        }
    }

    instruction "addc.b": DOUBLE_B {
        property opcode: int = 0b0110;
    	execute {
            local r1: byte = read(source);
            local r2: byte = read(dest);
            local result: byte = performAddition(r1, r2, bit(C));
            write(dest, result);
   	    }
    }

    instruction "and": DOUBLE_W {
	    property opcode: int = 0b1111;
	    execute {
            local r1: short = read(source);
            local r2: short = read(dest);
            local result: short = performAndW(r1, r2);
            write(dest, result);
        }
    }

    instruction "and.b": DOUBLE_B {
	    property opcode: int = 0b1111;
	    execute {
            local r1: byte = read(source);
            local r2: byte = read(dest);
            local result: byte = performAnd(r1, r2);
            write(dest, result);
        }
    }

    instruction "bic": DOUBLE_W {    //logical and on inverted source and dest
	    property opcode: int = 0b1100;                        //status bits are not affected
	    execute {
            write(dest, ~(read(source)) & read(dest));
        }
    }

    instruction "bic.b": DOUBLE_B {    //logical and on inverted source and dest
	    property opcode: int = 0b1100;                        //status bits are not affected
	    execute {
            write(dest, ~(read(source)) & read(dest));
        }
    }

    instruction "bis": DOUBLE_W {   //logical or on source and dest
        property opcode: int = 0b1101;                       //status bits not affected
        execute {
            write(dest, read(source) | read(dest));
        }
     }

    instruction "bis.b": DOUBLE_B {   //logical or on source and dest
        property opcode: int = 0b1101;                       //status bits not affected
        execute {
            write(dest, read(source) | read(dest));
        }
     }

    instruction "bit": DOUBLE_W {   //test bits in dest by anding source
	    property opcode: int = 0b1011;                         //with dest and affecting only status bits
	    execute {
	        performAndW(read(source), read(dest));
        }
    }

    instruction "bit.b": DOUBLE_B {   //test bits in dest by anding source
	    property opcode: int = 0b1011;                         //with dest and affecting only status bits
	    execute {
	        performAndW(read(source), read(dest));
        }
    }

    instruction "br": SINGLE_W {  //uncondtional branch emulated by moving
	    property opcode: int = 0b0100;                     //operand to Program counter
	    execute {
		    // emulated by MOV instruction
	        nextPC = read(source);
	    }
    }

    instruction "call": SINGLE_W {     //calls a subroutine from 64k address space
        // TODO: double check this opcode
	    property opcode: int = 0b000100101000;          //stores old pc on TOS while jumping to subroutine
	    execute {
            local temp: int = read(source);  //r1 is the SP, r0 is the PC
            pushPC(nextPC);
            nextPC = temp;
        }
    }

    instruction "clr": SINGLE_W {             //emulated by MOV instruction
    	property opcode: int = 0b0100;
        execute {
            // note: the read is necessary for the auto-increment operands
            read(source);
            write(source, 0);
        }
    }

    instruction "clr.b": SINGLE_B {           //emulated by MOV instruction
	    property opcode: int = 0b0100;
	    execute {
            // note: the read is necessary for the auto-increment operands
            read(source);
            write(source, 0);
	    }
    }


    instruction "clrc" {               //clear carry bit by anding with #1
	    property opcode: int = 0b1100;
        execute {
		    //emulated by BIC instruction
            C = false;
	    }
    }

    instruction "clrn" {             //clear neg. bit by anding with #4
	    property opcode: int = 0b1100;
        execute {
       		//emulated by BIC instruction
            N = false;
	    }
    }

    instruction "clrz" {
        property opcode: int = 0b1100;
        execute {
    		//emulated by BIC instruction
            Z = false;
	    }
    }

    instruction "cmp": DOUBLE_W {      // compares 2 operands by
	    property opcode: int = 0b1001;                   // adding source with inverted dest
	    execute {                        // and adding 1 to the result
	        performAdditionW(read(source), ~(read(dest)), 1);
        }
    }

    instruction "cmp.b": DOUBLE_B {    // compares 2 operands by
    	property opcode: int = 0b1001;                   // adding source with inverted dest
	    execute {                        // and adding 1 to the result
	        performAddition(read(source), ~(read(dest)), 1);
        }
    }

    instruction "dadc": SINGLE_W {   // add carry decimally to dest
	    property opcode: int = 0b1010;                 // emulated by DADD instruction
	    execute {
	        write(source, performDeciAddCW(0, read(source), bit(C)));
	    }
    }

    instruction "dadc.b": SINGLE_B {   // add carry decimally to dest
	    property opcode: int = 0b1010;                   // emulated by DADD instruction
	    execute {
	        write(source, performDeciAddC(0, read(source), bit(C)));
	    }
    }

    instruction "dadd": DOUBLE_W {  //source and carry added decimally to dest
	    property opcode: int = 0b1010;
	    execute {
	        write(dest, performDeciAddCW(read(source), read(dest), bit(C)));
	    }
    }

    instruction "dadd.b": DOUBLE_B {  //source and carry added decimally to dest
	    property opcode: int = 0b1010;
	    execute {
	        write(dest, performDeciAddC(read(source), read(dest), bit(C)));
	    }
    }

    instruction "dec": SINGLE_W  {
	    property opcode: int = 0b1000;        // emulated by subtraction operation
	    execute {
	        local original: short = read(source);
	        write(source, performSubtractionW(original, 1, 0));
 	        if (original == 1)
 	            N = 1;    // if original value of dest was 1, set N bit
        }
    }

    instruction "dec.b": SINGLE_B  {
	    property opcode: int = 0b1000;        //emulated by subtraction operation
	    execute {
	        local original: byte = read(source);
	        write(source, performSubtraction(original, 1, 0));
 	        if (original == 1)
 	            N = 1;    // if original value of dest was 1, set N bit
        }
    }

    instruction "decd": SINGLE_W {
	    property opcode: int = 0b1000;         //emulated by subtraction  operation
	    execute {
 	        local original: short = read(source);
            write(source, performSubtractionW(original, 2, 0));
	        if (original == 2)
	            N = 1;    //if original value of dest was 2, set N bit
	    }
    }

    instruction "decd.b": SINGLE_B {
	    property opcode: int = 0b1000;         //emulated by subtraction  operation
	    execute {
 	        local original: byte = read(source);
            write(source, performSubtraction(original, 2, 0));
	        if (original == 2)
	            N = 1;    //if original value of dest was 2, set N bit
	    }
    }

    instruction "dint" {       // disable general interrupts
        property opcode: int = 0b1100;       // emulated by BIC operation
	    execute {
	        disableInterrupts();
	    }
    }

    instruction "eint" {       // enable general interrupts
	    property opcode: int = 0b1101;       // emulated by BIS operation
	    execute {
	        enableInterrupts();
	    }
    }

    instruction "inc": SINGLE_W {     // increment dest
	    property opcode: int = 0b0101;                  // emulated by ADD operation
	    execute {
	        write(source, performAdditionW(read(source), 1, 0));
 	    }
    }

    instruction "inc.b": SINGLE_B {     // increment dest
	    property opcode: int = 0b0101;                    // emulated by ADD operation
	    execute {
	        write(source, performAdditionW(read(source), 1, 0));
 	    }
    }

    instruction "incd": SINGLE_W {      //double increment dest
	    property opcode: int = 0b0101;	    //emulated by ADD operation
	    execute {
	        write(source, performAdditionW(read(source), 2, 0));
	    }
    }

    instruction "incd.b": SINGLE_B {      //double increment dest
	    property opcode: int = 0b0101;	    //emulated by ADD operation
	    execute {
	        write(source, performAdditionW(read(source), 2, 0));
	    }
    }

    instruction "inv": SINGLE_W  {       //invert dest
	    property opcode: int = 0b1110;    //emulated by XOR operation
	    execute {
   	        local result: int = ~(read(source));
	        N = result[15];             //set if neg.
	        Z = (result == 0xFFFF);  //set if contains 0FFFFh
	        C = !(result == 0);      //set if result not 0
	        V = ($regs(rd) < 0);     //set if original contents neg.
	        write(source, result: short);
	    }
    }

    instruction "inv.b": SINGLE_B  {       //invert dest
	    property opcode: int = 0b1110;    //emulated by XOR operation
	    execute {
   	        local result: int = ~(read(source));
	        N = results[7];             //set if neg.
	        Z = (results == 0xFF);  //set if contains 0FFh
	        C = !(results == 0);      //set if result not 0
	        V = (low($regs(rd)) < 0);     //set if original contents neg.
	        write(source, low(result));
	    }
    }

    instruction "jc": JMP_W  {      //jump if carry set
	    property opcode: int = 0b00101100;
	    execute {
 	        if ( C ) {
 	            nextPC = nextPC + 2 * read(source);
	        }
        }
    }

    instruction "jhs": JMP_W  {      //jump if higher or same
	    property opcode: int = 0b00101100;
	    execute {
 	        if ( C ) {
 	            nextPC = nextPC + 2 * read(source);
	        }
        }
    }

    instruction "jeq": JMP_W {      //jump if equal
	    property opcode: int = 0b00100100;
	    execute {
	        if ( Z ) {
 	            nextPC = nextPC + 2 * read(source);
            }
        }
    }

    instruction "jz": JMP_W {      //jump if zero
	    property opcode: int = 0b00100100;
	    execute {
	        if ( Z ) {
 	            nextPC = nextPC + 2 * read(source);
            }
        }
    }

    instruction "jge": JMP_W {   //jump if greater or equal
	    property opcode: int = 0b001101000;
	    execute {
	        if ( Z  xor N ) {
 	            nextPC = nextPC + 2 * read(source);
	        }
	    }
    }

    instruction "jl": JMP_W {   //jump if less
        property opcode: int = 0b00111000;
        execute {
             if ( N xor Z ) {
 	            nextPC = nextPC + 2 * read(source);
             }
    	 }
    }

    instruction "jmp": JMP_W {  //jump unconditionally
	    property opcode: int = 0b00111100;
	    execute {
            //jump to address listed by 10 bit offset, unconditionally
 	        nextPC = nextPC + 2 * read(source);
	    }
    }

    instruction "jn": JMP_W {   //jump if negative
	    property opcode: int = 0b00110000;
	    execute {
	        if ( N ) {
			    //if N = 1, jump to address listed by 10 bit offset
 	            nextPC = nextPC + 2 * read(source);
	        }
        }
    }

    instruction "jnc": JMP_W {  //jump if carry not set
	    property opcode: int = 0b00101000;
	    execute {
	        if ( !C ) {
			    //if C != 0, jump to address listed by 10 bit offset
 	            nextPC = nextPC + 2 * read(source);
	        }
        }
    }

    instruction "jlo": JMP_W {  //jump if carry not set
	    property opcode: int = 0b00101000;
	    execute {
            if ( !C ) {
                //if C != 0, jump to address listed by 10 bit offset
 	            nextPC = nextPC + 2 * read(source);
            }
        }
    }

    instruction "jne": JMP_W {  //jump if not equal
        property opcode: int = 0b00100000;
        execute {
            if ( !Z ) {
                //if Z != 0, jump to address listed by 10 bit offset
 	            nextPC = nextPC + 2 * read(source);
            }
        }
    }

    instruction "jnz": JMP_W {  //jump if not equal
	    property opcode: int = 0b00100000;
	    execute {
	        if ( !Z ) {
			    //if Z != 0, jump to address listed by 10 bit offset
 	            nextPC = nextPC + 2 * read(source);
	        }
	    }
    }

    instruction "mov": DOUBLE_W {  //move source to dest
        property opcode: int = 0b0100;
        execute {
            write(dest, read(source));
        }
    }

    instruction "mov.b": DOUBLE_B {  //move source to dest
        property opcode: int = 0b0100;
        execute {
            write(dest, read(source));
        }
    }

    instruction "nop" {   //no operation
        property opcode: int = 0b0100;     //emulated by MOV operation
        execute {
        }
    }

    instruction "pop": SINGLE_W  {  // pop word from stack to dest
        property opcode: int = 0b0100;   // emulated by MOV operation
        execute {
            write(source, popWord());         // move temp to dest
        }
    }

    instruction "pop.b": SINGLE_B  {  //pop byte from stack to dest
        property opcode: int = 0b0100;   //emulated by MOV operation
        execute {
            write(source, popByte());         // move temp to dest
        }
    }

    instruction "push": SINGLE_W {  //push word onto stack
        property opcode: int = 0b00010010;
        execute {
            pushWord(read(source));
        }
    }

    instruction "push.b": SINGLE_B {  //push byte onto stack
        property opcode: int = 0b00010010;
        execute {
            pushByte(read(source));
        }
    }

    instruction "ret"  {    //return from subroutine
        property opcode: int = 0b0100;
        execute {
            nextPC = popWord();
        }
    }

    instruction "reti" {    //return from interrupt
        property opcode: int = 0b00010011;
        execute {
            sreg = popWord();
            nextPC = popWord();
        }
    }

    instruction "rla": SINGLE_W {    // rotate left arithmetically
        property opcode: int = 0b0101;            // emulated by add instruction (add dst, dst)
        execute {
            local dest: short = read(source);
            C = dest[15];        // move MSB into carry
            V = (dest > 0x3FFF and dest < 0xC000);  //overflow if >= 4000h and less than C000h
            dest = dest << 1;    // shifting left 1 position
            N = dest[15];        // setting Neg. bit
            Z = (dest == 0);     // set Z bit if equal to zero
            write(source, dest);
        }
    }

    instruction "rla.b": SINGLE_B {    // rotate left arithmetically
        property opcode: int = 0b0101;                   // emulated by add instruction (add dst, dst)
        execute {
            local dest: int = read(source);
            C = dest[7];        // move MSB into carry
            V = (dest > 0x3F and dest < 0xC0);  //overflow if >= 40h and less than C0h
            dest = dest << 1;   // shifting left 1 position
            N = dest[7];        // setting Neg. bit
            Z = (dest == 0);    // set Z bit if equal to zero
            write(source, low(dest));
        }
    }

    instruction "rlc": SINGLE_W {    //rotate left through carry
        property opcode: int = 0b0110;       // emulated by addc instruction (addc dst, dst)
        execute {
            local dest: short = read(source);
            local tempC: int = bit(C);
            C = dest[15];      // move MSB into carry
            V = (dest > 0x3FFF and dest < 0xC000);  //overflow if >= 4000h and less than C000h
            dest = dest << 1 | tempC;    //shifting left 1 position
            N = dest[15];      // setting Neg. bit
            Z = (dest == 0);   // set Z bit if equal to zero
            $regs(rd) = dest;  // move shifted result into destination
            write(source, dest);
        }
     }

    instruction "rlc.b": SINGLE_B {    //rotate left through carry
        property opcode: int = 0b0110;       // emulated by addc instruction (addc dst, dst)
        execute {
            local dest: int = read(source);
            local tempC: int = bit(C);
            C = dest[7];       // move MSB into carry
            V = (dest > 0x3F and dest < 0xC0);  //overflow if >= 40h and less than C0h
            dest = dest << 1 | tempC;    //shifting left 1 position
            N = dest[7];       // setting Neg. bit
            Z = (dest == 0);   // set Z bit if equal to zero
            write(source, low(dest));
        }
     }

    instruction "rra": SINGLE_W  {     //rotate right arithmetically
        property opcode: int = 0b00010001;
        execute {
            local temp: short = read(source);
            C = temp[0];             // move LSB into Carry
            temp = temp >> 1;        // shift 1 right ( i think)
            N = temp[15];
            Z = (temp == 0);
            V = 0;                   // reset overflow bit
            write(source, temp);
	    }
    }

    instruction "rra.b": SINGLE_B  {     //rotate right arithmetically
        property opcode: int = 0b000100010100;
        execute {
            local temp: byte = read(source);
            C = temp2[0];            // move LSB into Carry
            temp = temp >> 1;        // shift 1 right ( i think)
            N = temp[7];
            Z = (temp == 0);
            V = 0;                   // reset overflow bit
            write(source, temp);
        }
    }

    instruction "rrc": SINGLE_W  {    //rotate right through carry
        property opcode: int = 0b00010000;
        execute {
            local temp: short = read(source);
            local oldC: int = bit(C);
            C = temp[0];          // carry loaded from original LSB
            temp = temp >> 1 | oldC << 15;      //shift 1 bit right
            N = temp[15];
            Z = (temp == 0);
            V = (temp[14] == 0 and oldC == 1);  //set if inital dest pos. and inital carry was set
            write(source, temp);
        }
    }

    instruction "rrc.b": SINGLE_B  {    //rotate right through carry
        property opcode: int = 0b000100000100;
        execute {
            local temp: byte = read(source);
            local oldC: int = bit(C);
            C = temp2[0];         //Carry loaded from original LSB
            temp = temp >> 1 | oldC << 7;      //shift 1 bit right
            N = temp[7];
            Z = (temp == 0);
            V = (temp[6] == 0 and oldC == 1);  //set if inital dest pos. and inital carry was set
            write(source, temp);
        }
    }

    instruction "sbc": SINGLE_W {    // subtract source and borrow/.NOT. carry from dest
        property opcode: int = 0b0111;                 // emulated by SUBC instruction
        execute {
            local dest: short = read(source);
            local highbit: int = dest[15];
            // TODO: why not emulate this with the performSubtraction method?
            dest = dest + 0xFFFF + bit(C);  //carry bit is added to dest minus one
            N = dest[15];
            Z = (dest == 0);
            C = ((highbit > dest[15]) and (bit(C) == 0));  //if and overflow occured in MSB, set carry
            V = (dest > 0xFFFF);   //set overflow if arithmetic overflow occurs
            write(source, dest);
	    }
    }

    instruction "sbc.b": SINGLE_B {    //subtract source and borrow/.NOT. carry from dest
        property opcode: int = 0b0111;      //emulated by SUBC instruction
        execute {
            local dest: byte = read(source);
            local highbit: int = dest[7];
            dest = dest + 0xFF + bit(C);  //carry bit is added to dest minus one
            N = dest[7];
            Z = (dest == 0);
            C = ((highbit > dest[7]) and (bit(C) == 0));  //if and overflow occured in MSB, set carry
            V = (dest > 0xFF);   //set overflow if arithmetic overflow occurs
            write(source, dest);
        }
    }

    instruction "setc"    {     //set carry bit
        property opcode: int = 0b1101;    //emulated by the BIS operation
        execute {
            C = true;
        }
    }

    instruction "setn"   {   //set Negative bit
        property opcode: int = 0b1101;   //emulated by the BIS operation
        execute {
            N = true;
        }
    }

    instruction "setz"  {   // set zero bit
        property opcode: int = 0b1101;   //emulated by the BIS operation
        execute {
            Z = true;
        }
    }

    instruction "sub": DOUBLE_W {   //subtract source from dest
        property opcode: int = 0b1000;
        execute {
            local r1: short = read(source);
            local r2: short = read(dest);
            local results: int = performSubtractionW(r1, r2, 0);
            write(dest, results: short);
    	}
    }

    instruction "sub.b": DOUBLE_B {   //subtract source from dest
        property opcode: int = 0b1000;
        execute {
            local r1: byte = read(source);
            local r2: byte = read(dest);
            local results: int = performSubtraction(r1, r2, 0);
            write(dest, low(results));
    	}
    }

    instruction "subc": DOUBLE_W  {    //sub source and borrow/.NOT. carry from dest
        property opcode: int = 0b0111;
        execute {
            local r1: short = read(source);
            local r2: short = read(dest);
            local results: int = performSubtractionW(r1, r2, bit(C));
            write(dest, results: short);
	    }
    }

    instruction "subc.b": DOUBLE_B {    //sub source and borrow/.NOT. carry from dest
        property opcode: int = 0b0111;
        execute {
            local r1: byte = read(source);
            local r2: byte = read(dest);
            local results: int = performSubtraction(r1, r2, bit(C));
            write(dest, low(results));
 	    }
    }

    instruction "sbb" : DOUBLE_W  {    //sub source and borrow/.NOT. carry from dest
	    property opcode: int = 0b0111;                         //same operation as SUBC, different syntax
	    execute {
            local r1: short = read(source);
            local r2: short = read(dest);
	        local results: int = performSubtractionW(r1, r2, bit(C));
            write(dest, results: short);
	    }
    }

    instruction "sbb.b": DOUBLE_B {    //sub source and borrow/.NOT. carry from dest
        property opcode: int = 0b0111;                            //same operation as SUBC, different syntax
        execute {
            local r1: byte = read(source);
            local r2: byte = read(dest);
            local results: int = performSubtraction(r1, r2, bit(C));
            write(dest, low(results));
 	    }
    }

    instruction "swpb": SINGLE_W {   //swap bytes
        property opcode: int = 0b000100001000;
        execute {
           local temp1: short = read(source);   //contains original
           local temp2: short = temp1;   //eventually contains swapped bytes
           temp2[15:8] = temp1[7:0];
           temp2[7:0] = temp1[15:8];
           write(source, temp2);
        }
    }

    instruction "sxt": SINGLE_W {  //extend sign
        property opcode: int = 0b000100011000;
        execute {
            local r1: short = read(source);
            r1 = (r1 << 8) >> 8;
            N = r1[15];      // set if result is negative
            Z = (r1 == 0);   // set if result is zero
            C = !Z;          // set if result not zero
            V = false;       // reset
            write(source, r1);
        }
    }

    instruction "tst": SINGLE_W {  //test destination
        property opcode: int = 0b1001;
        execute {
            local r1: int = read(source);
            N = r1[15];       // if dest is negative, set
            Z = (r1 == 0);    // if dest contains 0, set
            C = true;         // set carry
            V = false;        // reset overflow
        }
    }

    instruction "tst.b": SINGLE_B {  //test destination
        property opcode: int = 0b1001;
        execute {
            local r1: int = read(source);
            N = r1[7];       //if dest is negative, set
            Z = (r1 == 0);   //if dest contains 0, set
            C = true;   //set carry
            V = false;   //reset overflow
        }
    }

    instruction "xor": DOUBLE_W {  //Exclusive OR of source with dest
        property opcode: int = 1110;
        execute {
            local source: int = read(source);
            local dest: int = read(dest);
            dest = dest ^ source;
            N = dest[15];
            Z = (dest == 0);
            C = !Z;
            V = ((source < 0) and (dest < 0));
            write(dest, dest: short);
        }
    }

    instruction "xor.b": DOUBLE_B {  //Exclusive OR of source with dest
	    property opcode: int = 1110;
	    execute {
            local source: int = read(source);
            local dest: int = read(dest);
            dest = dest ^ source;
            N = dest[7];
            Z = (dest == 0);
            C = !Z;
            V = ((source < 0) and (dest < 0));
            write(dest, low(dest));
        }
    }

}

