/**
 * Copyright (c) 2004-2005, Regents of the University of California
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * Neither the name of the University of California, Los Angeles nor the
 * names of its contributors may be used to endorse or promote products
 * derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package jintgen.gen.disassembler;

import avrora.util.Util;
import jintgen.isdl.*;
import jintgen.isdl.parser.Token;
import jintgen.jigir.*;
import jintgen.gen.disassembler.DecodingTree;
import jintgen.gen.Generator;
import avrora.util.*;

import java.util.*;
import java.io.PrintStream;

/**
 * The <code>DisassemblerGenerator</code> class is a generator that can create a Java class
 * from an architecture description that disassembles binary instructions into the instruction
 * IR generated by the <code>InstrIRGenerator</code>.
 *
 * @author Ben L. Titzer
 */
public class DisassemblerGenerator extends Generator {

    protected static final int LARGEST_INSTR = 15;
    protected static final int WORD_SIZE = 16;

    Printer printer;
    Verbose.Printer verbose = Verbose.getVerbosePrinter("jintgen.disassem");
    static String instrClassName;
    static String symbolClassName;

    int indent;

    int methods;
    int encodingNumber = 0;
    int instrs = 0;
    int treeNodes = 0;
    int numTrees = 0;
    int pseudoInstrs = 0;

    DecodingTree[] rootSets = new DecodingTree[0];

    HashSet<EncodingInfo> pseudo;

    public DisassemblerGenerator() {
        pseudo = new HashSet<EncodingInfo>();
    }

    public void generate() throws Exception {
        List<String> imports = new LinkedList<String>();
        imports.add("avrora.util.Arithmetic");
        printer = newClassPrinter(className("Disassembler"), imports, null);
        instrClassName = className("Instr");
        symbolClassName = className("Symbol");

        generateHeader();
        generateDecodeTables();
        for ( InstrDecl d : arch.instructions ) visitInstr(d);
        for ( int cntr = 0; cntr < rootSets.length; cntr++ ) {
            DecodingTree es = rootSets[cntr];
            if ( es == null ) continue;
            numTrees++;
            es.compute();
            es.generateCode((cntr+1)*100000, printer);
        }
        generateRoot();
        Terminal.nextln();
        TermUtil.reportQuantity("Instructions", instrs, "");
        TermUtil.reportQuantity("Pseudo-instructions", pseudoInstrs, "");
        TermUtil.reportQuantity("Encodings", encodingNumber, "");
        TermUtil.reportQuantity("Decoding Trees", numTrees, "");
        TermUtil.reportQuantity("Nodes", treeNodes, "");
        printer.endblock();
    }

    private void generateHeader() {
        printer.startblock("static class InvalidInstruction extends Exception");
        printer.startblock("InvalidInstruction(int word1, int pc) ");
        printer.println("super(\"Invalid instruction at \"+pc);");
        printer.endblock();
        printer.endblock();
    }

    private void generateRoot() {
        printer.startblock(instrClassName+" decode_root(int word1) throws InvalidInstruction ");
        printer.println(instrClassName+" i = null;");
        for ( int cntr = 0; cntr < rootSets.length; cntr++ ) {
            DecodingTree es = rootSets[cntr];
            if ( es == null ) continue;
            printer.println("i = decode_root"+cntr+"(word1);");
            printer.println("if ( i != null ) return i;");
        }
        invalidInstr();
        printer.endblock();
    }

    public void visitInstr(InstrDecl d) {
        // for now, we ignore pseudo instructions.
        if ( d.pseudo ) {
            pseudoInstrs++;
        } else {
            instrs++;
            for ( AddrModeDecl am : d.addrMode.addrModes ) {
                for ( EncodingDecl ed : am.encodings )
                    addEncodingInfo(d, am, ed);
            }
        }
    }

    private void addEncodingInfo(InstrDecl d, AddrModeDecl am, EncodingDecl ed) {
        EncodingInfo ei = new EncodingInfo(d, am, encodingNumber, ed);
        DecodingTree dt = getDecodingTree(ed.getPriority());
        dt.encodings.add(ei);
        encodingNumber++;
    }

    private DecodingTree getDecodingTree(int priority) {
        // grow the root set array if necessary
        if ( priority >= rootSets.length ) {
            DecodingTree[] nroots = new DecodingTree[priority+1];
            System.arraycopy(rootSets, 0, nroots, 0, rootSets.length);
            rootSets = nroots;
        }

        DecodingTree dt = getRoot(priority);
        return dt;
    }

    private DecodingTree getRoot(int priority) {
        DecodingTree nset = rootSets[priority];
        if ( nset == null ) {
            nset = new DecodingTree();
            nset.methodname = "decode_root"+priority;
            rootSets[priority] = nset;
        }
        return nset;
    }

    private void invalidInstr() {
        printer.println("throw new InvalidInstruction(word1, pc);");
    }

    private void returnNull() {
        printer.println("return null;");
    }

    private void generateDecodeTables() {
        for ( EnumDecl d : arch.enums ) {
            generateEnumDecodeTable(d);
        }
    }

    void generateEnumDecodeTable(EnumDecl d) {
        int max = getTableSize(d);
        String[] symbol = new String[max+1];
        for ( SymbolMapping.Entry e : d.map.getEntries() ) {
            symbol[e.value] = e.name;
        }
        String tablename = d.name+"_table";
        String symname = symbolClassName+"."+d.name;
        printer.startblock("static final "+symname+"[] "+tablename+" =");
        for ( int cntr = 0; cntr < symbol.length; cntr++ ) {
            if ( symbol[cntr] == null ) printer.print("null");
            else printer.print(symname+"."+symbol[cntr].toUpperCase());
            if ( cntr != symbol.length - 1) printer.print(", ");
            emitDecodeComment(max, cntr, symbol);
            printer.nextln();
        }
        printer.endblock(";");
    }

    private void emitDecodeComment(int max, int cntr, String[] symbol) {
        int lb = Arithmetic.highestBit(max);
        if ( lb <= 0 ) lb = 0;
        String binaryRep = StringUtil.toBin(cntr, lb+1);
        printer.print(" // "+cntr+" (0b"+binaryRep+") -> "+symbol[cntr]);
    }

    private int getTableSize(EnumDecl d) {
        int max = 0;
        for ( SymbolMapping.Entry e : d.map.getEntries() ) {
            if ( e.value > max ) max = e.value;
        }
        if ( max > 64 && max > (d.map.size() * 2) ) {
            throw Util.failure("Enumeration "+StringUtil.quote(d.name)+" too sparse");
        }
        return max;
    }

    public static void generateRead(Printer p, int left_bit, int right_bit) {
        int high_bit = nativeBitOrder(left_bit);
        int low_bit = nativeBitOrder(right_bit);
        int mask = Arithmetic.getBitRangeMask(low_bit, high_bit);

        int word = 1 + (left_bit / WORD_SIZE);

        if ( low_bit > 0 )
            p.print("((word"+word+" >> "+low_bit+") & "+StringUtil.to0xHex(mask, 5)+")");
        else
            p.print("(word"+word+" & "+StringUtil.to0xHex(mask, 5)+")");
    }

    public static int nativeBitOrder(int bit) {
        return 15-(bit % WORD_SIZE);
    }
}
