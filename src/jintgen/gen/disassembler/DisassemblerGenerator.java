/**
 * Copyright (c) 2004-2005, Regents of the University of California
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * Neither the name of the University of California, Los Angeles nor the
 * names of its contributors may be used to endorse or promote products
 * derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package jintgen.gen.disassembler;

import avrora.util.Util;
import jintgen.isdl.*;
import jintgen.isdl.parser.Token;
import jintgen.jigir.*;
import jintgen.gen.disassembler.DTBuilder;
import jintgen.gen.Generator;
import avrora.util.*;

import java.util.*;
import java.io.PrintStream;
import java.io.FileOutputStream;
import java.io.FileNotFoundException;

/**
 * The <code>DisassemblerGenerator</code> class is a generator that can create a Java class
 * from an architecture description that disassembles binary instructions into the instruction
 * IR generated by the <code>InstrIRGenerator</code>.
 *
 * @author Ben L. Titzer
 */
public class DisassemblerGenerator extends Generator {

    protected static final int LARGEST_INSTR = 15;
    protected static final int WORD_SIZE = 16;

    protected final Option.Bool MULTI_TREE = options.newOption("multiple-trees", false, 
            "This option selects whether the disassembler generator will create multiple decode trees " +
            "(i.e. one per priority level) or whether it will create a single, unified tree. In some " +
            "instances one large tree is more efficient, while in others multiple smaller trees may be " +
            "more efficient.");
    protected final Option.Bool PARALLEL_TREE = options.newOption("parallel-trees", false,
            "This option selects whether the disassembler generator will create multiple decode trees " +
            "that are applied in parallel to resolve both the addressing mode and instruction. For " +
            "complex architectures, this can result in tremendously reduced tree sizes. For small architecture, " +
            "the result can be less efficient.");

    Printer printer;
    Verbose.Printer verbose = Verbose.getVerbosePrinter("jintgen.disassem");
    Verbose.Printer verboseDump = Verbose.getVerbosePrinter("jintgen.disassem.tree");
    Verbose.Printer dotDump = Verbose.getVerbosePrinter("jintgen.disassem.dot");
    static String instrClassName;
    static String symbolClassName;
    static String disassemblerClassName;

    int indent;

    int methods;
    int encodingNumber = 0;
    int instrs = 0;
    int treeNodes = 0;
    int numTrees = 0;
    int pseudoInstrs = 0;

    HashSet<EncodingInfo> pseudo;

    DecoderImplementation implementation;

    class DecoderImplementation {
        boolean multiple;
        boolean parallel;

        final HashMap<String, DTNode> finalTrees;

        final DTBuilder[] completeTree;

        DecoderImplementation(int maxprio) {
            parallel = PARALLEL_TREE.get();
            multiple = MULTI_TREE.get();
            completeTree = new DTBuilder[maxprio+1];
            finalTrees = new HashMap<String, DTNode>();
        }

        void compute() {
            for ( int cntr = 0; cntr < completeTree.length; cntr++ ) {
                DTBuilder dt = completeTree[cntr];
                if ( dt == null ) continue;
                DTNode root = dt.compute();
                if ( parallel ) {
                    addFinalTree("instr"+cntr, optimizeInstrs(root));
                    addFinalTree("addr"+cntr, optimizeAddrs(root));
                } else {
                    addFinalTree("root"+cntr, root);
                }
            }
        }

        private DTNode optimizeAddrs(DTNode root) {
            labelTreeWithAddrModes(root);
            DTNode newTree = new TreeFactorer(root).getNewTree();
            return newTree;
        }

        private DTNode optimizeInstrs(DTNode root) {
            labelTreeWithInstrs(root);
            root = DGUtil.removeAll(root, "*");
            DTNode newTree = new TreeFactorer(root).getNewTree();
            return newTree;
        }

        void addFinalTree(String n, DTNode t) {
            finalTrees.put(n, t);
            treeNodes += DGUtil.numberNodes(t);
        }

        void print(Printer p) {
            for ( DTNode dt : finalTrees.values() )
                DGUtil.printTree(p, dt);
        }

        void dotDump() throws Exception {
            for ( Map.Entry<String, DTNode> e : finalTrees.entrySet() ) {
                String name = e.getKey();
                FileOutputStream fos = new FileOutputStream(name+".dot");
                Printer p = new Printer(new PrintStream(fos));
                DGUtil.printDotTree(name, e.getValue(), p);
            }
        }

        void add(EncodingInfo ei) {
            int priority = ei.encoding.getPriority();
            if ( !multiple ) priority = 0;
            DTBuilder dt = completeTree[priority];
            if ( dt == null ) dt = completeTree[priority] = new DTBuilder();
            dt.addEncoding(ei);
        }

        void generate() {
            for ( Map.Entry<String, DTNode> e : finalTrees.entrySet() ) {
                String treeName = e.getKey();
                generateDecodingTree("make_"+treeName, e.getValue());
                printer.println("private static DTNode "+treeName+" = make_"+treeName+"();");
            }
            if ( parallel ) {
                generateParallelRoot();
            } else {
                generateRoot();
            }
        }

        void generateParallelRoot() {
            printer.startblock(instrClassName+" decode_root(int word0) throws InvalidInstruction ");
            printer.println("DTNode addr = addr0;");
            printer.println("DTNode instr = instr0;");
            printer.startblock("while (true)");
            printer.println("int bits = (word0 >> addr.left_bit) & addr.mask;");
            printer.println("addr = addr.move(bits);");
            printer.println("if ( instr != null ) instr = instr.move(bits);");
            printer.println("if ( addr == null ) break;");
            printer.println("if ( addr.action != null ) addr.action();");
            printer.println("if ( instr != null && instr.action != null ) instr.action();");
            printer.endblock();
            printer.println("return null;");
            printer.endblock();
        }

        private void generateRoot() {
            printer.startblock(instrClassName+" decode_root(int word0) throws InvalidInstruction ");
            printer.println("DTNode node = root0;");
            printer.startblock("while (true)");
            printer.println("int bits = (word0 >> node.left_bit) & node.mask;");
            printer.println("node = node.move(bits);");
            printer.println("if ( node == null ) break;");
            printer.println("if ( node.action != null ) node.action();");
            printer.endblock();
            printer.println("return null;");
            printer.endblock();
        }

    }

    public DisassemblerGenerator() {
        pseudo = new HashSet<EncodingInfo>();
    }

    public void generate() throws Exception {
        List<String> imports = new LinkedList<String>();
        imports.add("avrora.util.Arithmetic");
        imports.add("java.util.Arrays");
        instrClassName = className("Instr");
        symbolClassName = className("Symbol");
        disassemblerClassName = className("Disassembler");
        printer = newClassPrinter(disassemblerClassName, imports, null);

        generateHeader();
        generateDecodeTables();
        generateNodeClasses();
        int maxprio = getMaxPriority();
        implementation = new DecoderImplementation(maxprio);
        addInstructions();
        implementation.compute();
        implementation.generate();
        if ( verboseDump.enabled ) {
            implementation.print(verboseDump);
        }
        if ( dotDump.enabled ) {
            implementation.dotDump();
        }
        Terminal.nextln();
        TermUtil.reportQuantity("Instructions", instrs, "");
        TermUtil.reportQuantity("Pseudo-instructions", pseudoInstrs, "");
        TermUtil.reportQuantity("Encodings", encodingNumber, "");
        TermUtil.reportQuantity("Decoding Trees", numTrees, "");
        TermUtil.reportQuantity("Nodes", treeNodes, "");
        printer.endblock();
    }

    private int getMaxPriority() {
        int maxprio = 0;
        for ( InstrDecl d : arch.instructions ) {
            if (!d.pseudo) {
                for ( AddrModeDecl am : d.addrMode.addrModes ) {
                    for ( EncodingDecl ed : am.encodings ) {
                        int prio = ed.getPriority();
                        if ( prio > maxprio ) maxprio = prio;
                    }
                }
            }
        }
        return maxprio;
    }

    private void addInstructions() {
        for ( InstrDecl d : arch.instructions ) visitInstr(d);
    }

    private void generateHeader() {
        printer.startblock("static class InvalidInstruction extends Exception");
        printer.startblock("InvalidInstruction(int pc) ");
        printer.println("super(\"Invalid instruction at \"+pc);");
        printer.endblock();
        printer.endblock();
    }

    public void visitInstr(InstrDecl d) {
        // for now, we ignore pseudo instructions.
        if ( d.pseudo ) {
            pseudoInstrs++;
        } else {
            instrs++;
            for ( AddrModeDecl am : d.addrMode.addrModes ) {
                for ( EncodingDecl ed : am.encodings )
                    addEncodingInfo(d, am, ed);
            }
        }
    }

    private void addEncodingInfo(InstrDecl d, AddrModeDecl am, EncodingDecl ed) {
        EncodingInfo ei = new EncodingInfo(d, am, encodingNumber, ed);
        implementation.add(ei);
        encodingNumber++;
    }

    private void invalidInstr() {
        printer.println("throw new InvalidInstruction(0);");
    }

    private void returnNull() {
        printer.println("return null;");
    }

    private void generateDecodeTables() {
        for ( EnumDecl d : arch.enums ) {
            generateEnumDecodeTable(d);
        }
    }

    void generateEnumDecodeTable(EnumDecl d) {
        int max = getTableSize(d);
        String[] symbol = new String[max+1];
        for ( SymbolMapping.Entry e : d.map.getEntries() ) {
            symbol[e.value] = e.name;
        }
        String tablename = d.name+"_table";
        String symname = symbolClassName+"."+d.name;
        printer.startblock("static final "+symname+"[] "+tablename+" =");
        for ( int cntr = 0; cntr < symbol.length; cntr++ ) {
            if ( symbol[cntr] == null ) printer.print("null");
            else printer.print(symname+"."+symbol[cntr].toUpperCase());
            if ( cntr != symbol.length - 1) printer.print(", ");
            emitDecodeComment(max, cntr, symbol);
            printer.nextln();
        }
        printer.endblock(";");
    }

    private void emitDecodeComment(int max, int cntr, String[] symbol) {
        int lb = Arithmetic.highestBit(max);
        if ( lb <= 0 ) lb = 0;
        String binaryRep = StringUtil.toBin(cntr, lb+1);
        printer.print(" // "+cntr+" (0b"+binaryRep+") -> "+symbol[cntr]);
    }

    private int getTableSize(EnumDecl d) {
        int max = 0;
        for ( SymbolMapping.Entry e : d.map.getEntries() ) {
            if ( e.value > max ) max = e.value;
        }
        if ( max > 64 && max > (d.map.size() * 2) ) {
            throw Util.failure("Enumeration "+StringUtil.quote(d.name)+" too sparse");
        }
        return max;
    }

    public static void generateRead(Printer p, int left_bit, int right_bit) {
        int high_bit = nativeBitOrder(left_bit);
        int low_bit = nativeBitOrder(right_bit);
        int mask = Arithmetic.getBitRangeMask(low_bit, high_bit);

        int word = 1 + (left_bit / WORD_SIZE);

        if ( low_bit > 0 )
            p.print("((word"+word+" >> "+low_bit+") & "+StringUtil.to0xHex(mask, 5)+")");
        else
            p.print("(word"+word+" & "+StringUtil.to0xHex(mask, 5)+")");
    }

    public void generateNodeClasses() {
        printer.startblock("static abstract class DTNode");
        printer.println("final int left_bit;");
        printer.println("final int mask;");
        printer.println("final Action action;");
        printer.println("DTNode(Action a, int lb, int msk) { action = a; left_bit = lb; mask = msk; }");
        printer.println("abstract DTNode move(int val);");
        printer.println("void action() { }");
        printer.endblock();

        printer.startblock("static class DTArrayNode extends DTNode");
        printer.println("final DTNode[] nodes;");
        printer.startblock("DTArrayNode(Action a, int lb, int msk, DTNode[] n)");
        printer.println("super(a, lb, msk);");
        printer.println("nodes = n;");
        printer.endblock();
        printer.startblock("DTNode move(int val)");
        printer.println("return nodes[val];");
        printer.endblock();
        printer.endblock();

        printer.startblock("static class DTSortedNode extends DTNode");
        printer.println("final DTNode def;");
        printer.println("final DTNode[] nodes;");
        printer.println("final int[] values;");
        printer.startblock("DTSortedNode(Action a, int lb, int msk, int[] v, DTNode[] n, DTNode d)");
        printer.println("super(a, lb, msk);");
        printer.println("values = v;");
        printer.println("nodes = n;");
        printer.println("def = d;");
        printer.endblock();
        printer.startblock("DTNode move(int val)");
        printer.println("int ind = Arrays.binarySearch(values, val);");
        printer.println("if ( ind < values.length && values[ind] == val )");
        printer.println("    return nodes[ind];");
        printer.println("else");
        printer.println("    return def;");
        printer.endblock();
        printer.endblock();

        printer.startblock("static class DTTerminal extends DTNode");
        printer.startblock("DTTerminal(Action a)");
        printer.println("super(a, 0, 0);");
        printer.endblock();
        printer.startblock("DTNode move(int val)");
        printer.println("return null;");
        printer.endblock();
        printer.endblock();

        printer.startblock("static abstract class Action");
        printer.println("abstract void action("+disassemblerClassName+" d) throws Exception;");
        printer.endblock();

        printer.startblock("static class ErrorAction extends Action");
        printer.println("void action("+disassemblerClassName+" d) throws Exception { throw new InvalidInstruction(0); }");
        printer.endblock();

        printer.println("public static final DTTerminal ERROR = new DTTerminal(null);");
    }

    public void generateDecodingTree(String methname, DTNode dt) {
        printer.startblock("static DTNode "+methname+"()");
        String last = "ERROR";
        for ( DTNode n : DGUtil.topologicalOrder(dt) )
            last = generateDecodingNode(n);
        printer.println("return "+last+";");
        printer.endblock();
    }

    abstract class DTNodeImpl {
        String def = "ERROR";
        final String nname;
        final int left;
        final int mask;
        final int length;
        LinkedList<String> init;

        DTNodeImpl(DTNode dt) {
            nname = nodeName(dt);
            left = dt.left_bit;
            length = dt.right_bit - dt.left_bit + 1;
            mask = -1 >>> (32 - length);
            init = new LinkedList<String>();
        }
        abstract void add(int value, String nname);
        abstract void generate();

        protected void printInits() {
            boolean first2 = true;
            for ( String str : init ) {
                if ( !first2 ) {
                    printer.print(", ");
                }
                printer.print(str);
                first2 = false;
            }
        }
    }

    class DTArrayNodeImpl extends DTNodeImpl {
        int current;

        DTArrayNodeImpl(DTNode dt) {
            super(dt);
        }
        void add(int value, String nname) {
            if ( value == -1 ) def = nname;
            else {
                while ( current < value ) {
                    current++;
                    init.add(def);
                }
                current++;
                init.add(nname);
            }
        }
        void generate() {
            printer.print("DTNode "+nname+" = new DTArrayNode(null, "+left+", "+mask+", new DTNode[] {");
            padInits();
            printInits();
            printer.println("});");
        }

        void padInits() {
            int total = 1 << (length);
            for ( int cntr = init.size(); cntr < total; cntr++ ) {
                init.add(def);
            }
        }
    }

    class DTSortedNodeImpl extends DTNodeImpl {
        LinkedList<Integer> values = new LinkedList<Integer>();
        DTSortedNodeImpl(DTNode dt) {
            super(dt);
        }
        void add(int value, String nname) {
            if ( value == -1 ) def = nname;
            else {
                init.add(nname);
                values.add(value);
            }
        }
        void generate() {
            printer.print("DTNode "+nname+" = new DTSortedNode(null, "+left+", "+mask+", new int[] {");
            boolean first = true;
            for ( Integer i : values ) {
                if ( !first ) {
                    printer.print(", ");
                }
                printer.print(i.toString());
                first = false;
            }
            printer.print("}, new DTNode[] {");
            printInits();
            printer.println("}, "+def+");");
        }


    }

    private String generateDecodingNode(DTNode n) {
        if ( n.isLeaf() ) {
            String nname = nodeName(n);
            printer.println("DTNode "+nname+" = new DTTerminal(null);");
            return nname;
        }
        DTNodeImpl nodeImpl = newDTNode(n);
        for ( Map.Entry<Integer, DTNode> e : n.getSortedEdges() ) {
            int value = e.getKey();
            DTNode cdt = e.getValue();
            nodeImpl.add(value, nodeName(cdt));
        }
        nodeImpl.generate();
        return nodeImpl.nname;
    }

    private String nodeName(DTNode cdt) {
        if ( cdt.isLeaf() ) return "T"+cdt.number;
        else return "N"+cdt.number;
    }

    private DTNodeImpl newDTNode(DTNode dt) {
        int size = 1 << (dt.right_bit - dt.left_bit);
        if ( size > 16 && (dt.getChildren().size() < (size/2)) ) return new DTSortedNodeImpl(dt);
        return new DTArrayNodeImpl(dt);
    }

    public static int nativeBitOrder(int bit) {
        return 15-(bit % WORD_SIZE);
    }

    public static String getInstrClassName(EncodingInfo ei) {
        return instrClassName+"."+ei.instr.getInnerClassName();
    }

    public static void labelTreeWithInstrs(DTNode dt) {
        HashSet<InstrDecl> instrs = new HashSet<InstrDecl>();
        for ( EncodingInfo ei : dt.encodings )
            instrs.add(ei.instr);

        // label all the children
        if ( instrs.size() == 1 ) {
            dt.setLabel(instrs.iterator().next().innerClassName);
            // label all the children
            for ( DTNode cdt : dt.getChildren() )
            labelTree("*", cdt);
        } else {
            dt.setLabel("-");
            for ( DTNode cdt : dt.getChildren() )
                labelTreeWithInstrs(cdt);
        }
    }

    public static void labelTreeWithAddrModes(DTNode dt) {
        HashSet<AddrModeDecl> addrs = new HashSet<AddrModeDecl>();
        for ( EncodingInfo ei : dt.encodings )
            addrs.add(ei.addrMode);

        if ( addrs.size() == 1 ) {
            // label all the children
            dt.setLabel(addrs.iterator().next().name.image);
            for ( DTNode cdt : dt.getChildren() )
            labelTree("*", cdt);
        } else {
            // label all the children
            dt.setLabel("-");
            for ( DTNode cdt : dt.getChildren() )
                labelTreeWithAddrModes(cdt);
        }
    }

    public static void labelTree(String l, DTNode dt) {
        dt.setLabel(l);
        for ( DTNode cdt : dt.getChildren() )
            labelTree(l, cdt);
    }

    public static Comparator<InstrDecl> INSTR_COMPARATOR = new Comparator<InstrDecl>() {
        public int compare(InstrDecl a, InstrDecl b) {
            return a.name.image.compareTo(b.name.image);
        }
    };

    public static Comparator<AddrModeDecl> ADDR_COMPARATOR = new Comparator<AddrModeDecl>() {
        public int compare(AddrModeDecl a, AddrModeDecl b) {
            return a.name.image.compareTo(b.name.image);
        }
    };
}
