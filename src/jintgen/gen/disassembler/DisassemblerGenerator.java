/**
 * Copyright (c) 2004-2005, Regents of the University of California
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * Neither the name of the University of California, Los Angeles nor the
 * names of its contributors may be used to endorse or promote products
 * derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package jintgen.gen.disassembler;

import avrora.util.Util;
import jintgen.isdl.*;
import jintgen.isdl.parser.Token;
import jintgen.jigir.*;
import jintgen.gen.disassembler.DTBuilder;
import jintgen.gen.Generator;
import avrora.util.*;

import java.util.*;
import java.io.PrintStream;
import java.io.FileOutputStream;
import java.io.FileNotFoundException;

/**
 * The <code>DisassemblerGenerator</code> class is a generator that can create a Java class
 * from an architecture description that disassembles binary instructions into the instruction
 * IR generated by the <code>InstrIRGenerator</code>.
 *
 * @author Ben L. Titzer
 */
public class DisassemblerGenerator extends Generator {

    protected static final int LARGEST_INSTR = 15;
    protected static final int WORD_SIZE = 16;

    protected final Option.Bool MULTI_TREE = options.newOption("multiple-trees", false, 
            "This option selects whether the disassembler generator will create multiple decode trees " +
            "(i.e. one per priority level) or whether it will create a single, unified tree. In some " +
            "instances one large tree is more efficient, while in others multiple smaller trees may be " +
            "more efficient.");
    protected final Option.Bool PARALLEL_TREE = options.newOption("parallel-trees", false,
            "This option selects whether the disassembler generator will create multiple decode trees " +
            "that are applied in parallel to resolve both the addressing mode and instruction. For " +
            "complex architectures, this can result in tremendously reduced tree sizes. For small architecture, " +
            "the result can be less efficient.");

    Printer printer;
    Verbose.Printer verbose = Verbose.getVerbosePrinter("jintgen.disassem");
    Verbose.Printer verboseDump = Verbose.getVerbosePrinter("jintgen.disassem.tree");
    Verbose.Printer dotDump = Verbose.getVerbosePrinter("jintgen.disassem.dot");
    static String instrClassName;
    static String symbolClassName;
    static String operandClassName;
    static String disassemblerClassName;
    static String builderClassName;

    int indent;

    int methods;
    int encodingNumber = 0;
    int instrs = 0;
    int treeNodes = 0;
    int numTrees = 0;
    int pseudoInstrs = 0;

    HashSet<EncodingInfo> pseudo;

    DecoderImplementation implementation;

    class DecoderImplementation {
        boolean multiple;
        boolean parallel;

        final HashMap<String, DTNode> finalTrees;

        final DTBuilder[] completeTree;

        DecoderImplementation(int maxprio) {
            parallel = PARALLEL_TREE.get();
            multiple = MULTI_TREE.get();
            completeTree = new DTBuilder[maxprio+1];
            finalTrees = new HashMap<String, DTNode>();
        }

        void compute() {
            for ( int cntr = 0; cntr < completeTree.length; cntr++ ) {
                DTBuilder dt = completeTree[cntr];
                if ( dt == null ) continue;
                DTNode root = dt.compute();
                if ( parallel ) {
                    addFinalTree("instr"+cntr, optimizeInstrs(root));
                    addFinalTree("addr"+cntr, optimizeAddrs(root));
                } else {
                    addFinalTree("root"+cntr, root);
                }
            }
        }

        private DTNode optimizeAddrs(DTNode root) {
            labelTreeWithAddrModes(root);
            DTNode newTree = new TreeFactorer(root).getNewTree();
            return newTree;
        }

        private DTNode optimizeInstrs(DTNode root) {
            labelTreeWithInstrs(root);
            root = DGUtil.removeAll(root, "*");
            DTNode newTree = new TreeFactorer(root).getNewTree();
            return newTree;
        }

        void addFinalTree(String n, DTNode t) {
            finalTrees.put(n, t);
            treeNodes += DGUtil.numberNodes(t);
        }

        void print(Printer p) {
            for ( DTNode dt : finalTrees.values() )
                DGUtil.printTree(p, dt);
        }

        void dotDump() throws Exception {
            for ( Map.Entry<String, DTNode> e : finalTrees.entrySet() ) {
                String name = e.getKey();
                FileOutputStream fos = new FileOutputStream(name+".dot");
                Printer p = new Printer(new PrintStream(fos));
                DGUtil.printDotTree(name, e.getValue(), p);
            }
        }

        void add(EncodingInfo ei) {
            int priority = ei.encoding.getPriority();
            if ( !multiple ) priority = 0;
            DTBuilder dt = completeTree[priority];
            if ( dt == null ) dt = completeTree[priority] = new DTBuilder();
            dt.addEncoding(ei);
        }

        void generate() {
            generateFields();
            generateTreeBuilderMethods();
            generateTreeFields();
            if ( parallel ) {
                generateParallelRoot();
            } else {
                generateRoot();
            }

        }

        private void generateTreeFields() {
            for ( Map.Entry<String, DTNode> e : finalTrees.entrySet() ) {
                String treeName = e.getKey();
                generateJavaDoc("The <code>"+treeName+"</code> field stores a reference to the root of " +
                        "a decoding tree. It is the starting point for decoding a bit pattern.");
                printer.println("private static final DTNode "+treeName+" = make_"+treeName+"();");
            }
        }

        private void generateTreeBuilderMethods() {
            for ( Map.Entry<String, DTNode> e : finalTrees.entrySet() ) {
                String treeName = e.getKey();
                ActionGetter ag;
                if ( treeName.startsWith("instr") )
                    ag = new InstrActionGetter();
                else ag = new AddrModeActionGetter();
                generateDecodingTree("make_"+treeName, ag, e.getValue());
            }
        }

        void generateFields() {
            generateJavaDoc("The <code>builder</code> field stores a reference to the builder that was " +
                    "discovered as a result of traversing the decoder tree. The builder corresponds to one " +
                    "and only one instruction and has a method that can build a new instance of the instruction " +
                    "from the operands.");
            printer.println("private "+builderClassName+".Single builder;");
            generateJavaDoc("The <code>operands</code> field stores a reference to the operands that were " +
                    "extracted from the bit pattern as a result of traversing the decoding tree. When a node is " +
                    "reached where the addressing mode is known, then the action on that node executes and " +
                    "reads the operands from the bit pattern, storing them in this field.");
            printer.println("private "+operandClassName+"[] operands;");
        }

        void generateParallelRoot() {
            generateJavaDoc("The <code>decode_root()</code> method begins decoding the bit pattern " +
                    "into an instruction. " +
                    "This implementation is <i>parallel</i>, meaning there are two trees: one for " +
                    "the instruction resolution and one of the addressing mode resolution. By beginning " +
                    "at the root node of the addressing mode and " +
                    "instruction resolution trees, the loop compares bits in the bit patterns and moves down " +
                    "the two trees in parallel. When both trees reach an endpoint, the comparison stops and " +
                    "an instruction will be built. This method accepts the value of the first word of the " +
                    "bits and begins decoding from there.\n" +
                    "@param word0 the first 16 bits of the bit pattern");
            printer.startblock(instrClassName+" decode_root(int word0) throws InvalidInstruction ");
            printer.println("DTNode addr = addr0;");
            printer.println("DTNode instr = instr0;");
            printer.startblock("while (true)");
            printer.println("int bits = (word0 >> addr.left_bit) & addr.mask;");
            printer.println("addr = addr.move(bits);");
            printer.println("if ( instr != null ) instr = instr.move(bits);");
            printer.println("if ( addr == null ) break;");
            printer.println("if ( addr.action != null ) addr.action();");
            printer.println("if ( instr != null && instr.action != null ) instr.action();");
            printer.endblock();
            printer.println("if ( builder != null && operands != null ) return builder.build(operands);");
            printer.println("return null;");
            printer.endblock();
        }

        private void generateRoot() {
            generateJavaDoc("The <code>decode_root()</code> method begins decoding the bit pattern " +
                    "into an instruction. This implementation resolves both instruction and addressing " +
                    "mode with one tree. It begins at the root node and continues comparing bits and " +
                    "following the appropriate paths until a terminal node is reached. This method " +
                    "accepts the value of the first word of the bits and begins " +
                    "decoding from there.\n" +
                    "@param word0 the first 16 bits of the bit pattern");
            printer.startblock(instrClassName+" decode_root(int word0) throws InvalidInstruction ");
            printer.println("DTNode node = root0;");
            printer.startblock("while (true)");
            printer.println("int bits = (word0 >> node.left_bit) & node.mask;");
            printer.println("node = node.move(bits);");
            printer.println("if ( node == null ) break;");
            printer.println("if ( node.action != null ) node.action();");
            printer.endblock();
            printer.println("if ( builder != null && operands != null ) return builder.build(operands);");
            printer.println("return null;");
            printer.endblock();
        }

        private void generateDecodingTree(String methname, ActionGetter ag, DTNode dt) {
            generateJavaDoc("The <code>"+methname+"()</code> method creates a new instance of a " +
                    "decoding tree by allocating the DTNode instances and connecting the references " +
                    "together correctly. It is called only once in the static initialization of the " +
                    "disassembler to build a single shared instance of the decoder tree implementation " +
                    "and the reference to the root node is stored in a single private static field of " +
                    "the same name.");
            printer.startblock("static DTNode "+methname+"()");
            String last = "ERROR";
            for ( DTNode n : DGUtil.topologicalOrder(dt) )
                last = generateDecodingNode(n, ag);
            printer.println("return "+last+";");
            printer.endblock();
        }

        private String generateDecodingNode(DTNode n, ActionGetter ag) {
            String action = ag.getAction(n);
            if ( n.isLeaf() ) {
                String nname = nodeName(n);
                printer.println("DTNode "+nname+" = new DTTerminal("+action+");");
                return nname;
            }
            DTNodeImpl nodeImpl = newDTNode(n, action);
            for ( Map.Entry<Integer, DTNode> e : n.getSortedEdges() ) {
                int value = e.getKey();
                DTNode cdt = e.getValue();
                nodeImpl.add(value, nodeName(cdt));
            }
            nodeImpl.generate();
            return nodeImpl.nname;
        }

        abstract class ActionGetter {
            abstract String getAction(DTNode n);
        }

        class InstrActionGetter extends ActionGetter {
            String getAction(DTNode n) {
                String label = n.getLabel();
                if ( "*".equals(label) ) return "null";
                if ( "-".equals(label) ) return "null";
                else return "new SetBuilder("+builderClassName+"."+label+")";
            }
        }

        class AddrModeActionGetter extends ActionGetter {
            String getAction(DTNode n) {
                return "null";
            }
        }
    }

    public DisassemblerGenerator() {
        pseudo = new HashSet<EncodingInfo>();
    }

    public void generate() throws Exception {
        List<String> imports = new LinkedList<String>();
        imports.add("avrora.util.Arithmetic");
        imports.add("java.util.Arrays");
        instrClassName = className("Instr");
        symbolClassName = className("Symbol");
        disassemblerClassName = className("Disassembler");
        builderClassName = className("InstrBuilder");
        operandClassName = className("Operand");
        printer = newClassPrinter(disassemblerClassName, imports, null,
                "The <code>"+disassemblerClassName+"</code> class decodes bit patterns into instructions.");

        generateHeader();
        generateDecodeTables();
        generateNodeClasses();
        int maxprio = getMaxPriority();
        implementation = new DecoderImplementation(maxprio);
        addInstructions();
        implementation.compute();
        implementation.generate();
        if ( verboseDump.enabled ) {
            implementation.print(verboseDump);
        }
        if ( dotDump.enabled ) {
            implementation.dotDump();
        }
        Terminal.nextln();
        TermUtil.reportQuantity("Instructions", instrs, "");
        TermUtil.reportQuantity("Pseudo-instructions", pseudoInstrs, "");
        TermUtil.reportQuantity("Encodings", encodingNumber, "");
        TermUtil.reportQuantity("Decoding Trees", numTrees, "");
        TermUtil.reportQuantity("Nodes", treeNodes, "");
        printer.endblock();
    }

    private int getMaxPriority() {
        int maxprio = 0;
        for ( InstrDecl d : arch.instructions ) {
            if (!d.pseudo) {
                for ( AddrModeDecl am : d.addrMode.addrModes ) {
                    for ( EncodingDecl ed : am.encodings ) {
                        int prio = ed.getPriority();
                        if ( prio > maxprio ) maxprio = prio;
                    }
                }
            }
        }
        return maxprio;
    }

    private void addInstructions() {
        for ( InstrDecl d : arch.instructions ) visitInstr(d);
    }

    private void generateHeader() {
        printer.startblock("static class InvalidInstruction extends Exception");
        printer.startblock("InvalidInstruction(int pc) ");
        printer.println("super(\"Invalid instruction at \"+pc);");
        printer.endblock();
        printer.endblock();
    }

    public void visitInstr(InstrDecl d) {
        // for now, we ignore pseudo instructions.
        if ( d.pseudo ) {
            pseudoInstrs++;
        } else {
            instrs++;
            for ( AddrModeDecl am : d.addrMode.addrModes ) {
                for ( EncodingDecl ed : am.encodings )
                    addEncodingInfo(d, am, ed);
            }
        }
    }

    private void addEncodingInfo(InstrDecl d, AddrModeDecl am, EncodingDecl ed) {
        EncodingInfo ei = new EncodingInfo(d, am, encodingNumber, ed);
        implementation.add(ei);
        encodingNumber++;
    }

    private void generateDecodeTables() {
        for ( EnumDecl d : arch.enums ) {
            generateEnumDecodeTable(d);
        }
    }

    void generateEnumDecodeTable(EnumDecl d) {
        int max = getTableSize(d);
        String[] symbol = new String[max+1];
        for ( SymbolMapping.Entry e : d.map.getEntries() ) {
            symbol[e.value] = e.name;
        }
        String tablename = d.name+"_table";
        String symname = symbolClassName+"."+d.name;
        printer.startblock("static final "+symname+"[] "+tablename+" =");
        for ( int cntr = 0; cntr < symbol.length; cntr++ ) {
            if ( symbol[cntr] == null ) printer.print("null");
            else printer.print(symname+"."+symbol[cntr].toUpperCase());
            if ( cntr != symbol.length - 1) printer.print(", ");
            emitDecodeComment(max, cntr, symbol);
            printer.nextln();
        }
        printer.endblock(";");
    }

    private void emitDecodeComment(int max, int cntr, String[] symbol) {
        int lb = Arithmetic.highestBit(max);
        if ( lb <= 0 ) lb = 0;
        String binaryRep = StringUtil.toBin(cntr, lb+1);
        printer.print(" // "+cntr+" (0b"+binaryRep+") -> "+symbol[cntr]);
    }

    private int getTableSize(EnumDecl d) {
        int max = 0;
        for ( SymbolMapping.Entry e : d.map.getEntries() ) {
            if ( e.value > max ) max = e.value;
        }
        if ( max > 64 && max > (d.map.size() * 2) ) {
            throw Util.failure("Enumeration "+StringUtil.quote(d.name)+" too sparse");
        }
        return max;
    }

    public static void generateRead(Printer p, int left_bit, int right_bit) {
        int high_bit = nativeBitOrder(left_bit);
        int low_bit = nativeBitOrder(right_bit);
        int mask = Arithmetic.getBitRangeMask(low_bit, high_bit);

        int word = 1 + (left_bit / WORD_SIZE);

        if ( low_bit > 0 )
            p.print("((word"+word+" >> "+low_bit+") & "+StringUtil.to0xHex(mask, 5)+")");
        else
            p.print("(word"+word+" & "+StringUtil.to0xHex(mask, 5)+")");
    }

    public void generateNodeClasses() {
        generateJavaDoc("The <code>DTNode</code> class represents a node in a decoding graph. Each node " +
                "compares a range of bits and branches to other nodes based on the value. Each node may " +
                "also have an action (such as fixing the addressing mode or instruction) that is " +
                "executed when the node is reached. Actions on the root node are not executed.");
        printer.startblock("static abstract class DTNode");
        printer.println("final int left_bit;");
        printer.println("final int mask;");
        printer.println("final Action action;");
        printer.println("DTNode(Action a, int lb, int msk) { action = a; left_bit = lb; mask = msk; }");
        printer.println("abstract DTNode move(int val);");
        printer.println("void action() { }");
        printer.endblock();

        generateJavaDoc("The <code>DTArrayNode</code> implementation is used for small (less than 32) " +
                "and dense (more than 50% full) edge lists. It uses an array of indices that is " +
                "directly indexed by the bits extracted from the stream.");
        printer.startblock("static class DTArrayNode extends DTNode");
        printer.println("final DTNode[] nodes;");
        printer.startblock("DTArrayNode(Action a, int lb, int msk, DTNode[] n)");
        printer.println("super(a, lb, msk);");
        printer.println("nodes = n;");
        printer.endblock();
        printer.startblock("DTNode move(int val)");
        printer.println("return nodes[val];");
        printer.endblock();
        printer.endblock();

        generateJavaDoc("The DTSortedNode implementation is used for sparse edge lists. It uses a " +
                "sorted array of indices and uses binary search on the value of the bits.");
        printer.startblock("static class DTSortedNode extends DTNode");
        printer.println("final DTNode def;");
        printer.println("final DTNode[] nodes;");
        printer.println("final int[] values;");
        printer.startblock("DTSortedNode(Action a, int lb, int msk, int[] v, DTNode[] n, DTNode d)");
        printer.println("super(a, lb, msk);");
        printer.println("values = v;");
        printer.println("nodes = n;");
        printer.println("def = d;");
        printer.endblock();
        printer.startblock("DTNode move(int val)");
        printer.println("int ind = Arrays.binarySearch(values, val);");
        printer.println("if ( ind < values.length && values[ind] == val )");
        printer.println("    return nodes[ind];");
        printer.println("else");
        printer.println("    return def;");
        printer.endblock();
        printer.endblock();

        generateJavaDoc("The <code>DTTerminal</code> class represents a terminal node in the decoding " +
                "tree. Terminal nodes are reached when decoding is finished, and represent either " +
                "successful decoding (meaning instruction and addressing mode were discovered) or " +
                "unsucessful decoding (meaning the bit pattern does not encode a valid instruction.");
        printer.startblock("static class DTTerminal extends DTNode");
        printer.startblock("DTTerminal(Action a)");
        printer.println("super(a, 0, 0);");
        printer.endblock();
        printer.startblock("DTNode move(int val)");
        printer.println("return null;");
        printer.endblock();
        printer.endblock();

        generateJavaDoc("The ERROR node is reached for incorrectly encoded instructions and signals " +
                "that the bit pattern was an incorrectly encoded instruction.");
        printer.println("public static final DTTerminal ERROR = new DTTerminal(new ErrorAction());");

        generateActionClasses();

        generateJavaDoc("The <code>OperandReader</code> class is an object that is capable of reading the " +
                "operands from the bit pattern of an instruction, once the addressing mode is known. One " +
                "of these classes is generated for each addressing mode. When the addressing mode is " +
                "finally known, an action will fire that sets the operand reader which is used to read " +
                "the operands from the bit pattern.");
        printer.startblock("static abstract class OperandReader");
        printer.println("abstract "+operandClassName+"[] read("+disassemblerClassName+" d);");
        printer.endblock();
    }

    private void generateActionClasses() {
        generateJavaDoc("The <code>Action</code> class represents an action that can happen when the " +
                "decoder reaches a particular node in the tree. The action may be to fix the instruction " +
                "or addressing mode, or to signal an error.");
        printer.startblock("static abstract class Action");
        printer.println("abstract void action("+disassemblerClassName+" d) throws Exception;");
        printer.endblock();

        generateJavaDoc("The <code>ErrorAction</code> class is an action that is fired when the decoding tree " +
                "reaches a state which indicates the bit pattern is not a valid instruction.");
        printer.startblock("static class ErrorAction extends Action");
        printer.println("void action("+disassemblerClassName+" d) throws Exception { throw new InvalidInstruction(0); }");
        printer.endblock();

        generateJavaDoc("The <code>SetBuilder</code> class is an action that is fired when the decoding tree " +
                "reaches a node where the instruction is known. This action fires and sets the <code>builder</code> " +
                "field to point the appropriate builder for the instruction..");
        printer.startblock("static class SetBuilder extends Action");
        printer.println(builderClassName+".Single builder;");
        printer.println("SetBuilder("+builderClassName+".Single b) { builder = b; }");
        printer.println("void action("+disassemblerClassName+" d) throws Exception { d.builder = builder; }");
        printer.endblock();
    }

    private void generateJavaDoc(String p) {
        generateJavaDoc(printer, p);
    }

    abstract class DTNodeImpl {
        String def = "ERROR";
        String action;
        final String nname;
        final int left;
        final int mask;
        final int length;

        DTNodeImpl(DTNode dt, String act) {
            nname = nodeName(dt);
            left = dt.left_bit;
            length = dt.right_bit - dt.left_bit + 1;
            mask = -1 >>> (32 - length);
            action = act;
        }
        abstract void add(int value, String nname);
        abstract void generate();
    }

    class DTArrayNodeImpl extends DTNodeImpl {
        int current;
        String[] vals;

        DTArrayNodeImpl(DTNode dt, String action) {
            super(dt, action);
            vals = new String[1 << length];
        }
        void add(int value, String nname) {
            if ( value == -1 ) def = nname;
            else {
                vals[value] = nname;
            }
        }
        void generate() {
            printer.print("DTNode "+nname+" = new DTArrayNode("+action+", "+left+", "+mask+", new DTNode[] {");
            boolean first = true;
            for ( String str : vals ) {
                if ( !first ) {
                    printer.print(", ");
                }
                first = false;
                if ( str == null ) printer.print(def);
                else printer.print(str);
            }
            printer.println("});");
        }

    }

    class DTSortedNodeImpl extends DTNodeImpl {
        LinkedList<String> init = new LinkedList<String>();
        LinkedList<Integer> values = new LinkedList<Integer>();
        DTSortedNodeImpl(DTNode dt, String act) {
            super(dt, act);
        }
        void add(int value, String nname) {
            if ( value == -1 ) def = nname;
            else {
                init.add(nname);
                values.add(value);
            }
        }
        void generate() {
            printer.print("DTNode "+nname+" = new DTSortedNode("+action+", "+left+", "+mask+", new int[] {");
            boolean first = true;
            for ( Integer i : values ) {
                if ( !first ) {
                    printer.print(", ");
                }
                printer.print(i.toString());
                first = false;
            }
            printer.print("}, new DTNode[] {");
            printInits();
            printer.println("}, "+def+");");

        }

        void printInits() {
            boolean first2 = true;
            for ( String str : init ) {
                if ( !first2 ) {
                    printer.print(", ");
                }
                printer.print(str);
                first2 = false;
            }
        }
    }

    private String nodeName(DTNode cdt) {
        if ( cdt.isLeaf() ) return "T"+cdt.number;
        else return "N"+cdt.number;
    }

    private DTNodeImpl newDTNode(DTNode dt, String action) {
        int size = 1 << (dt.right_bit - dt.left_bit);
        if ( size > 16 && (dt.getChildren().size() < (size/2)) ) return new DTSortedNodeImpl(dt, action);
        return new DTArrayNodeImpl(dt, action);
    }

    public static int nativeBitOrder(int bit) {
        return 15-(bit % WORD_SIZE);
    }

    public static String getInstrClassName(EncodingInfo ei) {
        return instrClassName+"."+ei.instr.getInnerClassName();
    }

    public static void labelTreeWithInstrs(DTNode dt) {
        HashSet<InstrDecl> instrs = new HashSet<InstrDecl>();
        for ( EncodingInfo ei : dt.encodings )
            instrs.add(ei.instr);

        // label all the children
        if ( instrs.size() == 1 ) {
            dt.setLabel(instrs.iterator().next().innerClassName);
            // label all the children
            for ( DTNode cdt : dt.getChildren() )
            labelTree("*", cdt);
        } else {
            dt.setLabel("-");
            for ( DTNode cdt : dt.getChildren() )
                labelTreeWithInstrs(cdt);
        }
    }

    public static void labelTreeWithAddrModes(DTNode dt) {
        HashSet<AddrModeDecl> addrs = new HashSet<AddrModeDecl>();
        for ( EncodingInfo ei : dt.encodings )
            addrs.add(ei.addrMode);

        if ( addrs.size() == 1 ) {
            // label all the children
            dt.setLabel(addrs.iterator().next().name.image);
            for ( DTNode cdt : dt.getChildren() )
            labelTree("*", cdt);
        } else {
            // label all the children
            dt.setLabel("-");
            for ( DTNode cdt : dt.getChildren() )
                labelTreeWithAddrModes(cdt);
        }
    }

    public static void labelTree(String l, DTNode dt) {
        dt.setLabel(l);
        for ( DTNode cdt : dt.getChildren() )
            labelTree(l, cdt);
    }

    public static Comparator<InstrDecl> INSTR_COMPARATOR = new Comparator<InstrDecl>() {
        public int compare(InstrDecl a, InstrDecl b) {
            return a.name.image.compareTo(b.name.image);
        }
    };

    public static Comparator<AddrModeDecl> ADDR_COMPARATOR = new Comparator<AddrModeDecl>() {
        public int compare(AddrModeDecl a, AddrModeDecl b) {
            return a.name.image.compareTo(b.name.image);
        }
    };
}
