package avrora.actions;

import avrora.actions.FindGadgetsAction.Feature;
import avrora.arch.*;
import avrora.arch.legacy.*;

import cck.text.StringUtil;
import cck.text.Terminal;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Set;
import java.util.Map;
import java.util.TreeMap;
import java.util.Iterator;

/**
 * The <code>GadgetsSet</code> used to manage gadgest of code ... // TODO
 * 
 * @author A. Francillon
 */

public class Gadget implements Comparable<Gadget> {
    TreeMap<Integer, AbstractInstr> contents;

    Comparator<Gadget> cmp = new CodeSizeComparator();

    // Comparator<Gadget> cmp=new StackSizeComparator();

    /**
     * autogenerated fix a warning
     */

    private static final long serialVersionUID = 1L;

    /**
     * this address is the address of the gadget i.e. the address of it's ret
     * instruction
     */
    int addr;

    /**
     * default constructor
     * 
     */
    public Gadget() {
        System.out.println("create a gadget without base address:!!! ");
        contents = new TreeMap<Integer, AbstractInstr>();
    }

    public Gadget(Integer addr) {
        contents = new TreeMap<Integer, AbstractInstr>();
        this.addr = addr;
    }

    public Gadget(Gadget orig, Integer length) {
        this.addr = orig.addr;
        // System.out.println("copy gadget from " +(addr-length-2)+" to "+addr);
        contents = new TreeMap<Integer, AbstractInstr>(orig.contents.subMap(
                addr - length - 2, addr));
    }

    /**
     * Add an instruction to the gadget
     * 
     * @param addr
     *            address of the instruction to add as integer
     * @param Instr
     *            instruction to add
     */
    public void addInstr(Integer addr, AbstractInstr Instr) {
        contents.put(addr, Instr);
    }

    public Integer size() {
        return contents.size();
    }

    public Integer sizeOnStack() {
        Integer sizeOnStack = 0;
        Set s = contents.entrySet();
        Iterator i = s.iterator();

        while (i.hasNext()) {
            Map.Entry entry = (Map.Entry) i.next();
            AbstractInstr instr = (AbstractInstr) entry.getValue();
            if (instr instanceof LegacyInstr.POP)
                sizeOnStack++;
            else if (instr instanceof LegacyInstr.RET
                    || instr instanceof LegacyInstr.RETI)
                sizeOnStack++;
            else if (instr instanceof LegacyInstr.PUSH)
                sizeOnStack--;
            else if (instr instanceof LegacyInstr.CALL
                    || instr instanceof LegacyInstr.ICALL
                    || instr instanceof LegacyInstr.RCALL) {
                sizeOnStack--;
                sizeOnStack--;
            }
        }
        return sizeOnStack;
    }

    /**
     * hasPop retuns true when gadget contains a pop instruction
     * 
     * @return
     */
    public boolean hasPop() {
        Set s = contents.entrySet();
        Iterator i = s.iterator();

        while (i.hasNext()) {
            Map.Entry entry = (Map.Entry) i.next();
            AbstractInstr instr = (AbstractInstr) entry.getValue();
            if (instr instanceof LegacyInstr.POP)
                return true;
        }
        return false;
    }

    public Iterator<Map.Entry<Integer, AbstractInstr>> reverseIterator() {
        TreeMap<Integer, AbstractInstr> reverseCont = new TreeMap<Integer, AbstractInstr>(
                Collections.reverseOrder());
        reverseCont.putAll(contents);
        Set<Map.Entry<Integer, AbstractInstr>> s = reverseCont.entrySet();
        return s.iterator();

    }

    public Integer hasInstr(Class instr) {
        TreeMap<Integer, AbstractInstr> reverseCont = new TreeMap<Integer, AbstractInstr>(
                Collections.reverseOrder());
        reverseCont.putAll(contents);
        Set s = reverseCont.entrySet();
        return hasInstr(s, instr);

    }

    public Integer hasInstr(Class instr, Integer reg){
        TreeMap<Integer,AbstractInstr> reverseCont= 
            new TreeMap<Integer,AbstractInstr>(Collections.reverseOrder());
        reverseCont.putAll(contents);
        Set s = reverseCont.entrySet();
//        Terminal.println("looking up for instr "+instr+" reg "+reg);
//       
//        if(LegacyInstr.POP.class.getGenericSuperclass()==LegacyInstr.REG_class.class){
//            Terminal.println("PPPPPPPPPPRRRRRRRRRRRRRRRRROOOOOOOOOOOOOOOOOUUUUUUUUUUUUUUTTTTTTTt");
//             
//        }else
//            Terminal.println("XXXXXXXXXXXXXXXXXxxx"+LegacyInstr.POP.class+" "+LegacyInstr.REG_class.class);
//            
        if(instr.getSuperclass()==LegacyInstr.REG_class.class){
                // instr instanceof if(instr.isInstance(LegacyInstr.REG_class.class)){
            //Terminal.println("is a LegacyInstr.REG_class");
            return hasInstr_reg(s,instr,reg);
        }
        else if(instr.getSuperclass()==LegacyInstr.REGREG_class.class){
            //Terminal.println("is a LegacyInstr.REGREG_class");
           return hasInstr_regreg(s,instr,reg,null);
        }
        else {
            //Terminal.println("is a LegacyInstr.XXXXX_class");
            return hasInstr(s, instr);
        }
            
    }

    public Integer hasInstr(Class instr, Integer reg1, Integer reg2) {
        TreeMap<Integer, AbstractInstr> reverseCont = new TreeMap<Integer, AbstractInstr>(
                Collections.reverseOrder());
        reverseCont.putAll(contents);
        Set s = reverseCont.entrySet();
        return hasInstr_regreg(s, instr, reg1, reg2);

    }

    /**
     * hasInstr retuns true when set <code>s</code> contains an instruction
     * <code>instr</code>
     * 
     * @return position from ret of closet match to the ret instr
     */
    private Integer hasInstr(Set s, Class instr) {
        Iterator i = s.iterator();
        Integer pos = 0;
        while (i.hasNext()) {
            Map.Entry entry = (Map.Entry) i.next();
            AbstractInstr localInstr = (AbstractInstr) entry.getValue();
            if (instr != null && instr.isInstance(localInstr)){
                // we found instruction return it's position in set
                return pos;
            }
            pos += localInstr.getSize();
        }
        // none found
        return null;
    }

    private Integer hasInstr_reg(Set s, Class instr, Integer reg1) {
        Iterator i = s.iterator();
        Integer pos = 0;
        // can't do much if instr is null
        assert instr != null;
        assert instr.isInstance(LegacyInstr.REG_class.class);
        while (i.hasNext()) {
            Map.Entry entry = (Map.Entry) i.next();
            AbstractInstr localInstr = (AbstractInstr) entry.getValue();
            if (instr.isInstance(localInstr)) {
//                if (localInstr instanceof LegacyInstr.REG_class)
               if (reg1 == null)
                   return pos;
                if (((LegacyInstr.REG_class) localInstr).r1.getNumber() == reg1)
                    return pos;
            }
            // if instruction is not a valid instruction
            if(localInstr==null)
                pos+=2;
            else
                pos += localInstr.getSize();
        }
        // none found
        return null;
    }

    private Integer hasInstr_regreg(Set s, Class instr, Integer reg1,
            Integer reg2) {
        Iterator i = s.iterator();
        Integer pos = 0;
        // can't do much if instr is null
        assert instr == null;
        assert instr.isInstance(LegacyInstr.REGREG_class.class);

        while (i.hasNext()) {
            Map.Entry entry = (Map.Entry) i.next();
            AbstractInstr localInstr = (AbstractInstr) entry.getValue();
            
            // TODO  Rmove one of thoe two tests ? dupe ?
            if (instr.isInstance(localInstr)) {
//                if (localInstr instanceof LegacyInstr.REGREG_class) {
                    // if we don't care about the regs values ... 
                    if (reg1 == null && reg2 == null)
                        return pos;
//                  result for r1 only
                    if (reg2 == null)
                        if (((LegacyInstr.REGREG_class) localInstr).r1
                                .getNumber() == reg1)
                            return pos;
                    // result for r2 only
                    if (reg1 == null)
                        if (((LegacyInstr.REGREG_class) localInstr).r2
                                .getNumber() == reg2)
                            return pos; 

                    // both r1 and r2 != null
                    if (((LegacyInstr.REGREG_class) localInstr).r1.getNumber() == reg1
                            && ((LegacyInstr.REGREG_class) localInstr).r2
                                    .getNumber() == reg2)
                        return pos;
//                }
            }
            // if insrution is not valid 
            if(localInstr==null)
                pos+=2;
            else
                pos += localInstr.getSize();

        }
        // none found
        return null;
    }

    /**
     * search for a pop instruction in the gadget
     * 
     * @param regnumber
     *            register to pop, if null match all pop's
     * @return Integer the address of the pop instruction found
     */

    public Integer hasPop(Integer regnumber) {
        Set s = contents.entrySet();
        Iterator i = s.iterator();

        while (i.hasNext()) {

            AbstractInstr instr;
            Map.Entry entry;

            entry = (Map.Entry) i.next();
            instr = (AbstractInstr) entry.getValue();

            if (instr instanceof LegacyInstr.POP) {
                LegacyRegister reg = ((LegacyInstr.POP) instr).r1;
                if (regnumber == null)
                    return (Integer) entry.getKey();
                if (reg.getNumber() == regnumber.intValue())
                    return (Integer) entry.getKey();
            }
        }
        return null;
    }

    public void print() {
        Set s = contents.entrySet();
        Iterator i = s.iterator();

        Terminal.println("=============");
        while (i.hasNext()) {

            AbstractInstr instr;
            Map.Entry entry;

            entry = (Map.Entry) i.next();
            instr = (AbstractInstr) entry.getValue();
            Integer addr = (Integer) entry.getKey();
            print((AbstractInstr) instr, addr.intValue());
        }
        Terminal.println("=============");
    }

    private static int print(AbstractInstr instr, int addr) {
        String result;
        int len = 2;
        if (instr == null)
            result = "null";
        else {
            result = instr.toString();
            len = instr.getSize();
        }
        // TODO FIXME it's shit
        byte buf[] = new byte[40000];

        print(buf, addr, len, result);
        return len;
    }

    private static void print(byte[] buf, int off, int len, String str) {
        StringBuffer sbuf = new StringBuffer();
        sbuf.append(StringUtil.addrToString(off));
        sbuf.append(": ");
        for (int cntr = 0; cntr < len; cntr++) {
            StringUtil.toHex(sbuf, buf[off + cntr], 2);
            sbuf.append(' ');
        }
        for (int cntr = sbuf.length(); cntr < 30; cntr++)
            sbuf.append(' ');
        sbuf.append(str);
        Terminal.println(sbuf.toString());
    }

    /**
     * get the entry point for this gadget it's the addr minus the size of it's
     * instructions
     * 
     * @return entry point address
     */
    public Integer entryPointAddr() {
        Integer entrypoint = addr; // start at first instruction
        Set instructions = entrySet();
        Iterator<AbstractInstr> i = instructions.iterator();
        while (i.hasNext()) {
            Map.Entry entry = (Map.Entry) i.next();
            AbstractInstr localInstr = (AbstractInstr) entry.getValue();
            entrypoint = entrypoint - localInstr.getSize();
        }
        return entrypoint;
    }

    /**
     * Strip a gadget: keep only instructions needed between the one 
     * matching features and ret ... 
     * @param features
     * @return the stripped gadget
     */
    public Gadget gadgetStrip(ArrayList<Feature> features) {
        Iterator<Feature> i = features.iterator();
        Integer minpos =0;// size();
        while (i.hasNext()) {
            Feature f = i.next();
            Integer pos;
            pos = hasInstr(f.instruction, f.register1);
            if (pos > minpos)
                // we have to make the gadget longer because this feature is
                // at position "pos" which is bigger than last expected minimum
                // position
                minpos = pos;
        }
        Gadget striped=new Gadget(this, minpos);
        return striped;
    }

    public Set entrySet() {
        return contents.entrySet();
    }

    public boolean equals(Gadget g) {

        return g == this && contents.size() == g.size();
    }

    public int compareTo(Gadget g) {
        // Terminal.println("compareTo");
        if (this.equals(g))
            return 0;
        if (contents.size() < g.size())
            return -1;
        return 1;
    }

    // public boolean equals(Object o) {
    // return cmp.equals(o);
    // }
    //    
    // public int compareTo(Gadget g) {
    // return cmp.compare(this, g);
    // }
    //    
    // public void newComparator(Comparator<Gadget> newcmp){
    // cmp=newcmp;
    // }
    public Integer firstKey() {
        return contents.firstKey();
    }

    public AbstractInstr get(Object key) {
        return contents.get(key);
    }

}

class CodeSizeComparator implements Comparator<Gadget> {

    public int compare(Gadget g1, Gadget g2) {
        if (g1.size() == g2.size())
            return 0;
        if (g1.size() < g2.size())
            return -1;
        return 1;
    }
}

class StackSizeComparator implements Comparator<Gadget> {

    public int compare(Gadget g1, Gadget g2) {
        if (g1.sizeOnStack() == g2.sizeOnStack())
            return 0;
        if (g1.sizeOnStack() < g2.sizeOnStack())
            return -1;
        return 1;
    }
}
