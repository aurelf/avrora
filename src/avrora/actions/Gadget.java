
package avrora.actions;

import avrora.arch.*;
import avrora.arch.legacy.*;


import cck.text.StringUtil;
import cck.text.Terminal;

import java.util.Collections;
import java.util.Set;
import java.util.Map;
import java.util.TreeMap;
import java.util.Iterator;

import com.ibm.xslt4j.bcel.classfile.Code;

/**
 * The <code>GadgetsSet</code>  used to manage gadgest of code ...
 * // TODO 
 * @author A. Francillon
 */



public class Gadget implements Comparable{
    TreeMap contents;
    /**
     * autogenerated fix a warning 
     */

    private static final long serialVersionUID = 1L;
    
    /**
     * usefull ? 
     */
    int addr;
    
    /**
     * default constructor 
     *
     */
    public Gadget(){
        contents=new TreeMap();
    }
    public Gadget(Integer addr){
        contents=new TreeMap();
        this.addr=addr;
    }

    public Gadget(Gadget orig, Integer length){
        this.addr=orig.addr;
        //System.out.println("copy gadget from " +(addr-length-2)+" to "+addr);
        contents=new TreeMap(orig.contents.subMap(addr-length-2, addr));
    }
    /**
     * Add an instruction to the gadget 
     * @param addr address of the instruction to add as integer
     * @param Instr instruction to add 
     */
    public void addInstr(Integer addr,Object Instr ) {
        contents.put(addr,Instr);
    }
    
    public Integer size() {
        return contents.size();
    }
    
    public boolean equals(Object  o) {
        //Terminal.println("someone is looking at Gadget.equals");

        if (o instanceof Gadget)
                return false;
        Gadget g=(Gadget)o;
        return contents.size()==g.size();        

    }
    
    public int compareTo(Object o) {
        //Terminal.println("compareTo");
        if (!(o instanceof Gadget)) 
            throw new ClassCastException();
        Gadget g=(Gadget) o;
        if(this.equals(o))
            return 0;
        if(contents.size()<g.size())
            return -1;
        return 1;
    }
        
    
    /**
     * hasPop retuns true when gadget contains a pop instruction
     * @return
     */
    public boolean  hasPop(){
        Set s = contents.entrySet();
        Iterator i=s.iterator();

        while(i.hasNext()){
            Map.Entry entry= (Map.Entry)i.next() ;
            AbstractInstr instr=(AbstractInstr)entry.getValue();
            if( instr instanceof LegacyInstr.POP )
                return true;
        }
        return false;
    }

    /**
     * hasPop retuns true when gadget contains a instruction <code>instr</code>
     * 
     * @return position from ret 
     */
    public Integer hasInstr(Class instr, Integer reg){
        TreeMap reverseCont= new TreeMap(Collections.reverseOrder());
        reverseCont.putAll(contents);
        Set s = reverseCont.entrySet();
        Iterator i=s.iterator();
        Integer pos=0;
        while(i.hasNext()){        
            Map.Entry entry= (Map.Entry)i.next() ;
            AbstractInstr localInstr=(AbstractInstr)entry.getValue();
            if( instr.isInstance(localInstr) )
                if(reg==null)
                    return pos;
                else
                    if(localInstr instanceof LegacyInstr.REG_class)
                        if(((LegacyInstr.REG_class)localInstr).r1.getNumber()==reg)
                            return pos;
                    else 
                        if(localInstr instanceof LegacyInstr.REGREG_class)
                           if(((LegacyInstr.REGREG_class)localInstr).r1.getNumber()==reg)
                                   return pos;
            pos+=localInstr.getSize();
        }
        return null;
    }

  
    
    /**
     * search for a pop instruction in the gadget 
     * @param regnumber register to pop, if null match all pop's 
     * @return Integer the address of the pop instruction found 
     */

    public Integer  hasPop(Integer regnumber ){
        Set s= contents.entrySet();
        Iterator i=s.iterator(); 

        while(i.hasNext()){

            AbstractInstr instr;                
            Map.Entry entry;

            entry=(Map.Entry)i.next();
            instr=(AbstractInstr)entry.getValue();

            if( instr instanceof LegacyInstr.POP ){
                LegacyRegister reg=((LegacyInstr.POP)instr).r1;
                if (regnumber==null)
                    return (Integer)entry.getKey();
                if (reg.getNumber()==regnumber.intValue())
                    return (Integer)entry.getKey();
            }
        }
        return null;
    }


    public void print(){
        Set s= contents.entrySet();
        Iterator i=s.iterator(); 

        Terminal.println("=============");            
        while(i.hasNext()){

            AbstractInstr instr;                
            Map.Entry entry;

            entry=(Map.Entry)i.next();
            instr=(AbstractInstr)entry.getValue();
            Integer addr=(Integer)entry.getKey();
            print((AbstractInstr)instr,addr.intValue());
        }
        Terminal.println("=============");            
    }

    private static int print(AbstractInstr instr, int addr) {
        String result;
        int len = 2;
        if ( instr == null ) result = "null";
        else {
            result = instr.toString();
            len = instr.getSize();
        }
        // TODO FIXME 
        byte buf[] = new byte[40000];


        print(buf, addr, len, result);
        return len;
    }


    private static void print(byte[] buf, int off, int len, String str) {
        StringBuffer sbuf = new StringBuffer();
        sbuf.append(StringUtil.addrToString(off));
        sbuf.append(": ");
        for ( int cntr = 0; cntr < len; cntr++ ) {
            StringUtil.toHex(sbuf, buf[off+cntr], 2);
            sbuf.append(' ');
        }
        for ( int cntr = sbuf.length(); cntr < 30; cntr++ ) sbuf.append(' ');
        sbuf.append(str);
        Terminal.println(sbuf.toString());
    }
}  
