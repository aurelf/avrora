
//
//  instruction set description of the Texas Instruments MSP430 microcontroller
//
architecture msp430 {

//---------------------------------------------------------------------------
//  ENCODING FORMATS OF INSTRUCTIONS
//---------------------------------------------------------------------------

    format SINGOPER = { opcode[8:0], BW[0], AS[1:0],SREG[3:0] }
    format DOUBOPER = { opcode[3:0], SREG[3:0], AD[0], BW[0], AS[1:0],DREG[3:0] }
    format JUMPOPER = { opcode[5:0], PCOFF[9:0] }

//---------------------------------------------------------------------------
//  MEMORY ALLOWED TO INSTRUCTIONS
//---------------------------------------------------------------------------
    memory $regs(symbol): short;
    memory $sram(int): byte; // a "view" of the memory as bytes
    memory $wsram(int): short; // a "view" of the memory as shorts

    global C: boolean;
    global N: boolean;
    global Z: boolean;
    global V: boolean;

    global nextPC: int;
    global cyclesConsumed: int;

//----------------------------------------------------------------------------------
//  OPERANDS ALLOWED FOR INSTRUCTIONS
//----------------------------------------------------------------------------------
    operand-type SREG_B[4]: symbol {
        mapping = {
	        r2 = 2, r3 = 3,  r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
	        r9 = 9, r10 = 10, r11 = 11, r12 = 12, r13 = 13, r14 = 14,
	        r15 = 15
	    }
	    read: byte = { return low($regs(this)); }
	    write: byte = { $regs(this)[7:0] = value; }
	}

    operand-type SREG_W[4]: symbol {
        mapping = {
	        r2 = 2, r3 = 3,  r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
	        r9 = 9, r10 = 10, r11 = 11, r12 = 12, r13 = 13, r14 = 14,
	        r15 = 15
	    }
	    read: short = { return $regs(this); }
	    write: short = { $regs(this) = value; }
	}

    operand-type AIREG_B[4]: symbol {
        mapping = {
	        r2 = 2, r3 = 3,  r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
	        r9 = 9, r10 = 10, r11 = 11, r12 = 12, r13 = 13, r14 = 14,
	        r15 = 15
	    }
	    read: byte = {
	        local val:short = $regs(this);
	        $regs(this) = val + 1;
	        return val:byte;
	    }
	    write: byte = { $regs(this)[7:0] = value; }
	}

    operand-type AIREG_W[4]: symbol {
        mapping = {
	        r2 = 2, r3 = 3,  r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
	        r9 = 9, r10 = 10, r11 = 11, r12 = 12, r13 = 13, r14 = 14,
	        r15 = 15
	    }
	    read: short = {
	        local val: short = $regs(this);
	        $regs(this) = val + 2;
	        return val;
	    }
	    write: short = { $regs(this) = value; }
	}


    operand-type IND_B {
        sub-operand reg: SREG_B;
        sub-operand index[8]: immediate = [0,0xFF];
	    read: byte = { return $sram(read(reg) + index); }
	    write: byte = { $sram(read(reg) + index) = value; }
    }

    operand-type IND_W {
        sub-operand reg: SREG_W;
        sub-operand index[8]: immediate = [0,0xFF];
	    read: short = { return $wsram(reg.read() + index); }
	    write: short = { $wsram(reg.read() + index) = value; }
    }

    operand-type REL_B[8]: immediate [0,0xFF] {
	    read: byte = { return $sram(pc + this)); }
	    write: byte = { $sram(pc + this) = value; }
    }

    operand-type REL_W[8]: immediate [0,0xFF] {
	    read: short = { return $wsram(pc + this); }
	    write: short = { $wsram(pc + this) = value; }
    }

    operand-type ABS_B[8]: immediate [0,0xFF] {
	    read: byte = { return $sram(this)); }
	    write: byte = { $sram(this) = value; }
    }

    operand-type ABS_W[8]: immediate [0,0xFF] {
	    read: short = { return $wsram(this); }
	    write: short = { $wsram(this) = value; }
    }

//-------------------------------------------------------------------------- 
//   ADDRESSING MODES ALLOWED FOR SINGLE OPERAND/DOUBLE OPERAND/JUMP INSTRUCTIONS
//-------------------------------------------------------------------------   
    addr-mode REG_W {                   //addressing modes like REG_W, REGPUSH_W, REGCALL_W are single operand
	    operand source: SREG_W;
	    encoding = { opcode[8:0], 0b000, r1 = source  }
	    syntax = "%source";
	    cycles = 1;
    }

    addr-mode REGPUSH_W {
	    operand source: SREG_W;
	    encoding = { opcode[8:0], 0b000, r1 = source  }
	    syntax = "%source";
	    cycles = 3;
    }

    addr-mode REGCALL_W {
	    operand source: SREG_W;
	    encoding = { opcode[8:0], 0b100, r1 = source  }
	    syntax = "%source";
	    cycles = 4;
    }

    addr-mode REG_B {
	    operand source: SREG_B;
    	encoding = { opcode[8:0], 0b100, r1 = source  }
	    syntax = "%source";
	    cycles = 1;
    }

    addr-mode REGPUSH_B {
	    operand source: SREG_B;
	    encoding = { opcode[8:0], 0b100, r1 = source  }
	    syntax = "%source";
	    cycles = 3;
    }

    addr-mode REGCALL_B {
	    operand source: SREG_B;
	    encoding = { opcode[8:0], 0b100, r1 = source  }
	    syntax = "%source";
	    cycles = 4;
    }

    addr-mode REGREG_B {         //addressing modes like REGREG_B, REGIND_W, etc are double operand
        operand source: SREG_B;
        operand dest: SREG_B;
        encoding = { opcode[3:0], r1 = source, 0b0100, r2 = dest }
        syntax = "%source, %dest";
        cycles = 1;
    }

    addr-mode REGREG_W {
        operand source: SREG_W;
        operand dest: SREG_W;
        encoding = { opcode[3:0],r1 = source, 0b0000, r2 = dest }
        syntax = "%source, %dest";
        cycles = 1;
    }

    addr-mode REGIND_B {
        operand source: SREG_B;
        operand dest: IND_B;
	    encoding = { opcode[3:0], r1 = source, 0b1100, r2 = dest.reg, dest.index[3:0] }
	    syntax = "%source, %dest.index(%dest.reg)";
	    cycles = 4;
    }

    addr-mode REGIND_W {
        operand source: SREG_W;
        operand dest: IND_W;
	    encoding = { opcode[3:0], r1 = source, 0b1000, r2 = dest.reg, dest.index[3:0] }
	    syntax = "%source, %dest.index(%dest.reg)";
	    cycles = 4;
    }

    addr-mode REGSYM_B {
        operand source: SREG_B;
	    operand dest: REL_B,
	    encoding = { opcode[3:0], r1 = source, 0b1100, r2 = 0b0000, dest - pc }  // X - r0 is the address at label - program counter
	    syntax = "%source, %dest";
	    cycles = 4;
    }

    addr-mode REGSYM_W {
        operand source: SREG_W;
        operand dest: IND_W;
    	encoding = { opcode[3:0], r1=source, 0b1000, r2 = 0b0000, dest - pc }  // X - r0 is the address at label - program counter
	    syntax = "%source, %dest";
	    cycles = 4;
    }

    addr-mode REGABS_B {
        operand source: SREG_B;
	    operand dest: ABS_B;
	    encoding = { opcode[3:0], r1 = source, 0b1100, r2 = 0b0010, dest } //X is the absolute address of the label
	    syntax = "%source, &%dest";
       	cycles = 4;
    }

    addr-mode REGABS_W {
        operand source: SREG_W;
	    operand dest: ABS_W;
	    encoding = { opcode[3:0], r1 = source, 0b1100, r2 = 0b0010, dest } //X is the absolute address of the label
	    syntax = "%source, &%dest";
       	cycles = 4;
    }

    addr-mode IND_W {
        operand source[20]: symbol = { r2 = 2, r3 = 3, r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
        r9 = 9, r10 = 10, r11 = 11, r12 = 12,r13 = 13, r14 = 14, r15 = 15},
        immediate X = [0,0xFFFF], read, write;
        encoding = { opcode[8:0], 0b001, r1 = source, X  }
        syntax = "%source";
        cycles = 4;
    }

    addr-mode INDPUSH_W {
        operand source[20]: symbol = { r2 = 2, r3 = 3, r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
        r9 = 9, r10 = 10, r11 = 11, r12 = 12,r13 = 13, r14 = 14, r15 = 15},
        immediate X = [0,0xFFFF], read, write;
        encoding = { opcode[8:0], 0b001, r1 = source, X  }
        syntax = "%source";
        cycles = 5;
    }

    addr-mode INDCALL_W {
        operand source[20]: symbol = { r2 = 2, r3 = 3, r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
        r9 = 9, r10 = 10, r11 = 11, r12 = 12,r13 = 13, r14 = 14, r15 = 15},
        immediate X = [0,0xFFFF], read, write;
        encoding = { opcode[8:0], 0b001, r1 = source, X  }
        syntax = "%source";
        cycles = 5;
    }

    addr-mode IND_B {
        operand source[12]: symbol = { r2 = 2, r3 = 3, r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
        r9 = 9, r10 = 10, r11 = 11, r12 = 12,r13 = 13, r14 = 14, r15 = 15},
        immediate X = [0,0xFF], read, write;
        encoding = { opcode[8:0], 0b101, r1 = source, X  }
        syntax = "%source";
        cycles = 4;
    }

    addr-mode INDPUSH_B {
        operand source[12]: symbol = { r2 = 2, r3 = 3, r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
        r9 = 9, r10 = 10, r11 = 11, r12 = 12,r13 = 13, r14 = 14, r15 = 15},
        immediate X = [0,0xFF], read, write;
        encoding = { opcode[8:0], 0b101, r1 = source, X  }
        syntax = "%source";
        cycles = 5;
    }
    addr-mode INDCALL_B {
        operand source[12]: symbol = { r2 = 2, r3 = 3, r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
        r9 = 9, r10 = 10, r11 = 11, r12 = 12,r13 = 13, r14 = 14, r15 = 15},
        immediate X = [0,0xFF], read, write;
        encoding = { opcode[8:0], 0b101, r1 = source, X  }
        syntax = "%source";
        cycles = 5;
    }

    addr-mode INDREG_B {
        operand source[12]: symbol = { r2 = 2, r3 = 3, r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
        r9 = 9, r10 = 10, r11 = 11, r12 = 12,r13 = 13, r14 = 14, r15 = 15},
        immediate X = [0,0xFF], read, write;
            operand dest[4]: symbol = { r2 = 2, r3 = 3, r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
        r9 = 9, r10 = 10, r11 = 11, r12 = 12,r13 = 13, r14 = 14, r15 = 15} read, write;
        encoding = {opcode[3:0], r1 = source, 0b0101, r2 = dest, X }
        syntax = "%X(%source), %dest";
        cycles = 3;
    }
    addr-mode INDREG_W {
        operand source[20]: symbol = { r2 = 2, r3 = 3, r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
        r9 = 9, r10 = 10, r11 = 11, r12 = 12,r13 = 13, r14 = 14, r15 = 15},
        immediate X = [0,0xFFFF], read, write;
            operand dest[4]: symbol = { r2 = 2, r3 = 3, r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
        r9 = 9, r10 = 10, r11 = 11, r12 = 12,r13 = 13, r14 = 14, r15 = 15} read, write;
        encoding = { opcode[3:0], r1 = source, 0b0001, r2 = dest, X }
        syntax = "%X(%source), %dest";
        cycles = 3;
    }

    addr-mode INDIND_B {
        operand source[12]: symbol = { r2 = 2, r3 = 3, r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
        r9 = 9, r10 = 10, r11 = 11, r12 = 12,r13 = 13, r14 = 14, r15 = 15},
        immediate X = [0,0xFF], read, write;
        operand dest[12]: symbol = { r2 = 2, r3 = 3, r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
        r9 = 9, r10 = 10, r11 = 11, r12 = 12,r13 = 13, r14 = 14, r15 = 15},
        immediate Y = [0,0xFF], read, write;
        encoding = { opcode[3:0], r1 = source, 0b1101, r2 = dest, X, Y }
        syntax = "%X(%source), %Y(%dest)";
        cycles = 6;
    }

    addr-mode INDIND_W {
        operand source[20]: symbol = { r2 = 2, r3 = 3, r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
        r9 = 9, r10 = 10, r11 = 11, r12 = 12,r13 = 13, r14 = 14, r15 = 15},
        immediate X = [0,0xFFFF], read, write;
        operand dest[20]: symbol = { r2 = 2, r3 = 3, r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
        r9 = 9, r10 = 10, r11 = 11, r12 = 12,r13 = 13, r14 = 14, r15 = 15},
        immediate Y = [0,0xFFFF], read, write;
        encoding = { opcode[3:0], r1 = source, 0b1001, r2 = dest, X, Y }
        syntax = "%X(%source), %Y(%dest)";
        cycles = 6;
    }

    addr-mode INDSYM_B {
        operand source[12]: symbol = { r2 = 2, r3 = 3, r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
        r9 = 9, r10 = 10, r11 = 11, r12 = 12,r13 = 13, r14 = 14, r15 = 15},
        immediate X = [0,0xFF], read, write;
        operand dest[12]: symbol  = { r0 = 0 },
        immediate Y =[0,0xFF], read, write;
        encoding =  { opcode[3:0], r1 = source, 0b1101, r2 = dest, X,  Y - r0 }
        syntax = "%X(%source), %Y";
        cycles = 6;
    }

    addr-mode INDSYM_W {
        operand source[20]: symbol = { r2 = 2, r3 = 3, r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
        r9 = 9, r10 = 10, r11 = 11, r12 = 12,r13 = 13, r14 = 14, r15 = 15},
        immediate X = [0,0xFFFF], read, write;
        operand dest[20]: symbol  = { r0 = 0 },
        immediate Y =[0,0xFFFF], read, write;
        encoding = { opcode[3:0], r1 = source, 0b1001, r2 = dest, X, Y - r0 }
        syntax = "%X(%source), %Y";
        cycles = 6;
    }

    addr-mode INDABS_B {
        operand source[12]: symbol = { r2 = 2, r3 = 3, r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
        r9 = 9, r10 = 10, r11 = 11, r12 = 12,r13 = 13, r14 = 14, r15 = 15},
        immediate X = [0,0xFF], read, write;
        operand dest[12]: symbol = { r2 = 2 },
        immediate Y = [0, 0xFF], read, write;
        encoding = { opcode[3:0], r1 = source, 0b1101, r2 = dest, X, Y -r2 }
        syntax = "%X(%source), &%Y";
        cycles = 6;
    }     

    addr-mode INDABS_W {
        operand source[20]: symbol = { r2 = 2, r3 = 3, r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
        r9 = 9, r10 = 10, r11 = 11, r12 = 12,r13 = 13, r14 = 14, r15 = 15},
        immediate X = [0,0xFFFF], read, write;
        operand dest[20]: symbol = { r2 = 2 },
        immediate Y = [0, 0xFFFF], read, write;
        encoding = { opcode[3:0], r1 = source, 0b1001, r2 = dest, X, Y - r2 }
        syntax = "%X(%source), &%Y";
        cycles = 6;
    } 

    addr-mode SYM_W {
        operand source[20]: symbol  = { r0 = 0 },
        immediate X =[0,0xFFFF], read, write;
        encoding = { opcode[8:0], 0b001, r1 = source, X - r0  }
        syntax = "%X";
        cycles = 4;
    }

    addr-mode SYMPUSH_W {
        operand source[20]: symbol  = { r0 = 0 },
        immediate X =[0,0xFFFF], read, write;
        encoding = { opcode[8:0], 0b001, r1 = source, X - r0  }
        syntax = "%X";
        cycles = 5;
    }

    addr-mode SYMCALL_W {
        operand source[20]: symbol  = { r0 = 0 },
        immediate X =[0,0xFFFF], read, write;
        encoding = { opcode[8:0], 0b101, r1 = source, X - r0  }
        syntax = "%X";
        cycles = 5;
    }

    addr-mode SYM_B {
        operand source[12]: symbol  = { r0 = 0 },
        immediate X =[0,0xFF], read, write;
        encoding = { opcode[8:0], 0b101, r1 = source, X - r0  }
        syntax = "%X";
        cycles = 4;
    }

    addr-mode SYMPUSH_B {
        operand source[12]: symbol  = { r0 = 0 },
        immediate X =[0,0xFF], read, write;
        encoding = { opcode[8:0], 0b101, r1 = source, X - r0  }
        syntax = "%X";
        cycles = 5;
    }

    addr-mode SYMCALL_B {
        operand source[12]: symbol  = { r0 = 0 },
        immediate X =[0,0xFF], read, write;
        encoding = { opcode[8:0], 0b101, r1 = source, X - r0  }
        syntax = "%X";
        cycles = 5;
    }	

    addr-mode SYMREG_B {
        operand source[12]: symbol  = { r0 = 0 },
        immediate X =[0,0xFF], read, write;
        operand dest[4]: symbol = { r2 = 2, r3 = 3, r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
        r9 = 9, r10 = 10, r11 = 11, r12 = 12,r13 = 13, r14 = 14, r15 = 15} read, write;
        encoding = { opcode[3:0], r1 = source, 0b0101, r2 = dest, X - r0 }
        syntax = "%X, %dest";
        cycles = 3;
    }

    addr-mode SYMREG_W {
        operand source[20]: symbol  = { r0 = 0 },
        immediate X =[0,0xFFFF], read, write;
        operand dest[4]: symbol = { r2 = 2, r3 = 3, r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
        r9 = 9, r10 = 10, r11 = 11, r12 = 12,r13 = 13, r14 = 14, r15 = 15} read, write;
        encoding = { opcode[3:0], r1 = source, 0b0001, r2 = dest, X - r0 }
        syntax = "%X, %dest";
        cycles = 3;
    }

    addr-mode SYMIND_B {
        operand source[12]: symbol  = { r0 = 0 },
        immediate X =[0,0xFF], read, write;
        operand dest[12]: symbol = { r2 = 2, r3 = 3, r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
        r9 = 9, r10 = 10, r11 = 11, r12 = 12,r13 = 13, r14 = 14, r15 = 15},
        immediate Y = [0,0xFF], read, write;
        encoding = { opcode[3:0], r1 = source, 0b1101, r2 = dest, X - r0, Y }
        syntax = "%X, %Y(%dest)";
        cycles = 6;
    }

    addr-mode SYMIND_W {
        operand source[20]: symbol  = { r0 = 0 },
        immediate X =[0,0xFFFF], read, write;
        operand dest[20]: symbol = { r2 = 2, r3 = 3, r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
        r9 = 9, r10 = 10, r11 = 11, r12 = 12,r13 = 13, r14 = 14, r15 = 15},
        immediate Y = [0,0xFFFF], read, write;
        encoding = { opcode[3:0], r1 = source, 0b1001, r2 = dest, X - r0, Y }
        syntax = "%X, %Y(%dest)";
        cycles = 6;
    }		

    addr-mode SYMSYM_B {
        operand source[12]: symbol  = { r0 = 0 },
        immediate X =[0,0xFF], read, write;
        operand dest[12]: symbol  = { r0 = 0 },
        immediate Y =[0,0xFF], read, write;
        encoding = { opcode[3:0], r1 = source, 0b1101, r2 = dest, X - r0, Y - r0 }
        syntax = "%X, %Y";
        cycles = 6;
    }

    addr-mode SYMSYM_W {
        operand source[20]: symbol  = { r0 = 0 },
        immediate X =[0,0xFFFF], read, write;
        operand dest[20]: symbol  = { r0 = 0 },
        immediate Y =[0,0xFFFF], read, write;
        encoding = { opcode[3:0], r1 = source, 0b1001, r2 = dest, X - r0, Y - r0 }
        syntax = "%X, %Y";
        cycles = 6;
    }

    addr-mode SYMABS_B {
        operand source[12]: symbol = { r0 = 0 },
        immediate X = [0,0xFF], read, write;
        operand dest[12]: symbol = { r2 = 2 },
        immediate Y = [0,0xFF], read, write;
        encoding = { opcode[3:0], r1 = source, 0b1101, r2 = dest, X - r0, Y - r2 }
        syntax = "%X, &%Y";
        cycles = 6;
    }

    addr-mode SYMABS_W {
        operand source[20]: symbol = { r0 = 0 },
        immediate X = [0,0xFFFF], read, write;
        operand dest[20]: symbol = { r2 = 2 },
        immediate Y = [0,0xFFFF], read, write;
        encoding = { opcode[3:0], r1 = source, 0b1001, r2 = dest, X - r0, Y - r2 }
        syntax = "%X, &%Y";
        cycles = 6;
    }

    addr-mode ABS_W {
        operand source[20]: symbol = { r2 = 2 },
        immediate Y = [0,0xFFFF], read, write;
        encoding = { opcode[8:0], 0b001, r1 = source, Y - r2  }
        syntax = "&%X";
        cycles = 4;
    }

    addr-mode ABSPUSH_W {
        operand source[20]: symbol = { r2 = 2 },
        immediate Y = [0,0xFFFF], read, write;
        encoding = { opcode[8:0], 0b001, r1 = source, Y - r2  }
        syntax = "&%X";
        cycles = 5;
    }

    addr-mode ABSCALL_W {
        operand source[20]: symbol = { r2 = 2 },
        immediate Y = [0,0xFFFF], read, write;
        encoding = { opcode[8:0], 0b101, r1 = source, Y - r2  }
        syntax = "&%X";
        cycles = 5;
    }

    addr-mode ABS_B {
        operand source[12]: symbol = { r2 = 2 },
        immediate Y = [0,0xFF], read, write;
        encoding = { opcode[8:0], 0b101, r1 = source, Y - r2  }
        syntax = "&%X";
        cycles = 4;
    }

    addr-mode ABSPUSH_B {
        operand source[12]: symbol = { r2 = 2 },
        immediate Y = [0,0xFF], read, write;
        encoding = { opcode[8:0], 0b101, r1 = source, Y - r2 }
        syntax = "&%X";
        cycles = 5;
    }

    addr-mode ABSCALL_B {
        operand source[12]: symbol = { r2 = 2 },
        immediate Y = [0,0xFF], read, write;
        encoding = { opcode[8:0], 0b101, r1 = source, Y - r2  }
        syntax = "&%X";
        cycles = 5;
    }	

    addr-mode ABSREG_B {
        operand source[12]: symbol = { r2 = 2 },
        immediate X = [0,0xFF], read, write;
        operand dest[4]: symbol = { r2 = 2, r3 = 3, r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
        r9 = 9, r10 = 10, r11 = 11, r12 = 12,r13 = 13, r14 = 14, r15 = 15} read, write;
        encoding = { opcode[3:0], r1 = source, 0b0101, r2 = dest, X - r2 }
        syntax = "&%X, %dest";
        cycles = 3;
    }

    addr-mode ABSREG_W {
        operand source[20]: symbol = { r2 = 2 },
        immediate X = [0,0xFFFF], read, write;
        operand dest[4]: symbol = { r2 = 2, r3 = 3, r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
        r9 = 9, r10 = 10, r11 = 11, r12 = 12,r13 = 13, r14 = 14, r15 = 15} read, write;
        encoding = { opcode[3:0], r1 = source, 0b0001, r2 = dest, X - r2 }
        syntax = "&%X, %dest";
        cycles = 3;
    }

    addr-mode ABSIND_B {
        operand source[12]: symbol = { r2 = 2 },
        immediate X = [0,0xFF], read, write;
        operand dest[12]: symbol = { r2 = 2, r3 = 3, r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
        r9 = 9, r10 = 10, r11 = 11, r12 = 12, r13 = 13, r14 = 14, r15 = 15},
        immediate Y = [0,0xFF], read, write;
        encoding = { opcode[3:0], r1 = source, 0b1101, r2 = dest, X - r2, Y }
        syntax = "&%X, %Y(%dest)";
        cycles = 6;
    }

    addr-mode ABSIND_W {
        operand source[20]: symbol = { r2 = 2 },
        immediate X = [0,0xFFFF], read, write;
        operand dest[20]: symbol = { r2 = 2, r3 = 3, r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
        r9 = 9, r10 = 10, r11 = 11, r12 = 12, r13 = 13, r14 = 14, r15 = 15},
        immediate Y = [0,0xFFFF], read, write;
        encoding = { opcode[3:0], r1 = source, 0b1001, r2 = dest, X - r2, Y }
        syntax = "&%X, %Y(%dest)";
        cycles = 6;
    }

    addr-mode ABSSYM_B {
        operand source[12]: symbol = { r2 = 2 },
        immediate X = [0,0xFF], read, write;
        operand dest[12]: symbol  = { r0 = 0 },
        immediate Y =[0,0xFF], read, write;
        encoding = { opcode[3:0], r1 = source, 0b1101, r2 = dest, X - r2, Y - r0 }
        syntax = "&%X, %Y";
        cycles = 6;
    }

    addr-mode ABSSYM_W {
        operand source[20]: symbol = { r2 = 2 },
        immediate X = [0,0xFFFF], read, write;
        operand dest[20]: symbol  = { r0 = 0 },
        immediate Y =[0,0xFFFF], read, write;
        encoding = { opcode[3:0], r1 = source, 0b1001, r2 = dest, X - r2, Y - r0 }
        syntax = "&%X, %Y";
        cycles = 6;
    }

    addr-mode ABSABS_B {
        operand source[12]: symbol = { r2 = 2 },
        immediate X = [0,0xFF], read, write;
        operand dest[12]: symbol = {r2 = 2 },
        immediate Y = [0,0xFF], read, write;
        encoding = { opcode[3:0], r1 = source, 0b1101, r2 = dest, X - r2, Y - r2 }
        syntax = "&%X, &%Y";
        cycles = 6;
    }

    addr-mode ABSABS_W {
        operand source[20]: symbol = { r2 = 2 },
        immediate X = [0,0xFFFF], read, write;
        operand dest[20]: symbol = {r2 = 2 },
        immediate Y = [0,0xFFFF], read, write;
        encoding = { opcode[3:0], r1 = source, 0b1001, r2 = dest, X - r2, Y - r2 }
        syntax = "&%X, &%Y";
        cycles = 6;
    }

    addr-mode INREG_W {
        operand source: SREG_W;
        encoding = { opcode[8:0], 0b010, r1 = source  }
        syntax = "@%source";
        cycles = 3;
    }

    addr-mode INREGPUSH_W {
        operand source: SREG_W;
        encoding = { opcode[8:0], 0b010, r1 = source  }
        syntax = "@%source";
        cycles = 4;
    }

    addr-mode INREGCALL_W {
        operand source: SREG_W;
	    encoding = { opcode[8:0], 0b110, r1 = source  }
	    syntax = "@%source";
	    cycles = 4;
    }

    addr-mode INREG_B {
        operand source: SREG_B;
        encoding = { opcode[8:0], 0b110, r1 = source  }
        syntax = "@%source";
        cycles = 3;
    }

    addr-mode INREGPUSH_B {
        operand source: SREG_B;
        encoding = { opcode[8:0], 0b110, r1 = source  }
        syntax = "@%source";
        cycles = 4;
    }

    addr-mode INREGCALL_B {
        operand source: SREG_B;
        encoding = { opcode[8:0], 0b110, r1 = source  }
        syntax = "@%source";
        cycles = 4;
    }	

    addr-mode INREGREG_B {
        operand source: SREG_B;
        operand dest: SREG_B;
        encoding = { opcode[3:0], r1 = contofaddyatsource, 0b0110, r2 = dest }
        syntax = "@%source, %dest";
        cycles = 2;
    }	

    addr-mode INREGREG_W {
        operand source: SREG_W;
        operand dest: SREG_W;
        encoding = { opcode[3:0], r1 = contofaddyatsource, 0b0010, r2 = dest }
        syntax = "@%source, %dest";
        cycles = 2;
    }	

    addr-mode INREGIND_B {
        operand source: SREG_B;
        operand dest[12]: symbol = { r2 = 2, r3 = 3, r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
        r9 = 9, r10 = 10, r11 = 11, r12 = 12, r13 = 13, r14 = 14, r15 = 15},
        immediate X = [0,0xFF], read, write;
        encoding = { opcode[3:0], r1 = contofaddyatsource, 0b1110, r2 = dest, X }
        syntax = "@%source, %X(%dest)";
        cycles = 5;
    }

    addr-mode INREGIND_W {
        operand source: SREG_W;
        operand dest[20]: symbol = { r2 = 2, r3 = 3, r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
        r9 = 9, r10 = 10, r11 = 11, r12 = 12, r13 = 13, r14 = 14, r15 = 15},
        immediate X = [0,0xFFFF], read, write;
        encoding = { opcode[3:0], r1 = contofaddyatsource, 0b1010, r2 = dest, X }
        syntax = "@%source, %X(%dest)";
        cycles = 5;
    }

    addr-mode INREGSYM_B {
        operand source: SREG_B;
        operand dest[12]: symbol  = { r0 = 0 },
        immediate X =[0,0xFF], read, write;
        encoding = { opcode[3:0], r1 = contofaddyatsource, 0b1110, r2 = dest, X - r0 }
        syntax = "@%source, %X";
        cycles = 5;
    }

    addr-mode INREGSYM_W {
        operand source: SREG_W;
        operand dest[20]: symbol  = { r0 = 0 },
        immediate X =[0,0xFFFF], read, write;
        encoding = { opcode[3:0], r1 = contofaddyatsource, 0b1010, r2 = dest, X - r0 }
        syntax = "@%source, %X";
        cycles = 5;
    }

    addr-mode INREGABS_B {
        operand source: SREG_B;
        operand dest[12]: symbol = {r2 = 2 },
        immediate X = [0,0xFF], read, write;
        encoding = { opcode[3:0], r1 = contofaddyatsource, 0b1110, r2 = dest, X - r2 }
        syntax = "@%source, &%X";
        cycles = 5;
    }

    addr-mode INREGABS_W {
        operand source: SREG_W;
        operand dest[20]: symbol = {r2 = 2 },
        immediate X = [0,0xFFFF], read, write;
        encoding = { opcode[3:0], r1 = contofaddyatsource, 0b1010, r2 = dest, X - r2 }
        syntax = "@%source, &%X";
        cycles = 5;
    }

    addr-mode INDRA_W {
        operand source: SREG_W;
        encoding = { opcode[8:0], 0b011, r1 = source  }
        syntax = "@%source+";
        cycles = 3;
    }

    addr-mode INDRAPUSH_W {
        operand source: SREG_W;
        encoding = { opcode[8:0], 0b011, r1 = source  }
        syntax = "@%source+";
        cycles = 5;
    }

    addr-mode INDRACALL_W {
        operand source: SREG_W;
        encoding = { opcode[8:0], 0b111, r1 = source  }
        syntax = "@%source+";
        cycles = 5;
    }

    addr-mode INDRA_B {
        operand source: SREG_B;
	    encoding = { opcode[8:0], 0b111, r1 = source  }
	    syntax = "@%source+";
	    cycles = 3;
    }
    addr-mode INDRAPUSH_B {
        operand source: SREG_B;
        encoding = { opcode[8:0], 0b111, r1 = source  }
        syntax = "@%source+";
        cycles = 5;
    }

    addr-mode INDRACALL_B {
        operand source: SREG_B;
        encoding = { opcode[8:0], 0b111, r1 = source  }
        syntax = "@%source+";
        cycles = 5;
    }	
    addr-mode INDRAREG_B {
        operand source: SREG_B;
        operand dest[4]: SREG_B;
        encoding = { opcode[3:0], r1 = contofaddyatsource, 0b0111, r2 = dest }
        syntax = "@%source+, %dest";
        cycles = 2;
   }
    addr-mode INDRAREG_W {
        operand source: SREG_W;
        operand dest: SREG_W;
        encoding = { opcode[3:0], r1 = contofaddyatsource, 0b0011, r2 = dest }
        syntax = "@%source+, %dest";
        cycles = 2;
   }
    addr-mode INDRAIND_B {
        operand source: SREG_B;
        operand dest[12]: symbol = {r2 = 2, r3 = 3, r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
        r9 = 9, r10 = 10, r11 = 11, r12 = 12, r13 = 13, r14 = 14, r15 = 15},
        immediate X = [0,0xFF], read, write;
        encoding = { opcode[3:0], r1 = contofaddyatsource, 0b1111, r2 = dest, X }
        syntax = "@%source+, %X(%dest)";
        cycles = 5;
    }  	

    addr-mode INDRAIND_W {
	    operand source: SREG_W;
	    operand dest[20]: symbol = {r2 = 2, r3 = 3,  r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
	    r9 = 9, r10 = 10, r11 = 11, r12 = 12, r13 = 13, r14 = 14, r15 = 15},
	    immediate X = [0,0xFFFF], read, write;
	    encoding = { opcode[3:0], r1 = contofaddyatsource, 0b1011, r2 = dest, X }
	    syntax = "@%source+, %X(%dest)";
	    cycles = 5;
    }

    addr-mode INDRASYM_B {
        operand source: SREG_B;
        operand dest[12]: symbol  = { r0 = 0 },
        immediate X =[0,0xFF], read, write;
        encoding = { opcode[3:0], r1 = contofaddyatsource, 0b1111, r2 = dest, X - r0 }
        syntax = "@%source+, %X";
        cycles = 5;
    }

    addr-mode INDRASYM_W {
        operand source: SREG_W;
        operand dest[20]: symbol  = { r0 = 0 },
        immediate X =[0,0xFFFF], read, write;
        encoding = { opcode[3:0], r1 = contofaddyatsource, 0b1011, r2 = dest, X - r0 }
        syntax = "@%source+, %X";
        cycles = 5;
    }

    addr-mode INDRAABS_B {
        operand source: SREG_B;
        operand dest[12]: symbol  = { r2 = 2 },
        immediate X =[0,0xFF], read, write;
        encoding = { opcode[3:0], r1 = contofaddyatsource, 0b1111, r2 = dest, X - r2 }
        syntax  = "@%source+, %X";
        cycles = 5;
    }
    addr-mode INDRAABS_W {
        operand source: SREG_W;
        operand dest[20]: symbol  = { r2 = 2 },
        immediate X =[0,0xFFFF], read, write;
        encoding = { opcode[3:0], r1 = contofaddyatsource, 0b1011, r2 = dest, X - r2 }
        syntax = "@%source+, %X";
        cycles = 5;
    }

    //Using of RRA, RRC, SWPB, and SXT instructions with an Immediate operand is not allowed

    addr-mode IMMEDPUSH_W {
        operand source[20]: symbol = { r2 = 2 } read, write;
        encoding = { opcode[8:0], 0b011, r1 = source  }
        syntax = "#%contofaddyatsource";
        cycles = 4;
    }
    addr-mode IMMEDCALL_W {
        operand source[20]: symbol = { r2 = 2 } read, write;
        encoding = { opcode[8:0], 0b111, r1 = source  }
        syntax = "#%contofaddyatsource";
        cycles = 5;
    }

    //Using of RRA, RRC, SWPB, and SXT instructions with an Immediate operand is not allowed

    addr-mode IMMEDPUSH_B {
        operand source[12]: symbol = { r2 = 2 } read, write;
        encoding = { opcode[8:0], 0b111, r1 = source  }
        syntax = "#%contofaddyatsource";
        cycles = 4;
    }

    addr-mode IMMEDCALL_B {
        operand source[12]: symbol = { r2 = 2 } read, write;
        encoding = { opcode[8:0], 0b111, r1 = source  }
        syntax = "#%contofaddyatsource";
        cycles = 5;
    }	

    addr-mode IMMEDREG_B {
        operand source[12]: symbol = { r2 = 2 } read, write;  //The PC points to the word following the instruction and moves the contents to dest
        operand dest[4]: symbol = { r2 = 2, r3 = 3,r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
        r9 = 9, r10 = 10, r11 = 11, r12 = 12,r13 = 13, r14 = 14, r15 = 15} read, write;
        encoding = { opcode[3:0], r1 = contofaddyatsource, 0b0111, r2 = dest }
        syntax = "#%contofaddyatsource, %dest";
        cycles = 2;
    }

    addr-mode IMMEDREG_W {
        operand source[20]: symbol = { r2 = 2 } read, write;  //The PC points to the word following the instruction and moves the contents to dest
        operand dest[4]: symbol = {r2 = 2, r3 = 3, r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
        r9 = 9, r10 = 10, r11 = 11, r12 = 12,r13 = 13, r14 = 14, r15 = 15} read, write;
        encoding = { opcode[3:0], r1 = contofaddyatsource, 0b0011, r2 = dest }
        syntax = "#%contofaddyatsource, %dest";
        cycles = 2;
    }

    addr-mode IMMEDIND_B {
        operand source[12]: symbol = { r2 = 2 } read, write;  //The PC points to the word following the instruction and moves the contents to dest
        operand dest[12]: symbol = { r2 = 2, r3 = 3,r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
        r9 = 9, r10 = 10, r11 = 11, r12 = 12, r13 = 13, r14 = 14, r15 = 15},
        immediate X = [0,0xFF], read, write;
        encoding = { opcode[3:0], r1 = contofaddyatsource, 0b1111, r2 = dest, X }
        syntax = "#%contofaddyatsource, %X(%dest)";
        cycles = 5;
    }

    addr-mode IMMEDIND_W {
        operand source[20]: symbol = { r2 = 2 } read, write;  //The PC points to the word following the instruction and moves the contents to dest
        operand dest[20]: symbol = {r2 = 2, r3 = 3, r4 = 4, r5 = 5, r6 = 6, r7 = 7, r8 = 8,
        r9 = 9, r10 = 10, r11 = 11, r12 = 12, r13 = 13, r14 = 14, r15 = 15},
        immediate X = [0,0xFFFF], read, write;
        encoding = { opcode[3:0], r1 = contofaddyatsource, 0b1011, r2 = dest, X }
        syntax = "#%contofaddyatsource, %X(%dest)";
        cycles = 5;
    }

    addr-mode IMMEDSYM_B {
        operand source[12]: symbol = { r2 = 2 } read, write;  //The PC points to the word following the instruction and moves the contents to dest
        operand dest[12]: symbol  = { r0 = 0 },
        immediate X =[0,0xFF], read, write;
        encoding = { opcode[3:0], r1 = contofaddyatsource, 0b1111, r2 = dest, X - r0 }
        syntax = "#%contofaddyatsource, %X";
        cycles = 5;
    }

    addr-mode IMMEDSYM_W {
        operand source[20]: symbol = { r2 = 2 } read, write;  //The PC points to the word following the instruction and moves the contents to dest
        operand dest[20]: symbol  = { r0 = 0 },
        immediate X =[0,0xFFFF], read, write;
        encoding = { opcode[3:0], r1 = contofaddyatsource, 0b1011, r2 = dest, X - r0 }
        syntax = "#%contofaddyatsource, %X";
        cycles = 5;
    }

    addr-mode IMMEDABS_B {
        operand source[12]: symbol = { r2 = 2 } read, write;  //The PC points to the word following the instruction and moves the contents to dest
        operand dest[12]: symbol  = { r2 = 2 },
        immediate X =[0,0xFF], read, write;
        encoding = { opcode[3:0], r1 = contofaddyatsource, 0b1111, r2 = dest, X - r2 }
        syntax = "#%contofaddyatsource, &%X";
        cycles = 5;
    }
    addr-mode IMMEDABS_W {
        operand source[20]: symbol = { r2 = 2 } read, write;  //The PC points to the word following the instruction and moves the contents to dest
        operand dest[20]: symbol  = { r2 = 2 },
        immediate X =[0,0xFFFF], read, write;
        encoding = { opcode[3:0], r1 = contofaddyatsource, 0b1011, r2 = dest, X - r2 }
        syntax = "#%contofaddyatsource, &%X";
        cycles = 5;
    }	

    addr-mode JMP {                 //Not sure if this is the only addressing mode need for Jump instructions...
        operand source[10]: int = {offset[0,0x3FF] } read, write;
        encoding = {opcode[7:2], r1 = offset }
        syntax = "%offset";
        cycles = 2;
    } 

    addr-set DOUBLE_W = {
        REGREG_W,
        REGIND_W,
    }

    addr-set SINGLE_W = {
    }

    addr-set DOUBLE_B = {
    }

    addr-set SINGLE_B = {
    }

//---------------------------------------------------------------------------
//  SUBROUTINES
//---------------------------------------------------------------------------
    inline subroutine performAddition(r1: int, r2: int, carry: int): byte {
        local result: int = r1 + r2 + carry;
        local ral: int = r1[3:0];
        local rbl: int = r2[3:0];

        local Rd7: boolean = r1[7];
        local Rr7: boolean = r2[7];
        local R7: boolean = result[7];

        // set the flags as per instruction set documentation.
        C = result[8];
        N = result[7];
        Z = low(result) == 0;
        V = (Rd7 and Rr7 and !R7) or (!Rd7 and !Rr7 and R7);

        return low(result);
    }

    inline subroutine performAdditionW(r1: int, r2: int, carry: int): word {
        local result: int = r1 + r2 + carry;
        local ral: int = r1[7:0];
        local rbl: int = r2[7:0];

        local Rd15: boolean = r1[15];
        local Rr15: boolean = r2[15];
        local R15: boolean  = result[15];

        C = result[16];
        N = result[15];
        Z = (result == 0);
        V = (Rd15 and Rr15 and !R15) or (!Rd15 and !Rr15 and R15);

        return result;
    }
	

    inline subroutine performSubtraction(r1: int, r2: int, carry: int): byte {
        local result: int = r1 - r2 - carry;

        local Rd7: boolean = r1[7];
        local Rr7: boolean = r2[7];
        local R7:  boolean = result[7];
        local Rd3: boolean = r1[3];
        local Rr3: boolean = r2[3];
        local R3:  boolean = result[3];

        // set the flags as per instruction set documentation.
        C = (!Rd7 and Rr7) or (Rr7 and R7) or (R7 and !Rd7);
        N = R7;
        Z = low(result) == 0;
        V = (Rd7 and !Rr7 and !R7) or (!Rd7 and Rr7 and R7);

        return low(result);
    }
    inline subroutine performSubtractionW(r1: int, r2: int, carry: int): word {
        local result: int = r1 - r2 - carry;

        local Rd15: boolean = r1[15];
        local Rr15: boolean = r2[15];
        local R15:  boolean = result[15];
        local Rd7: boolean = r1[7];
        local Rr7: boolean = r2[7];
        local R7:  boolean = result[7];

        // set the flags as per instruction set documentation.

        C = (!Rd15 and Rr15) or (Rr15 and R15) or (R15 and !Rd15);
        N = R15;
        Z = (low(result) == 0 and high(result) == 0);
        V = (Rd15 and !Rr15 and !R15) or (!Rd15 and Rr15 and R15);
       
        return result;
    }


    inline subroutine performAnd(r1: int, r2: int): byte {
        local result: int = r1 & r2;

        N = result[7];
        Z = low(result) == 0;
        V = false;
        C = !N;

        return low(result);
    }

    inline subroutine performAndW(r1: int, r2: int): word {
        local result: int = r1 & r2;

        N = result[15];
        C = !N;
        Z = if(result == 0);
        V = 0;
    }

    subroutine performDeciAddCW(r1: int, r2: int, carry: int): word { //16 bit operation
        local r10dec: int = 0;    //First   BCD sum
        local r20dec: int = 0;	  //Second BCD sum
        local r30dec: int = 0;    //Third  BCD sum
        local r40dec: int = 0;   //Fourth  BCD sum

        if ( carry)               //adds carry to source if carry set
                r10dec = 1;
        if ( r1[3:0] < 0b1010 and r2[3:0] < 0b1010) {
           r10dec  = r1[3:0] + r2[3:0];    //sums lowest BCDs
           if (r10dec > 9) {
             r10dec = r10dec - 10;    //if sum overflowed, reset and
                 r20dec = r20dec + 1;   //add one to next BCD sum
               }
             }
        if (r1[7:4] < 0b1010 and r2[7:4] < 0b1010) {
               r20dec = r1[7:4]  + r2[7:4];  //sums second BCD pairs
           if (r20dec > 9) {
                 r20dec = r20dec - 10;
                 r30dec = r30dec + 1;
               }
             }
        if (r1[11:8] < 0b1010 and r2[11:8] < 0b1010) {
               r30dec = r1[11:8]  + r2[11:8];  //sums third BCD pairs
           if (r30dec > 9) {
                 r30dec = r30dec - 10;
                 r40dec = r40dec + 1;
               }
             }
        if (r1[15:12] < 0b1010 and r2[15:12] < 0b1010) {
               r40dec = r1[15:12]  + r2[15:12];  //sums fourth BCD pairs
           if (r40dec > 9) {
                 r40dec = r40dec - 10;
                 C = 1;
               }
             }
        local result: int = (r40dec * 1000) + (r30dec * 100) + (r20dec * 10) + r10dec;

        N =(r40dec[3] == 1);   // set N if MSB is negative.
        Z = !(result);        //reset Z unless result is zero
        return result;
    }


    subroutine performDeciAddC(r1: int, r2: int, carry: int): byte {  //8 bit operation
        local r1ldec: int   = 0;
        local r1hdec: int   = 0;
        local rltotdec: int = 0;
        local r2ldec: int   = 0;
        local r2hdec: int   = 0;
        local rhtotdec: int = 0;
        if (r1[0])
            r1ldec = r1ldec + 1;
        if (r1[1])
            r1ldec = r1ldec + 2;
        if (r1[2])
            r1ldec = r1ldec + 4;
        if (r1[3])
            r1ldec = r1ldec + 8;
        if (r1[4])
            r1hdec = r1hdec + 1;
        if (r1[5])
            r1hdec = r1hdec + 2;
        if (r1[6])
            r1hdec = r1hdec + 4;
        if (r1[7])
            r1hdec = r1hdec + 8;
        r1ldec = r1ldec + carry;    //adding of the source operand to carry
        if (r1ldec > 9) {          //if lower BCD overflows, add 1 to next digit
           r1ldec = r1ldec - 10;
           r1hdec = r1hdec + 1;
        }
        if (r1hdec > 9) {         //if higher BCD overflows, sub 10 and set carry bit
           r1hdec = r1hdec - 10;
           C = 1;
        }
        if (r2[0])
            r2ldec = r2ldec + 1;
        if (r2[1])
            r2ldec = r2ldec + 2;
        if (r2[2])
            r2ldec = r2ldec + 4;
        if (r2[3])
            r2ldec = r2ldec + 8;
        if (r2[4])
            r2hdec = r2hdec + 1;
        if (r2[5])
            r2hdec = r2hdec + 2;
        if (r2[6])
            r2hdec = r2hdec + 4;
        if (r2[7])
            r2hdec = r2hdec + 8;
        rltotdec = r1ldec + r2ldec;   ///adding lower BCDs (source and dest)
        if (rltotdec > 9) {     //if sum is greater that 9, sub. 10 and add 1 to
           rltotdec = rltotdec - 10;  // higher BCD
           rhtotdec = rhtotdec + 1;
        }
        rhtotdec = rhtotdec + r1hdec + r2hdec; //add up higher BCDs
        if (rhtotdec > 9) {      //if higher BCD overflows, sub 10 and set carry bit
           rhtotdec = rhtotdec  - 10;
           C = 1;
        }
        N = (rhtotdec[3] == 1);                      //set if MSB is 1
        Z = (((rhtotdec * 10) + rltotdec) == 0);    //set if result is 0
        return low((rhtotdec * 10) + rltotdec);
    }

    inline subroutine relativeBranch(target: int): void {
        nextPC = relative(target);
        cyclesConsumed = cyclesConsumed + 1;
    }

    inline subroutine relative(target: int): int {
        return (target * 2) + nextPC;
    }

    inline subroutine absolute(target: int): int {
        return target * 2;
    }

    inline subroutine skip(): void {
        local dist: int = $isize(nextPC);
        nextPC = nextPC + dist;
        if ( dist == 4 ) cyclesConsumed = cyclesConsumed + 2;
        else cyclesConsumed = cyclesConsumed + 1;
    }

    inline subroutine pushPC(npc: int): void {
        npc = npc / 2;
        pushByte(low(npc));
        pushByte(high(npc));
    }

    inline subroutine popPC(): int {
        local high: byte = popByte();
        local low: byte = popByte();
        return uword(low, high) * 2;
    }

    inline subroutine low(v: int): byte {
        return v:byte;
    }

    inline subroutine high(v: int): byte {
        return (v >> 8):byte;
    }

    inline subroutine uword(low: byte, high: byte): int {
        return ((high << 8) | low)[15:0];
    }

    external bit(b: boolean): int;
    external popByte(): byte;
    external pushByte(b: byte): void;


//---------------------------------------------------------------------------
//  BEGIN INSTRUCTION SET DESCRIPTION
//---------------------------------------------------------------------------
	
    instruction "adc" ops: SINGLE_W {
        opcode = 0b0110;                     //opcode for ADDC (6) emulated to ADC
        execute = {
            local r1: int       = read(ops.source);
            local result: int   = r1 + bit(C);
                                    //word operation
            local R15: boolean  = result[15];
            local Rdh7: boolean = r1[15];
            C = (!R15 and Rdh7);
            N = (R15);
            V = (!Rdh7 and R15);
            Z = (result[15:0]  == 0);

            write(ops.source, result: short);
        }
    }

    instruction "adc.b" ops: SINGLE_B {
        opcode = 0b0110;                     //opcode for ADDC (6) emulated to ADC
        execute = {
            local r1: int       = read(ops.source);
            local result: int   = r1 + bit(C);

            //byte operation
            local R7: boolean   = result[7];
            local Rdh1: boolean = r1[7];
            C = (!R7 and Rdh1);
            N = (R7);
            V = (!Rdh1 and R7);
            Z = (result[7:0]  == 0);

            write(ops.source, result: byte);
        }
    }


    instruction "add" ops: DOUBLE_W {
	    opcode = 0b0101;
        execute = {
            local r1: short = read(ops.source);
            local r2: short = read(ops.dest);
            local result: short = performAdditionW(r1, r2, 0);
            write(ops.dest, result);
        }
    }

    instruction "add.b" ops: DOUBLE_B {
        opcode = 0b0101;
        execute = {
            local r1: byte = read(ops.source);
            local r2: byte = read(ops.dest);
            local result: byte = performAddition(r1, r2, 0);
            write(ops.dest, result);
        }
    }

    instruction "addc" ops: DOUBLE_W {
        opcode = 0b0110;
        execute = {
            local r1: short = read(ops.source);
            local r2: short = read(ops.dest);
            local result: short = performAdditionW(r1, r2, bit(C));
            write(ops.dest, result);
        }
    }

    instruction "addc.b" ops: DOUBLE_B {
        opcode = 0b0110;
    	execute = {
            local r1: byte = read(ops.source);
            local r2: byte = read(ops.dest);
            local result: byte = performAddition(r1, r2, bit(C));
            write(ops.dest, result);
   	    }
    }

    instruction "and" ops: DOUBLE_W {
	    opcode = 0b1111;
	    execute = {
            local r1: short = read(ops.source);
            local r2: short = read(ops.dest);
            local result: short = performAndW(r1, r2);
            write(ops.dest, result);
        }
    }

    instruction "and.b" ops: DOUBLE_B {
	    opcode = 0b1111;
	    execute = {
            local r1: byte = read(ops.source);
            local r2: byte = read(ops.dest);
            local result: byte = performAnd(r1, r2);
            write(ops.dest, result);
        }
    }

    instruction "bic" ops: DOUBLE_W {    //logical and on inverted source and dest
	    opcode = 0b1100;                        //status bits are not affected
	    execute = {
            write(ops.dest, ~(read(ops.source)) & read(ops.dest));
        }
    }

    instruction "bic.b" ops: DOUBLE_B {    //logical and on inverted source and dest
	    opcode = 0b1100;                        //status bits are not affected
	    execute = {
            write(ops.dest, ~(read(ops.source)) & read(ops.dest));
        }
    }

    instruction "bis" ops: DOUBLE_W {   //logical or on source and dest
        opcode = 0b1101;                       //status bits not affected
        execute = { 
            write(ops.dest, read(ops.source) | read(ops.dest));
        }
     }

    instruction "bis.b" ops: DOUBLE_B {   //logical or on source and dest
        opcode = 0b1101;                       //status bits not affected
        execute = { 
            write(ops.dest, read(ops.source) | read(ops.dest));
        }
     }

    instruction "bit" ops: DOUBLE_W {   //test bits in dest by anding source
	    opcode = 0b1011;                         //with dest and affecting only status bits
	    execute = {
	        performAndW(read(ops.source), read(ops.dest));
        }
    }

    instruction "bit.b" ops: DOUBLE_B {   //test bits in dest by anding source
	    opcode = 0b1011;                         //with dest and affecting only status bits
	    execute = {
	        performAndW(read(ops.source), read(ops.dest));
        }
    }

    instruction "br" ops: SINGLE_W {  //uncondtional branch emulated by moving
	    opcode = 0b0100;                     //operand to Program counter
	    execute = {
		    // emulated by MOV instruction
	        nextPC = read(ops.source);
	    }
    }

    instruction "call" ops: SINGLE_W {     //calls a subroutine from 64k address space
	    opcode = 0b000100201000;          //stores old pc on TOS while jumping to subroutine
	    execute = {
            local temp: int = read(ops.source);  //r1 is the SP, r0 is the PC
            pushPC(nextPC);
            nextPC = temp;
        }
    }

    instruction "clr" ops: SINGLE_W {             //emulated by MOV instruction
    	opcode = 0b0100;
        execute = {
            // note: the read is necessary for the auto-increment operands
            read(ops.source);
            write(ops.source, 0);
        }
    }

    instruction "clr.b" ops: SINGLE_B {           //emulated by MOV instruction
	    opcode = 0b0100;
	    execute = {
            // note: the read is necessary for the auto-increment operands
            read(ops.source);
            write(ops.source, 0);
	    }
    }


    instruction "clrc" {               //clear carry bit by anding with #1
	    opcode = 0b1100;
        execute = {
		    //emulated by BIC instruction
            C = false;
	    }
    }

    instruction "clrn" {             //clear neg. bit by anding with #4
	    opcode = 0b1100;
        execute = {
       		//emulated by BIC instruction
            N = false;
	    }
    }

    instruction "clrz" {
        opcode = 0b1100;
        execute = {
    		//emulated by BIC instruction
            Z = false;
	    }
    }

    instruction "cmp" ops: DOUBLE_W {      // compares 2 operands by
	    opcode = 0b1001;                   // adding source with inverted dest
	    execute = {                        // and adding 1 to the result
	        performAdditionW(read(ops.source), ~(read(ops.dest)), 1);
        }
    }

    instruction "cmp.b" ops: DOUBLE_B {    // compares 2 operands by
    	opcode = 0b1001;                   // adding source with inverted dest
	    execute = {                        // and adding 1 to the result
	        performAdditionW(read(ops.source), ~(read(ops.dest)), 1);
        }
    }

    instruction "dadc" ops: SINGLE_W {   // add carry decimally to dest
	    opcode = 0b1010;                 // emulated by DADD instruction
	    execute = {
	        write(ops.source, performDeciAddCW(0, read(ops.source), bit(C)));
	    }
    }

    instruction "dadc.b" ops: SINGLE_B {   // add carry decimally to dest
	    opcode = 0b1010;                   // emulated by DADD instruction
	    execute = {
	        write(ops.source, performDeciAddCW(0, read(ops.source), bit(C)));
	    }
    }

    instruction "dadd" ops: DOUBLE_W {  //source and carry added decimally to dest
	    opcode = 0b1010;
	    execute = {
	        write(ops.dest, performDeciAddCW(read(ops.source), read(ops.dest), bit(C)));
	    }
    }

    instruction "dadd.b" ops: DOUBLE_B {  //source and carry added decimally to dest
	    opcode = 0b1010;
	    execute = {
	        write(ops.dest, performDeciAddCW(read(ops.source), read(ops.dest), bit(C)));
	    }
    }

    instruction "dec" ops: SINGLE_W  {
	    opcode = 0b1000;        // emulated by subtraction operation
	    execute = {
	        local original: short = read(ops.source);
	        write(ops.source, performSubtractionW(original, 1, 0));
 	        if (original == 1)
 	            N = 1;    // if original value of dest was 1, set N bit
        }
    }

    instruction "dec.b" ops: SINGLE_B  {
	    opcode = 0b1000;        //emulated by subtraction operation
	    execute = {
	        local original: byte = read(ops.source);
	        write(ops.source, performSubtraction(original, 1, 0));
 	        if (original == 1)
 	            N = 1;    // if original value of dest was 1, set N bit
        }
    }

    instruction "decd" ops: SINGLE_W {
	    opcode = 0b1000;         //emulated by subtraction  operation
	    execute = {
 	        local original: short = read(ops.source);
            write(ops.source, performSubtractionW(original, 2, 0));
	        if (original == 2)
	            N = 1;    //if original value of dest was 2, set N bit
	    }
    }

    instruction "decd.b" ops: SINGLE_B {
	    opcode = 0b1000;         //emulated by subtraction  operation
	    execute = {
 	        local original: byte = read(ops.source);
            write(ops.source, performSubtraction(original, 2, 0));
	        if (original == 2)
	            N = 1;    //if original value of dest was 2, set N bit
	    }
    }

    instruction "dint" {       // disable general interrupts
        opcode = 0b1100;       // emulated by BIC operation
	    execute = {
	        disableInterrupts();
	    }
    }

    instruction "eint" {       // enable general interrupts
	    opcode = 0b1101;       // emulated by BIS operation
	    execute = {
	        enableInterrupts();
	    }
    }

    instruction "inc" ops: SINGLE_W {     // increment dest
	    opcode = 0b0101;                  // emulated by ADD operation
	    execute = {
	        write(ops.source, performAdditionW(read(ops.source), 1, 0);
 	    }
    }

    instruction "inc.b" ops: SINGLE_B {     // increment dest
	    opcode = 0b0101;                    // emulated by ADD operation
	    execute = {
	        write(ops.source, performAdditionW(read(ops.source), 1, 0);
 	    }
    }

    instruction "incd" ops: SINGLE_W {      //double increment dest
	    opcode = 0b0101;	    //emulated by ADD operation
	    execute = {
	        write(ops.source, performAdditionW(read(ops.source), 2, 0);
	    }
    }

    instruction "incd.b" ops: SINGLE_B {      //double increment dest
	    opcode = 0b0101;	    //emulated by ADD operation
	    execute = {
	        write(ops.source, performAdditionW(read(ops.source), 2, 0);
	    }
    }

    instruction "inv" ops: SINGLE_W  {       //invert dest
	    opcode = 0b1110;    //emulated by XOR operation
	    execute = {
   	        local result: int = ~(read(ops.source));
	        N = result[15];             //set if neg.
	        Z = (result == 0xFFFF);  //set if contains 0FFFFh
	        C = !(result == 0);      //set if result not 0
	        V = ($regs(rd) < 0);     //set if original contents neg.
	        write(ops.source, result);
	    }
    }

    instruction "inv.b" ops: SINGLE_B  {       //invert dest
	    opcode = 0b1110;    //emulated by XOR operation
	    execute = {
   	        local result: int = ~(read(ops.source));
	        N = results[7];             //set if neg.
	        Z = (results == 0xFF);  //set if contains 0FFh
	        C = !(results == 0);      //set if result not 0
	        V = (low($regs(rd)) < 0);     //set if original contents neg.
	        write(ops.source, result);
	    }
    }

    instruction "jc" ops: JUMP_W  {      //jump if carry set
	    opcode = 0b00101100;
	    execute = {
 	        if ( C ) {
 	            nextPC = nextPC + 2 * read(ops.source);
	        }
        }
    }

    instruction "jhs" ops: JUMP_W  {      //jump if higher or same
	    opcode = 0b00101100;
	    execute = {
 	        if ( C ) {
 	            nextPC = nextPC + 2 * read(ops.source);
	        }
        }
    }

    instruction "jeq" ops: JUMP_W {      //jump if equal
	    opcode = 0b00100100;
	    execute = {
	        if ( Z ) {
 	            nextPC = nextPC + 2 * read(ops.source);
            }
        }
    }

    instruction "jz" ops: JUMP_W {      //jump if zero
	    opcode = 0b00100100;
	    execute = {
	        if ( Z ) {
 	            nextPC = nextPC + 2 * read(ops.source);
            }
        }
    }

    instruction "jge" ops: JUMP_W {   //jump if greater or equal
	    opcode = 0b001101000;
	    execute = {
	        if ( Z  xor N ) {
 	            nextPC = nextPC + 2 * read(ops.source);
	        }
	    }
    }

    instruction "jl" ops: JUMP_W {   //jump if less
        opcode = 0b00111000;
        execute = {
             if ( N xor Z ) {
 	            nextPC = nextPC + 2 * read(ops.source);
             }
    	 }
    }

    instruction "jmp" ops: JUMP_W {  //jump unconditionally
	    opcode = 0b00111100;
	    execute = {
            //jump to address listed by 10 bit offset, unconditionally
 	        nextPC = nextPC + 2 * read(ops.source);
	    }
    }

    instruction "jn" ops: JUMP_W {   //jump if negative
	    opcode = 0b00110000;
	    execute = {
	        if ( N ) {
			    //if N = 1, jump to address listed by 10 bit offset
 	            nextPC = nextPC + 2 * read(ops.source);
	        }
        }
    }

    instruction "jnc" ops: JUMP_W {  //jump if carry not set
	    opcode = 0b00101000;
	    execute = {
	        if ( !C ) {
			    //if C != 0, jump to address listed by 10 bit offset
 	            nextPC = nextPC + 2 * read(ops.source);
	        }
        }
    }

    instruction "jlo" ops: JUMP_W {  //jump if carry not set
	    opcode = 0b00101000;
	    execute = {
            if ( !C ) {
                //if C != 0, jump to address listed by 10 bit offset
 	            nextPC = nextPC + 2 * read(ops.source);
            }
        }
    }

    instruction "jne" ops: JUMP_W {  //jump if not equal
        opcode = 0b00100000;
        execute = {
            if ( !Z ) {
                //if Z != 0, jump to address listed by 10 bit offset
 	            nextPC = nextPC + 2 * read(ops.source);
            }
        }
    }

    instruction "jnz" ops: JUMP_W {  //jump if not equal
	    opcode = 0b00100000;
	    execute = {
	        if ( !Z ) {
			    //if Z != 0, jump to address listed by 10 bit offset
 	            nextPC = nextPC + 2 * read(ops.source);
	        }
	    }
    }

    instruction "mov" ops: DOUBLE_W {  //move source to dest
        opcode = 0b0100;
        execute = {
            write(ops.dest, read(ops.source));
        }
    }

    instruction "mov.b" ops: DOUBLE_B {  //move source to dest
        opcode = 0b0100;
        execute = {
            write(ops.dest, read(ops.source));
        }
    }

    instruction "nop" {   //no operation
        opcode = 0b0100;     //emulated by MOV operation
        execute = {
        }
    }

    instruction "pop" ops: SINGLE_W  {  // pop word from stack to dest
        opcode = 0b0100;   // emulated by MOV operation
        execute = {
            write(ops.source, popWord());         // move temp to dest
        }
    }

    instruction "pop.b" ops: SINGLE_B  {  //pop byte from stack to dest
        opcode = 0b0100;   //emulated by MOV operation
        execute = {
            write(ops.source, popByte());         // move temp to dest
        }
    }

    instruction "push" ops: SINGLE_W {  //push word onto stack
        opcode = 0b00010010;
        execute = {
            pushWord(read(ops.source));
        }
    }

    instruction "push.b" ops: SINGLE_B {  //push byte onto stack
        opcode = 0b00010010;
        execute = {
            pushByte(read(ops.source));
        }
    }

    instruction "ret"  {    //return from subroutine
        opcode = 0b0100;
        execute = {
            nextPC = popWord();
        }
    }

    instruction "reti" {    //return from interrupt
        opcode = 0b00010011;
        execute = {
            sreg = popWord();
            nextPC = popWord();
        }
    }

    instruction "rla" ops: SINGLE_W {    // rotate left arithmetically
        opcode = 0b0101;            // emulated by add instruction (add dst, dst)
        execute = {
            local dest: short = read(ops.source);
            C = dest[15];        // move MSB into carry
            V = (dest > 0x3FFF and dest < 0xC000);  //overflow if >= 4000h and less than C000h
            dest = dest << 1;    // shifting left 1 position
            N = dest[15];        // setting Neg. bit
            Z = (dest == 0);     // set Z bit if equal to zero
            write(ops.source, dest);
        }
    }

    instruction "rla.b" ops: SINGLE_B {    // rotate left arithmetically
        opcode = 0b0101;                   // emulated by add instruction (add dst, dst)
        execute = {
            local dest:int = read(ops.source);
            C = dest[7];        // move MSB into carry
            V = (dest > 0x3F and dest < 0xC0);  //overflow if >= 40h and less than C0h
            dest = dest << 1;   // shifting left 1 position
            N = dest[7];        // setting Neg. bit
            Z = (dest == 0);    // set Z bit if equal to zero
            write(ops.source, dest);
        }
    }

    instruction "rlc" ops: SINGLE_W {    //rotate left through carry
        opcode = 0b0110;       // emulated by addc instruction (addc dst, dst)
        execute = {
            local dest: short = read(ops.source);
            local tempC: int = bit(C);
            C = dest[15];      // move MSB into carry
            V = (dest > 0x3FFF and dest < 0xC000);  //overflow if >= 4000h and less than C000h
            dest = dest << 1 | tempC;    //shifting left 1 position
            N = dest[15];      // setting Neg. bit
            Z = (dest == 0);   // set Z bit if equal to zero
            $regs(rd) = dest;  // move shifted result into destination
            write(ops.source, dest);
        }
     }

    instruction "rlc.b" ops: SINGLE_B {    //rotate left through carry
        opcode = 0b0110;       // emulated by addc instruction (addc dst, dst)
        execute = {
            local dest:int = read(ops.source);
            local tempC:int = bit(C);
            C = dest[7];       // move MSB into carry
            V = (dest > 0x3F and dest < 0xC0);  //overflow if >= 40h and less than C0h
            dest = dest << 1 | tempC;    //shifting left 1 position
            N = dest[7];       // setting Neg. bit
            Z = (dest == 0);   // set Z bit if equal to zero
            write(ops.source, dest);
        }
     }

    instruction "rra" ops: SINGLE_W  {     //rotate right arithmetically
        opcode = 0b00010001;
        execute = {
            local temp: short = read(ops.source);
            C = temp[0];             // move LSB into Carry
            temp = temp >> 1;        // shift 1 right ( i think)
            N = temp[15];
            Z = (temp == 0);
            V = 0;                   // reset overflow bit
            write(ops.source, temp);
	    }
    }

    instruction "rra.b" ops: SINGLE_B  {     //rotate right arithmetically
        opcode = 0b000100010100;
        execute = {
            local temp: byte = read(ops.source);
            C = temp2[0];            // move LSB into Carry
            temp = temp >> 1;        // shift 1 right ( i think)
            N = temp[7];
            Z = (temp == 0);
            V = 0;                   // reset overflow bit
            write(ops.source, temp);
        }
    }

    instruction "rrc" ops: SINGLE_W  {    //rotate right through carry
        opcode = 0b00010000;
        execute = {
            local temp: short = read(ops.source);
            local oldC: int = bit(C);
            C = temp[0];          // carry loaded from original LSB
            temp = temp >> 1 | oldC << 15;      //shift 1 bit right
            N = temp[15];
            Z = (temp == 0);
            V = (temp[14] == 0 and oldC == 1)  //set if inital dest pos. and inital carry was set
            write(ops.source, temp);
        }
    }

    instruction "rrc.b" ops: SINGLE_B  {    //rotate right through carry
        opcode = 0b000100000100;
        execute = {
            local temp: short = read(ops.source);
            local oldC: int = bit(C);
            C = temp2[0];         //Carry loaded from original LSB
            temp = temp >> 1 | oldC << 7;      //shift 1 bit right
            N = temp[7];
            Z = (temp == 0);
            V = (temp[6] == 0 and oldC == 1)  //set if inital dest pos. and inital carry was set
            write(ops.source, temp);
        }
    }

    instruction "sbc" ops: SINGLE_W {    // subtract source and borrow/.NOT. carry from dest
        opcode = 0b0111;                 // emulated by SUBC instruction
        execute = {
            local dest: short = read(ops.source);
            local highbit:int = dest[15];
            // TODO: why not emulate this with the performSubtraction method?
            dest = dest + 0xFFFF + bit(C);  //carry bit is added to dest minus one
            N = dest[15];
            Z = (dest == 0);
            C = ((highbit > dest[15]) and (bit(C) == 0));  //if and overflow occured in MSB, set carry
            V = (dest > 0xFFFF);   //set overflow if arithmetic overflow occurs
            write(ops.source, dest);
	    }
    }

    instruction "sbc.b" ops: SINGLE_B {    //subtract source and borrow/.NOT. carry from dest
        opcode = 0b0111;      //emulated by SUBC instruction
        execute = {
            local dest: short = read(ops.source);
            local highbit:int = dest[7];
            dest = dest + 0xFF + bit(C);  //carry bit is added to dest minus one
            N = dest[7];
            Z = (dest == 0);
            C = ((highbit > dest[7]) and (bit(C) == 0));  //if and overflow occured in MSB, set carry
            V = (dest > 0xFF);   //set overflow if arithmetic overflow occurs
            write(ops.source, dest);
        }
    }

    instruction "setc"    {     //set carry bit
        opcode = 0b1101;    //emulated by the BIS operation
        execute = {
            C = true;
        }
    }

    instruction "setn"   {   //set Negative bit
        opcode = 0b1101;   //emulated by the BIS operation
        execute = {
            N = true;
        }
    }

    instruction "setz"  {   /set zero bit
        opcode = 0b1101;   //emulated by the BIS operation
        execute = {
            Z = true;
        }
    }

    instruction "sub" ops: DOUBLE_W {   //subtract source from dest
        opcode = 0b1000;
        execute = {
            local r1: short = read(ops.source);
            local r2: short = read(ops.dest);
            local results: int = r1 + ~(r2) + 1;
            local Rd15: boolean = r1[15];
            local Rr15: boolean = r2[15];
            local R15:  boolean = results[15];
            C = (!Rd15 and Rr15) or (Rr15 and R15) or (R15 and !Rd15);
            N = R15;
            Z = result == 0;
            V = (Rd15 and !Rr15 and !R15) or (!Rd15 and Rr15 and R15);
            write(ops.dest, results);
    	}
    }

    instruction "sub.b" ops: DOUBLE_B {   //subtract source from dest
        opcode = 0b1000;
        execute = {
            local r1: byte = read(ops.source);
            local r2: byte = read(ops.dest);
            local results:int = r1 + ~(r2) + 1;
            local Rd7: boolean = r1[7];
            local Rr7: boolean = r2[7];
            local R7:  boolean = results[7];
            C = (!Rd7 and Rr7) or (Rr7 and R7) or (R7 and !Rd7);
            N = R7;
            Z = result == 0;
            V = (Rd7 and !Rr7 and !R7) or (!Rd7 and Rr7 and R7);
            write(ops.dest, results);
    	}
    }

    instruction "subc" ops: DOUBLE_W  {    //sub source and borrow/.NOT. carry from dest
        opcode = 0b0111;
        execute = {
            local r1: short = read(ops.source);
            local r2: short = read(ops.dest);
            local results:int = r1 + ~(r2) + bit(C);
            local Rd15: boolean = r1[15];
            local Rr15: boolean = r2[15];
            local R15:  boolean = results[15];
            C = (!Rd15 and Rr15) or (Rr15 and R15) or (R15 and !Rd15);
            N = R15;
            Z = result == 0;
            V = (Rd15 and !Rr15 and !R15) or (!Rd15 and Rr15 and R15);
            write(ops.dest);
	    }
    }

    instruction "subc.b" ops: DOUBLE_B {    //sub source and borrow/.NOT. carry from dest
        opcode = 0b0111;
        execute = {
            local r1: byte = read(ops.source);
            local r2: byte = read(ops.dest);
            local results:int = r1 + ~(r2) + bit(C);
            local Rd7: boolean = r1[7];
            local Rr7: boolean = r2[7];
            local R7:  boolean = results[7];
            C = (!Rd7 and Rr7) or (Rr7 and R7) or (R7 and !Rd7);
            N = R7;
            Z = result == 0;
            V = (Rd7 and !Rr7 and !R7) or (!Rd7 and Rr7 and R7);
            write(ops.dest, results);
 	    }
    }

    instruction "sbb"  ops: DOUBLE_W  {    //sub source and borrow/.NOT. carry from dest
	    opcode = 0b0111;                         //same operation as SUBC, different syntax
	    execute = {
            local r1: short = read(ops.source);
            local r2: short = read(ops.dest);
	        local results: int = r1 + ~(r2) + bit(C);
            local Rd15: boolean = r1[15];
            local Rr15: boolean = r2[15];
            local R15:  boolean = results[15];
            C = (!Rd15 and Rr15) or (Rr15 and R15) or (R15 and !Rd15);
            N = R15;
            Z = result == 0;
            V = (Rd15 and !Rr15 and !R15) or (!Rd15 and Rr15 and R15);
            write(ops.dest, results);
	    }
    }

    instruction "sbb.b" ops: DOUBLE_B {    //sub source and borrow/.NOT. carry from dest
        opcode = 0b0111;                            //same operation as SUBC, different syntax
        execute = {
            local r1: byte = read(ops.source);
            local r2: byte = read(ops.dest);
            local results:int = r1 + ~(r2) + bit(C);
            local Rd7: boolean = r1[7];
            local Rr7: boolean = r2[7];
            local R7:  boolean = results[7];
            C = (!Rd7 and Rr7) or (Rr7 and R7) or (R7 and !Rd7);
            N = R7;
            Z = result == 0;
            V = (Rd7 and !Rr7 and !R7) or (!Rd7 and Rr7 and R7);
            write(ops.dest, results);
 	    }
    }

    instruction "swpb" ops: SINGLE_W {   //swap bytes
        opcode = 0b000100001000;
        execute = {
           local temp1: short = read(ops.source);   //contains original
           local temp2: short = temp1;   //eventually contains swapped bytes
           temp2[15:8] = temp1[7:0];
           temp2[7:0] = temp1[15:8];
           write(ops.source, temp2);
        }
    }

    instruction "sxt" ops: SINGLE_W {  //extend sign
        opcode = 0b000100011000;
        execute = {
            local r1: short = read(ops.source);
            r1 = (r1 << 8) >> 8;
            N = r1[15];      // set if result is negative
            Z = (r1 == 0);   // set if result is zero
            C = !Z;          // set if result not zero
            V = false;       // reset
            write(ops.source, r1);
        }
    }

    instruction "tst" ops: SINGLE_W {  //test destination
        opcode = 0b1001;
        execute = {
            local r1: int = read(ops.source);
            N = r1[15];       // if dest is negative, set
            Z = (r1 == 0);    // if dest contains 0, set
            C = true;         // set carry
            V = false;        // reset overflow
        }
    }

    instruction "tst.b" ops: SINGLE_B {  //test destination
        opcode = 0b1001;
        execute = {
            local r1: int = read(ops.source);
            N = r1[7];       //if dest is negative, set
            Z = (r1 == 0);   //if dest contains 0, set
            C = true;   //set carry
            V = false;   //reset overflow
        }
    }

    instruction "xor" ops: DOUBLE_W {  //Exclusive OR of source with dest
        opcode = 1110;
        execute = {
            local source: int = read(ops.source);
            local dest: int = read(ops.dest);
            dest = dest ^ source;
            N = dest[15];
            Z = (dest == 0);
            C = !Z;
            V = ((source < 0) and (dest < 0));
            write(ops.dest, dest);
        }
    }

    instruction "xor.b" ops: DOUBLE_B {  //Exclusive OR of source with dest
	    opcode = 1110;
	    execute = {
            local source: int = read(ops.source);
            local dest: int = read(ops.dest);
            dest = dest ^ source;
            N = dest[7];
            Z = (dest == 0);
            C = !Z;
            V = ((source < 0) and (dest < 0));
            write(ops.dest, dest);
        }
    }

}
