architecture avr {

//---------------------------------------------------------------------------
//  ENCODING FORMATS OF INSTRUCTIONS
//---------------------------------------------------------------------------

    format GPRGPR = { opcode[6:0], r2[4:4], r1[4:4], r1[3:0], r2[3:0] };
    format GPR = { opcode[7:0], r1[4:4], r1[3:0], 0b0101 };
    format HGPRIMM8 = { opcode[3:0], imm1[7:4], r1[4:1], imm1[3:0] };
    format BRSET = { 0b111100, target[6:0], bit[2:0] };
    format BRCLR = { 0b111101, target[6:0], bit[2:0] };
    format SET = { 0b10010100, 0b0, bit[2:0], 0b1000 };
    format CLR = { 0b10010100, 0b1, bit[2:0], 0b1000 };
    format ABS4 = { opcode[9:3], target[21:17], opcode[2:0], target[16:0] };
    format MGPRMGPR = { opcode[7:0], s1[0], (r1 - 16)[2:0], s2[0], (r2 - 16)[2:0] };


//---------------------------------------------------------------------------
//  OPERANDS ALLOWED TO INSTRUCTIONS
//---------------------------------------------------------------------------

    operand GPR: register = {
         r0,  r1,  r2,  r3,  r4,  r5,  r6,  r7,
         r8,  r9, r10, r11, r12, r13, r14, r15,
        r16, r17, r18, r19, r20, r21, r22, r23,
        r24, r25, r26, r27, r28, r29, r30, r31
    };

    operand HGPR: register = {
        r16, r17, r18, r19, r20, r21, r22, r23,
        r24, r25, r26, r27, r28, r29, r30, r31
    };

    operand MGPR: register = {
        r16, r17, r18, r19, r20, r21, r22, r23
    };

    operand YZ: register = {
        y, z
    };

    operand Z: register = {
        z
    };

    operand EGPR: register = {
         r0,  r2,  r4,  r6,
         r8, r10, r12, r14,
        r16, r18, r20, r22,
        r24, r26, r28, r30
    };

    operand RDL: register = {
        r24, r26, r28, r30
    };

//---------------------------------------------------------------------------
//  SUBROUTINES
//---------------------------------------------------------------------------
    subroutine performAddition(r1: int, r2: int, carry: int): int {
        local result: int = r1 + r2 + carry;
        local ral: int = r1[3:0];
        local rbl: int = r2[3:0];

        local Rd7: boolean = r1[7];
        local Rr7: boolean = r2[7];
        local R7: boolean = result[7];

        // set the flags as per instruction set documentation.
        H = (ral + rbl + carry)[4];
        C = result[8];
        N = result[7];
        Z = low(result) == 0;
        V = (Rd7 and Rr7 and !R7) or (!Rd7 and !Rr7 and R7);
        S = N xor V;

        return result;
    };

    subroutine performSubtraction(r1: int, r2: int, carry: int): int {
        local result: int = r1 - r2 - carry;

        local Rd7: boolean = r1[7];
        local Rr7: boolean = r2[7];
        local R7:  boolean = result[7];
        local Rd3: boolean = r1[3];
        local Rr3: boolean = r2[3];
        local R3:  boolean = result[3];

        // set the flags as per instruction set documentation.
        H = (!Rd3 and Rr3) or (Rr3 and R3) or (R3 and !Rd3);
        C = (!Rd7 and Rr7) or (Rr7 and R7) or (R7 and !Rd7);
        N = R7;
        Z = low(result) == 0;
        V = (Rd7 and !Rr7 and !R7) or (!Rd7 and Rr7 and R7);
        S = N xor V;

        return result;
    };

    // perform subtraction, but preserve zero flag if result is zero
    subroutine performSubtractionPZ(r1: int, r2: int, carry: int): int {
        local result: int = r1 - r2 - carry;

        local Rd7: boolean = r1[7];
        local Rr7: boolean = r2[7];
        local R7:  boolean = result[7];
        local Rd3: boolean = r1[3];
        local Rr3: boolean = r2[3];
        local R3:  boolean = result[3];

        // set the flags as per instruction set documentation.
        H = (!Rd3 and Rr3) or (Rr3 and R3) or (R3 and !Rd3);
        C = (!Rd7 and Rr7) or (Rr7 and R7) or (R7 and !Rd7);
        N = R7;
        Z = (low(result) == 0) and Z;
        V = (Rd7 and !Rr7 and !R7) or (!Rd7 and Rr7 and R7);
        S = N xor V;
    };

    subroutine performLeftShift(r1: int, lowbit: boolean): int {
        local result: int = r1 << 1;
        result[0] = lowbit;

        H = result[4];
        C = result[8];
        N = result[7];
        Z = low(result) == 0;
        V = N xor C;
        S = N xor V;

        return result;
    };

    subroutine performRightShift(r1: int, highbit: boolean): int {
        local result: int = ((r1 & 0xff) >> 1);
        if ( highbit ) result[7] = true;

        C = r1[0];
        N = highbit;
        Z = low(result) == 0;
        V = N xor C;
        S = N xor V;

        return result;
    };

    subroutine performOr(r1: int, r2: int): int {
        local result: int = r1 | r2;

        N = result[7];
        Z = low(result) == 0;
        V = false;
        S = N xor V;

        return result;
    };

    subroutine performAnd(r1: int, r2: int): int {
        local result: int = r1 & r2;

        N = result[7];
        Z = low(result) == 0;
        V = false;
        S = N xor V;

        return result;
    };

    subroutine relativeBranch(target: int): void {
        nextPC = relative(target);
        cycles = cycles + 1;
    };

    subroutine relative(target: int): int {
        return (target * 2) + nextPC;
    };

    subroutine absolute(target: int): int {
        return target * 2;
    };

    subroutine skip(): void {
        local dist: int = $isize(nextPC);
        nextPC = nextPC + dist;
        if ( dist == 4 ) cycles = cycles + 1;
        cycles = cycles + 1;
    };

//---------------------------------------------------------------------------
//  BEGIN INSTRUCTION SET DESCRIPTION
//---------------------------------------------------------------------------

    instruction "adc" rd: GPR, rr: GPR {
        encoding = GPRGPR where { opcode = 0b000111, r1 = rd, r2 = rr };
        execute = {
            local r1: byte = $regs(rd);
            local r2: byte = $regs(rr);
            local result: int = performAddition(r1, r2, C);
            $regs(rd) = low(result);
        };
    };

    instruction "add" rd: GPR, rr: GPR { // add second register to first
        encoding = GPRGPR where { opcode = 0b000011, r1 = rd, r2 = rr };
        execute = {
            local r1: byte = $regs(rd);
            local r2: byte = $regs(rr);
            local result: int = performAddition(r1, r2, 0);
            $regs(rd) = low(result);
        };
    };

    instruction "adiw" rd: RDL, imm: IMM6 { // add immediate to word register
        encoding = { 0b10010110, imm[5:4], rd[2:1], imm[3:0] };
        execute = {
            local r1: int       = $wregs(rd);
            local result: int   = r1 + imm;
            local R15: boolean  = result[15];
            local Rdh7: boolean = r1[7];

            C = (!R15 and Rdh7);
            N = (R15);
            V = (!Rdh7 and R15);
            Z = (result[15:0] == 0);
            S = (N xor V);

            $wregs(rd) = result;
        };
    };

    instruction "and" rd: GPR, rr: GPR { // and first register with second
        encoding = GPRGPR where { opcode = 0b001000, r1 = rd, r2 = rr };
        execute = {
            local r1: int = $regs(rd);
            local r2: int = $regs(rr);
            local result: int = performAnd(r1, r2);
            $regs(rd) = low(result);
        };
    };

    instruction "andi" rd: HGPR, imm: IMM8 { // and register with immediate
        encoding = HGPRIMM8 where { opcode = 0b0111, r1 = rd, imm1 = imm };
        execute = {
            local r1: int = $regs(rd);
            local result: int = performAnd(r1, imm);
            $regs(rd) = low(result);
        };
    };

    instruction "asr" rd: GPR {
        encoding = GPR where { opcode = 0b1001010, r1 = rd };
        execute = {
            local r1: byte = $regs(rd);
            local result: int = performRightShift(r1, r1[7]);
            $regs(rd) = low(result);
        };
    };

    instruction "bclr" bit: IMM3 {
        encoding = CLR where { bit = bit };
        execute = {
            $ioregs(SREG)[bit] = false;
        };
    };

    instruction "bld" rr: GPR, bit: IMM3 {
        encoding = { 0b1111100, rr[4:0], 0[0], bit[2:0] };
        execute = {
            $regs(rr)[bit] = T;
        };
    };

    instruction "brbc" bit: IMM3, target: SREL {
        encoding = BRCLR where { bit = bit };
        execute = {
            if (!($ioregs(SREG)[bit]) ) relativeBranch(target);
        };
    };

    instruction "brbs" bit: IMM3, target: SREL {
        encoding = BRSET where { bit = bit };
        execute = {
            if ( $ioregs(SREG)[bit] ) relativeBranch(target);
        };
    };

    instruction "brcc" target: SREL {
        encoding = BRCLR where { bit = 0b000 };
        execute = {
            if ( !C ) relativeBranch(target);
        };
    };

    instruction "brcs" target: SREL {
        encoding = BRSET where { bit = 0b000 };
        execute = {
            if ( C ) relativeBranch(target);
        };
    };

    instruction "break" {
        encoding = { 0b10010101, 0b10011000 };
        execute = {
            stop();
        };
    };

    instruction "breq" target: SREL {
        encoding = BRSET where { bit = 0b001 };
        execute = {
            if ( Z ) relativeBranch(target);
        };
    };

    instruction "brge" target: SREL{
        encoding = BRCLR where { bit = 0b100 };
        execute = {
            if ( !S ) relativeBranch(target);
        };
    };

    instruction "brhc" target: SREL {
        encoding = BRCLR where { bit = 0b101 };
        execute = {
            if ( !H ) relativeBranch(target);
        };
    };

    instruction "brhs" target: SREL {
        encoding = BRSET where { bit = 0b101 };
        execute = {
            if ( H ) relativeBranch(target);
        };
    };

    instruction "brid" target: SREL {
        encoding = BRCLR where { bit = 0b111 };
        execute = {
            if ( !I ) relativeBranch(target);
        };
    };

    instruction "brie" target: SREL {
        encoding = BRSET where { bit = 0b111 };
        execute = {
            if ( I ) relativeBranch(target);
        };
    };

    instruction "brlo" target: SREL {
        encoding = BRSET where { bit = 0b000 };
        execute = {
            if ( C ) relativeBranch(target);
        };
    };

    instruction "brlt" target: SREL {
        encoding = BRSET where { bit = 0b100 };
        execute = {
            if ( S ) relativeBranch(target);
        };
    };

    instruction "brmi" target: SREL {
        encoding = BRSET where { bit = 0b010 };
        execute = {
            if ( N ) relativeBranch(target);
        };
    };

    instruction "brne" target: SREL {
        encoding = BRCLR where { bit = 0b001 };
        execute = {
            if ( !Z ) relativeBranch(target);
        };
    };

    instruction "brpl" target: SREL {
        encoding = BRCLR where { bit = 0b010 };
        execute = {
            if ( !N ) relativeBranch(target);
        };
    };

    instruction "brsh" target: SREL {
        encoding = BRCLR where { bit = 0b000 };
        execute = {
            if ( !C ) relativeBranch(target);
        };
    };

    instruction "brtc" target: SREL {
        encoding = BRCLR where { bit = 0b110 };
        execute = {
            if ( !T ) relativeBranch(target);
        };
    };

    instruction "brts" target: SREL {
        encoding = BRSET where { bit = 0b110 };
        execute = {
            if ( T ) relativeBranch(target);
        };
    };

    instruction "brvc" target: SREL {
        encoding = BRCLR where { bit = 0b011 };
        execute = {
            if ( !V ) relativeBranch(target);
        };
    };

    instruction "brvs" target: SREL {
        encoding = BRSET where { bit = 0b011 };
        execute = {
            if ( V ) relativeBranch(target);
        };
    };

    instruction "bset" bit: IMM3 {
        encoding = SET where { bit = bit };
        execute = {
            $ioregs(SREG)[bit] = true;
        };
    };

    instruction "bst" rr: GPR, bit: IMM3 {
        encoding = { 0b1111101, rr[4:0], 0[0], bit[2:0] };
        execute = {
            T = $regs(rr)[bit];
        };
    };

    instruction "call" target: PADDR {
        encoding = ABS4 where { opcode = 0b1001010111 };
        execute = {
            pushPC(nextPC);
            nextPC = absolute(target);
        };
    };

    instruction "cbi" ior: IMM5, bit: IMM3 {
        encoding = { 0b1001100, ior[4:0], bit[2:0] };
        execute = {
            $ioregs(ior)[bit] = false;
        };
    };

    instruction "cbr" rd: HGPR, imm: IMM8 {
        // note that this is just the ANDI instruction with operand complemented
        encoding = HGPRIMM8 where { opcode = 0b0111, r1 = rd, imm1 = ~imm };
        execute = {
            $regs(rd) = low(performAnd($regs(rd), ~imm));
        };
    };

    instruction "clc" {
        encoding = CLR where { bit = 0b000 };
        execute = {
            C = false;
        };
    };

    instruction "clh" {
        encoding = CLR where { bit = 0b101 };
        execute = {
            H = false;
        };
    };

    instruction "cli" {
        encoding = CLR where { bit = 0b111 };
        execute = {
            I = false;
        };
    };

    instruction "cln" {
        encoding = CLR where { bit = 0b010 };
        execute = {
            N = false;
        };
    };

    instruction "clr" rd: GPR {
        // note that this is equivalent to eor rd, rd
        encoding = GPRGPR where { opcode = 0b001001, r1 = rd, r2 = rr };
        execute = {
            S = false;
            V = false;
            N = false;
            Z = true;
            $regs(rd) = low(0);
        };
    };

    instruction "cls" {
        encoding = CLR where { bit = 0b100 };
        execute = {
            S = false;
        };
    };

    instruction "clt" {
        encoding = CLR where { bit = 0b110 };
        execute = {
            T = false;
        };
    };

    instruction "clv" {
        encoding = CLR where { bit = 0b011 };
        execute = {
            V = false;
        };
    };

    instruction "clz" {
        encoding = CLR where { bit = 0b001 };
        execute = {
            Z = false;
        };
    };

    instruction "com" rd: GPR {
        encoding = { 0b1001010, rd[4:0], 0b0000 };
        execute = {
            local result: int = 0xff - $regs(rd);

            C = true;
            N = result[7];
            Z = low(result) == 0;
            V = false;
            S = N xor V;

            $regs(rd) = low(result);
        };
    };

    instruction "cp" rd: GPR, rr: GPR {
        encoding = GPRGPR where { opcode = 0b000101, r1 = rd, r2 = rr };
        execute = {
            // perform subtraction for flag side effects.
            performSubtraction($regs(rd), $regs(rr), false);
        };
    };

    instruction "cpc" rd: GPR, rr: GPR {
        encoding = GPRGPR where { opcode = 0b000001, r1 = rd, r2 = rr };
        execute = {
            // perform subtraction for flag side effects.
            performSubtraction($regs(rd), $regs(rr), C);
        };
    };

    instruction "cpi" rd: HGPR, imm: IMM8 {
        encoding = HGPRIMM8 where { opcode = 0b0011, r1 = rd, imm1 = imm };
        execute = {
            // perform subtraction for flag side effects.
            performSubtraction($regs(rd), imm, false);
        };
    };

    instruction "cpse" rd: GPR, rr: GPR {
        encoding = GPRGPR where { opcode = 0b000100, r1 = rd, r2 = rr };
        execute = {
            local r1: int = $regs(rd);
            local r2: int = $regs(rr);
            // perform subtraction for flag side effects.
            performSubtraction(r1, r2, 0);
            if (r1 == r2) skip();
        };
    };

    instruction "dec" rd: GPR {
        encoding = { 0b1001010, rd[4:0], 0b1010 };
        execute = {
            local r1: int = $uregs(rd);
            local result: int = r1 - 1;

            N = result[7];
            Z = low(result) == 0;
            V = r1 == 0x80;
            S = N xor V;

            $regs(rd) = low(result);
        };
    };

    instruction "eicall" {
        encoding = { 0b10010101, 0b00011001 };
        execute = {
            // TODO: implement me
        };
    };

    instruction "eijmp" {
        encoding = { 0b10010100, 0b00011001 };
        execute = {
            // TODO: implement me
        };
    };

    instruction "elpm" {
        encoding = { 0b10010101, 0b11011000 };
        execute = {
            local addr: int = $wregs(Z);
            addr[23:16] = $ioregs(RAMPZ);
            $regs(0) = $program(addr);
        };
    };

    instruction "elpmd" rd: GPR, rr: Z {
        // TODO: this is a variant of the ELPM instruction
        encoding = { 0b1001000, rd[4:0], 0b0110 };
        execute = {
            local addr: int = $wregs(Z);
            addr[23:16] = $ioregs(RAMPZ);
            $regs(rd) = $program(addr);
        };
    };

    instruction "elpmpi" rd: GPR, rr: Z {
        // TODO: this is a variant of the ELPM instruction
        encoding = { 0b1001000, rd[4:0], 0b0111 };
        execute = {
            local addr: int = $wregs(Z);
            addr[23:16] = $ioregs(RAMPZ);
            $regs(rd) = $program(addr);
            $wregs(Z) = addr + 1;
        };
    };

    instruction "eor" rd: GPR, rr: GPR {
        encoding = GPR where { opcode = 0b001001, r1 = rd, r2 = rr };
        execute = {
            local result: int = $regs(rd) ^ $regs(rr);

            N = result[7];
            Z = low(result) == 0;
            V = false;
            S = N xor V;

            $regs(rd) = low(result);
        };
    };

    instruction "fmul" rd: MGPR, rr: MGPR {
        encoding = MGPRMGPR where { opcode = 0b0000011, s1 = 0, r1 = rd, s2 = 1, r2 = rr };
        execute = {
            local result: int = ($uregs(rd) * $uregs(rr)) << 1;
            Z = result[15:0] == 0;
            C = result[16];
            $regs(0) = low(result);
            $regs(1) = high(result);
        };
    };

    instruction "fmuls" rd: MGPR, rr: MGPR {
        encoding = MGPRMGPR where { opcode = 0b0000011, s1 = 1, r1 = rd, s2 = 0, r2 = rr };
        execute = {
            local result: int = ($regs(rd) * $regs(rr)) << 1;
            Z = result[15:0] == 0;
            C = result[16];
            $regs(0) = low(result);
            $regs(1) = high(result);
        };
    };

    instruction "fmulsu" rd: MGPR, rr: MGPR {
        encoding = MGPRMGPR where { opcode = 0b0000011, s1 = 1, r1 = rd, s2 = 1, r2 = rr };
        execute = {
            local result: int = ($regs(rd) * $uregs(rr)) << 1;
            Z = result[15:0] == 0;
            C = result[16];
            $regs(0) = low(result);
            $regs(1) = high(result);
        };
    };

    instruction "icall" {
        encoding = { 0b10010101, 0b000001001 };
        execute = {
            pushPC(nextPC);
            nextPC = absolute($wregs(0));
        };
    };

    instruction "ijmp" {
        encoding = { 0b10010100, 0b00001001 };
        execute = {
            nextPC = absolute($wregs(0));
        };
    };

    instruction "in" rd: GPR, imm: IMM6 {
        encoding = { 0b10110, imm[5:4], rd[4:0], imm[3:0] };
        execute = {
            $regs(rd) = $ioregs(imm);
        };
    };

    instruction "inc" rd: GPR {
        encoding = { 0b1001010, rd[4:0], 0b0011 };
        execute = {
            local r1: int = $uregs(rd);
            local result: int = r1 + 1;

            N = result[7];
            Z = low(result) == 0;
            V = r1 == 0x7f;
            S = N xor V;

            $regs(rd) = low(result);
        };
    };

    instruction "jmp" target: PADDR {
        encoding = ABS4 where { opcode = 0b1001010110 };
        execute = {
            nextPC = absolute(target);
        };
    };

    instruction "ld" rd: GPR, ar: ADR {
        // TODO: THIS ENCODING IS NOT CORRECT
        encoding = { 0b1001000, rd[4:0], 0b1100 };
        execute = {
            $regs(rd) = $sram($wregs(ar));
        };
    };

    instruction "ldd" rd: GPR, ar: YZ, imm: IMM6 {
        // TODO: THIS ENCODING IS NOT CORRECT
        encoding = { 0b1001000, rd[4:0], 0b1100 };
        execute = {
            $regs(rd) = $sram($wregs(ar) + imm);
        };
    };

    instruction "ldi" rd: HGPR, imm: IMM8 {
        encoding = HGPRIMM8 where { opcode = 0b1110 };
        execute = {
            $regs(rd) = low(imm);
        };
    };

    instruction "ldpd" rd: GPR, ar: ADR {
        // TODO: THIS ENCODING IS NOT CORRECT
        encoding = { 0b1001000, rd[4:0], 0b1100 };
        execute = {
            local addr: int = $wregs(ar) - 1;
            $regs(rd) = $sram(addr);
            $wregs(ar) = addr;
        };
    };

    instruction "ldpi" rd: GPR, ar: ADR {
        // TODO: THIS ENCODING IS NOT CORRECT
        encoding = { 0b1001000, rd[4:0], 0b1100 };
        execute = {
            local addr: int = $wregs(ar);
            $regs(rd) = $sram(addr);
            $wregs(ar) = addr + 1;
        };
    };

    instruction "lds" rd: GPR, addr: DADDR {
        encoding = { 0b1001000, rd[4:0], 0b0000, addr[15:0] };
        execute = {
            $regs(rd) = $sram(addr);
        };
    };

    instruction "lpm" {
        encoding = { 0b10010101, 0b11001000 };
        execute = {
            $regs(0) = $program($wregs(Z));
        };
    };

    instruction "lpmd" rd: GPR, z: Z {
        // TODO: this is a variant of LPM
        encoding = { 0b1001000, rd[4:0], 0b0100 };
        execute = {
            $regs(rd) = $program($wregs(Z));
        };
    };

    instruction "lpmpi" rd: GPR, z: Z {
        // TODO: this is a variant of LPM
        encoding = { 0b1001000, rd[4:0], 0b0101 };
        execute = {
            local addr: int = $wregs(Z);
            $regs(rd) = $program(addr);
            $wregs(Z) = addr + 1;
        };
    };

    instruction "lsl" rd: GPR {
        encoding = GPRGPR where { opcode = 0b000011, r1 = rd, r2 = rd };
        execute = {
            $regs(rd) = performLeftShift($regs(rd), false);
        };
    };

    instruction "lsr" rd: GPR {
        encoding = { 0b1001010, rd[5:0], 0b0110 };
        execute = {
            $regs(rd) = performRightShift($regs(rd), false);
        };
    };

    instruction "mov" rd: GPR, rr: GPR {
        encoding = GPRGPR where { opcode = 0b001011, r1 = rd, r2 = rr };
        execute = {
            $regs(rd) = $regs(rr);
        };
    };

    instruction "movw" rd: EGPR, rr: EGPR {
        encoding = { 0b00000001, rd[3:0], rr[3:0] };
        execute = {
            $wregs(rd) = $wregs(rr);
        };
    };

    instruction "mul" rd: GPR, rr: GPR {
        encoding = GPRGPR where { opcode = 0b100111, r1 = rr, r2 = rd };
        execute = {
            local result: int = $uregs(rd) * $uregs(rr);
            C = result[15];
            Z = (result[15:0] == 0);
            $wregs(0) = result;
        };
    };

    instruction "muls" rd: HGPR, rr: HGPR {
        encoding = { 0b00000010, rd[3:0], rr[3:0] };
        execute = {
            local result: int = $regs(rd) * $regs(rr);
            C = result[15];
            Z = (result[15:0] == 0);
            $wregs(0) = result;
        };
    };

    instruction "mulsu" rd: MGPR, rr: MGPR {
        encoding = { 0b00000011, 0[0], (rd - 16)[2:0], 0[0], (rr - 16)[2:0] };
        execute = {
            local result: int = $regs(rd) * $uregs(rr);
            C = result[15];
            Z = (result[15:0] == 0);
            $wregs(0) = result;
        };
    };

    instruction "neg" rd: GPR {
        encoding = { 0b1001010, rd[4:0], 0b0001 };
        execute = {
            $regs(rd) = performSubtraction(0, $regs(rd), false);
        };
    };

    instruction "nop" {
        encoding = { 0b00000000, 0b00000000 };
        execute = {
            // do nothing.
        };
    };

    instruction "or" rd: GPR, rr: GPR {
        encoding = GPRGPR where { opcode = 0b001010, r1 = rd, r2 = rr };
        execute = {
            $regs(rd) = performOr($regs(rd), $regs(rr));
        };
    };

    instruction "ori" rd: HGPR, imm: IMM8 {
        encoding = HGPRIMM8 where { opcode = 0b0110 };
        execute = {
            $regs(rd) = performOr($regs(rd), imm);
        };
    };

    instruction "out" ior: IMM6, rr: GPR {
        encoding = { 0b10011, ior[5:4], rr[4:0], ior[3:0] };
        execute = {
            $ioreg(ior) = $regs(rr);
        };
    };

    instruction "pop" rd: GPR {
        encoding = { 0b1001000, rd[4:0], 0b1111 };
        execute = {
            $regs(rd) = popByte();
        };
    };

    instruction "push" rr: GPR {
        encoding = { 0b1001001, rd[4:0], 0b1111 };
        execute = {
            pushByte($regs(rr));
        };
    };

    instruction "rcall" target: LREL {
        encoding = { 0b1101, target[11:0] };
        execute = {
            pushPC(nextPC);
            nextPC = relative(target);
        };
    };

    instruction "ret" {
        encoding = { 0b100101010, 0b00010000 };
        execute = {
            nextPC = popPC();
        };
    };

    instruction "reti" {
        encoding = { 0b10010101, 0b00011000 };
        execute = {
            nextPC = popPC();
            I = true;
            justReturnedFromInterrupt = true;
        };
    };

    instruction "rjmp" target: LREL {
        encoding = { 0b1100, target[11:0] };
        execute = {
            nextPC = relative(target);
        };
    };

    instruction "rol" rd: GPR {
        encoding = GPRGPR where { opcode = 0b000111, r1 = rd, r2 = rd };
        execute = {
            $regs(rd) = performLeftShift($regs(rd), C);
        };
    };

    instruction "ror" rd: GPR {
        encoding = { 0b1001010, rd[4:0], 0b0111 };
        execute = {
            $regs(rd) = performRightShift($regs(rd), C);
        };
    };

    instruction "sbc" rd: GPR, rr: GPR {
        encoding = GPRGPR where { opcode = 0b0000010, r1 = rd, r2 = rr };
        execute = {
            $regs(rd) = performSubtractionPZ($regs(rd), $regs(rr), C);
        };
    };

    instruction "sbci" rd: HGPR, imm: IMM8 {
        encoding = HGPRIMM8 where { opcode = 0b0100, r1 = rd };
        execute = {
            $regs(rd) = performSubtractionPZ($regs(rd), imm, C);
        };
    };

    instruction "sbi" ior: IMM5, bit: IMM3 {
        encoding = { 0b10011010, ior[4:0], bit[2:0] };
        execute = {
            $ioregs(ior)[bit] = true;
        };
    };

    instruction "sbic" ior: IMM5, bit: IMM3 {
        encoding = { 0b10011001, ior[4:0], bit[2:0] };
        execute = {
            if (!($ioregs(ior)[bit])) skip();
        };
    };

    instruction "sbis" imm1: IMM5, bit: IMM3 {
        encoding = { 0b10011011, ior[4:0], bit[2:0] };
        execute = {
            if ( $ioregs(ior)[bit] ) skip();
        };
    };

    instruction "sbiw" rd: RDL, imm: IMM6 {
        encoding = { 0b10010111, imm[5:4], rd[2:1], imm[3:0] };
        execute = {
            local val: int = $wregs(rd);
            local result: int = val - imm;

            local Rdh7: boolean = val[15];
            local R15: boolean = result[15];

            V = Rdh7 and !R15;
            N = R15;
            Z = result[15:0] == 0;
            C = R15 and !Rdh7;
            S = N xor V;

            $wregs(rd) = result;
        };
    };

    instruction "sbr" rd: HGPR, imm: IMM8 {
        encoding = HGPRIMM8 where { opcode = 0b0110 };
        execute = {
            $regs(rd) = performOr($regs(rd), imm);
        };
    };

    instruction "sbrc" rr: GPR, bit: IMM3 {
        encoding = { 0b1111110, rr[4:0], 0[0], bit[2:0] };
        execute = {
            if (!($regs(rr)[bit])) skip();
        };
    };

    instruction "sbrs" rr: GPR, bit: IMM3 {
        encoding = { 0b1111111, rr[4:0], 0[0], bit[2:0] };
        execute = {
            if ( $regs(rr)[bit] ) skip();
        };
    };

    instruction "sec" {
        encoding = SET where { bit = 0b000 };
        execute = {
            C = true;
        };
    };

    instruction "seh" {
        encoding = SET where { bit = 0b101 };
        execute = {
            H = true;
        };
    };

    instruction "sei" {
        encoding = SET where { bit = 0b111 };
        execute = {
            I = true;
        };
    };

    instruction "sen" {
        encoding = SET where { bit = 0b010 };
        execute = {
            N = true;
        };
    };

    instruction "ser" rd: HGPR {
        encoding = { 0b11101111, rd[4:1], 0b1111 };
        execute = {
            $regs(rd) = low(0xff);
        };
    };

    instruction "ses" {
        encoding = SET where { bit = 0b100 };
        execute = {
            S = true;
        };
    };

    instruction "set" {
        encoding = SET where { bit = 0b110 };
        execute = {
            T = true;
        };
    };

    instruction "sev" {
        encoding = SET where { bit = 0b011 };
        execute = {
            V = true;
        };
    };

    instruction "sez" {
        encoding = SET where { bit = 0b001 };
        execute = {
            Z = true;
        };
    };

    instruction "sleep" {
        encoding = { 0b10010101, 0b10001000 };
        execute = {
            enterSleepMode();
        };
    };

    instruction "spm" {
        encoding = { 0b10010101, 0b11101000 };
        execute = {
            // TODO: don't know how this instruction behaves
        };
    };

    instruction "st" ar: ADR, rr: GPR {
        // TODO: THIS ENCODING IS NOT CORRECT
        encoding = { 0b1001000, rd[4:0], 0b1100 };
        execute = {
            $sram($wregs(ar)) = $regs(rr);
        };
    };

    instruction "std" ar: YZ, imm: IMM6, rr: GPR {
        // TODO: THIS ENCODING IS NOT CORRECT
        encoding = { 0b1001000, rd[4:0], 0b1100 };
        execute = {
            $sram($wregs(ar) + imm) = $regs(rr);
        };
    };

    instruction "stpd" ar: ADR, rr: GPR {
        // TODO: THIS ENCODING IS NOT CORRECT
        encoding = { 0b1001000, rd[4:0], 0b1100 };
        execute = {
            local addr: int = $wregs(ar) - 1;
            $sram(addr) = $regs(rr);
            $wregs(ar) = addr;
        };
    };

    instruction "stpi" ar: ADR, rr: GPR {
        // TODO: THIS ENCODING IS NOT CORRECT
        encoding = { 0b1001000, rd[4:0], 0b1100 };
        execute = {
            local addr: int = $wregs(ar);
            $sram(addr) = $regs(rr);
            $wregs(ar) = addr + 1;
        };
    };

    instruction "sts" addr: DADDR, rr: GPR {
        encoding = { 0b1001001, rr[4:0], 0b0000, addr[15:0] };
        execute = {
            $sram(addr) = $regs(rr);
        };
    };

    instruction "sub" rd: GPR, rr: GPR {
        encoding = GPRGPR where { opcode = 0b000110, r1 = rd, r2 = rr };
        execute = {
            $regs(rd) = performSubtraction($regs(rd), $regs(rr), false);
        };
    };

    instruction "subi" rd: HGPR, imm: IMM8 {
        encoding = HGPRIMM8 where { opcode = 0b0101 };
        execute = {
            $regs(rd) = performSubtraction($regs(rd), imm, false);
        };
    };

    instruction "swap" rd: GPR {
        encoding = { 0b1001010, rd[4:0], 0b0010 };
        execute = {
            local val: byte = $regs(rd);
            local result: byte = 0;
            result[3:0] = val[7:4];
            result[7:4] = val[3:0];
            $regs(rd) = result;
        };
    };

    instruction "tst" rd: GPR {
        encoding = GPRGPR where { opcode = 0b001000, r1 = rd, r2 = rd };
        execute = {
            local r1: int = $regs(rd);
            V = false;
            Z = low(r1) == 0;
            N = r1[7];
            S = N xor V;
        };
    };

    instruction "wdr" {
        encoding = { 0b10010101, 0b10101000 };
        execute = {
            // do nothing.
        };
    };

}